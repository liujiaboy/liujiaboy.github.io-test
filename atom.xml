<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不会飞的小白</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujiaboy.github.io/"/>
  <updated>2022-12-20T11:19:22.111Z</updated>
  <id>http://liujiaboy.github.io/</id>
  
  <author>
    <name>不会飞的小白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS审核被拒-5.1.1 &amp; 4.7.0 &amp; 3.2.2</title>
    <link href="http://liujiaboy.github.io/2022/12/16/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8-3/"/>
    <id>http://liujiaboy.github.io/2022/12/16/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8-3/</id>
    <published>2022-12-16T10:45:01.000Z</published>
    <updated>2022-12-20T11:19:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-1-1-Legal-Privacy-Data-Collection-and-Storage-amp-4-7-0-Design-HTML5-Games-Bots-etc-amp-3-2-2-Business-Other-Business-Model-Issues-Unacceptable"><a href="#5-1-1-Legal-Privacy-Data-Collection-and-Storage-amp-4-7-0-Design-HTML5-Games-Bots-etc-amp-3-2-2-Business-Other-Business-Model-Issues-Unacceptable" class="headerlink" title="5.1.1 Legal: Privacy - Data Collection and Storage &amp; 4.7.0 Design: HTML5 Games, Bots, etc. &amp; 3.2.2 Business: Other Business Model Issues - Unacceptable"></a>5.1.1 Legal: Privacy - Data Collection and Storage &amp; 4.7.0 Design: HTML5 Games, Bots, etc. &amp; 3.2.2 Business: Other Business Model Issues - Unacceptable</h1><p>被拒时间：2022.09.25 10:54<br>回复n次<br>过审时间：2022.10.13 23:13</p><p>值得一提的是，这个迭代是被拒的时间最长的一次，真的是搞心态啊，在此记录一下整体的过程。</p><h2 id="第1次被拒"><a href="#第1次被拒" class="headerlink" title="第1次被拒"></a>第1次被拒</h2><blockquote><p>Hello,</p><p>The issues we previously identified still need your attention.</p><p>If you have any questions, we are here to help. Reply to this message in App Store Connect and let us know. Bug Fix Submissions</p><p>The issues we’ve identified below are eligible to be resolved on your next update. If this submission includes bug fixes and you’d like to have it approved at this time, reply to this message and let us know. You do not need to resubmit your app for us to proceed.</p><p>Alternatively, if you’d like to resolve these issues now, please review the details, make the appropriate changes, and resubmit.</p><p>Guideline 5.1.1(v) - Data Collection and Storage</p><p>We noticed that your app supports account creation but does not appear to include an option to initiate account deletion.</p><p>Apps that support account creation must also offer account deletion to give App Store users more control of the data they’ve shared while using your app.</p><p>Next Steps</p><p>If your app already supports account deletion, reply to this message and let us know how to locate this feature. If your app does not support account deletion, revise your app to include an option to initiate account deletion.</p><p>If you are unable to offer account deletion or need to provide additional customer service flows to facilitate and confirm account deletion, either because your app operates in a highly-regulated industry or for some other reason, reply to this message in App Store Connect and provide additional information or documentation. If you have questions regarding your legal obligations, check with your legal counsel.</p><p>Keep these requirements in mind when updating your app to support account deletion:</p><ul><li><p>Only offering to temporarily deactivate or disable an account is insufficient.</p></li><li><p>If users need to visit a website to finish deleting their account, include a link directly to the page on your website where they can complete the process.</p></li><li><p>You may include confirmation steps to prevent users from accidentally deleting their account. However, only apps in highly-regulated industries may require users to use customer service resources, such as making a phone call or sending an email, to complete account deletion.</p></li></ul><p>Resources</p><ul><li><p>Review frequently asked questions and learn more about the <a href="https://developer.apple.com/support/offering-account-deletion-in-your-app" target="_blank" rel="noopener">account deletion requirements</a>.</p></li><li><p>Apps that offer Sign in with Apple should use the <a href="https://developer.apple.com/documentation/sign_in_with_apple/revoke_tokens" target="_blank" rel="noopener">Sign in with Apple REST API</a> to revoke user tokens.</p></li></ul><p>拒绝原因：<br>5.1.1 Legal: Privacy - Data Collection and Storage</p></blockquote><p>这个问题是苹果官方最新审核要求，在2022年6月30号以后，所有提交AppStore商城审核的应用程序支持帐户创建的 App 也必须提供帐户删除功能，否则将不会过审，拒绝原因就是Guideline 5.1.1(v) - Data Collection and Storage。</p><p>当看到这些信息的时候，我们以为是之前的原因，审核人员找不到注销的位置，所以我就把路径标注出来，并录屏作为附件进行了回复。结果，出乎意料，又被拒了，而且被拒的原因又多了一条。</p><h2 id="第2次被拒"><a href="#第2次被拒" class="headerlink" title="第2次被拒"></a>第2次被拒</h2><blockquote><p>Hello,</p><p>The issues we previously identified still need your attention.</p><p>If you have any questions, we are here to help. Reply to this message in App Store Connect and let us know. </p><p>Guideline 5.1.1(v) - Data Collection and Storage</p><p>We noticed that your app supports account creation but does not appear to include an option to initiate account deletion.</p><p>Apps that support account creation must also offer account deletion to give App Store users more control of the data they’ve shared while using your app.</p><p>Next Steps</p><p>If your app already supports account deletion, reply to this message and let us know how to locate this feature. If your app does not support account deletion, revise your app to include an option to initiate account deletion.</p><p>If you are unable to offer account deletion or need to provide additional customer service flows to facilitate and confirm account deletion, either because your app operates in a highly-regulated industry or for some other reason, reply to this message in App Store Connect and provide additional information or documentation. If you have questions regarding your legal obligations, check with your legal counsel.</p><p>Keep these requirements in mind when updating your app to support account deletion:</p><ul><li><p>Only offering to temporarily deactivate or disable an account is insufficient.</p></li><li><p>If users need to visit a website to finish deleting their account, include a link directly to the page on your website where they can complete the process.</p></li><li><p>You may include confirmation steps to prevent users from accidentally deleting their account. However, only apps in highly-regulated industries may require users to use customer service resources, such as making a phone call or sending an email, to complete account deletion.</p></li></ul><p>Resources</p><ul><li>Review frequently asked questions and learn more about the <a href="https://developer.apple.com/support/offering-account-deletion-in-your-app" target="_blank" rel="noopener">account deletion requirements</a>.</li></ul><p>Guideline 4.7 - Design - HTML5 Games, Bots, etc.</p><p>We noticed that your app includes code that is not embedded in the binary, but the software does not fulfill all of the requirements outlined in Guideline 4.7 of the App Store Review Guidelines or you have not provided us with an index of the software available in your app. Specifically, script message handlers in xxWebVC class were found not to be an appropriate implementation as it inappropriately expands standard web capabilities. </p><p>Next Steps</p><p>To resolve this issue, please ensure the software offered in your app:</p><p>– Is not offered in a store or store-like interface.</p><p>– Is free or purchased using in-app purchase.</p><p>– Does not allow e-commerce to transfer funds or game currency.</p><p>– Only uses capabilities available in a standard WebKit view.</p><p>– Is offered by developers that have joined the Apple Developer Program and signed the Apple Developer Program License Agreement.</p><p>– Adheres to the terms of the App Store Review Guidelines.</p><p>Additionally, if you have not done so already, it would be appropriate to provide an up-to-date index of the software and metadata available in your app in the Review Notes section of App Store Connect. This index should include the app name, developer name, game URL, and App Store Connect Team ID for the software.</p></blockquote><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>此为机器翻译。</p><blockquote><p>你好，</p><p>我们之前发现的问题仍然需要您的注意。</p><p>如果您有任何疑问，我们随时为您提供帮助。 在 App Store Connect 中回复此消息并告知我们。</p><p>准则 5.1.1(v) - 数据收集和存储</p><p>我们注意到您的应用程序支持创建帐户，但似乎不包含启动帐户删除的选项。</p><p>支持帐户创建的应用程序还必须提供帐户删除功能，以便 App Store 用户能够更好地控制他们在使用您的应用程序时共享的数据。</p><p>下一步</p><p>如果您的应用程序已经支持删除帐户，请回复此消息并告诉我们如何找到此功能。 如果您的应用不支持帐户删除，请修改您的应用以包含启动帐户删除的选项。</p><p>如果您无法提供帐户删除或需要提供额外的客户服务流程来促进和确认帐户删除，无论是因为您的应用程序在高度监管的行业中运行还是出于其他原因，请在 App Store Connect 中回复此消息并提供 附加信息或文档。 如果您对您的法律义务有疑问，请咨询您的法律顾问。</p><p>在更新您的应用程序以支持帐户删除时，请牢记这些要求：</p><ul><li><p>仅提供暂时停用或禁用帐户是不够的。</p></li><li><p>如果用户需要访问一个网站来完成删除他们的帐户，请在您的网站上包含一个直接指向他们可以完成该过程的页面的链接。</p></li><li><p>您可以包括确认步骤以防止用户意外删除他们的帐户。 但是，只有高度监管行业的应用程序可能需要用户使用客户服务资源，例如拨打电话或发送电子邮件来完成帐户删除。</p></li></ul><p>资源</p><ul><li>查看常见问题并了解有关帐户删除要求的更多信息。</li></ul><p>准则 4.7 - 设计 - HTML5 游戏、机器人等。</p><p>我们注意到您的应用程序包含未嵌入二进制文件中的代码，但该软件未满足 App Store 审查指南第 4.7 条中概述的所有要求，或者您未向我们提供您的可用软件索引 应用程序。 具体来说，发现 xxWebVC 类中的脚本消息处理程序不是合适的实现，因为它不适当地扩展了标准的 Web 功能。</p><p>下一步</p><p>要解决此问题，请确保您的应用中提供的软件：</p><p>– 不在商店或类似商店的界面中提供。</p><p>– 免费或使用应用内购买购买。</p><p>– 不允许电子商务转移资金或游戏货币。</p><p>– 仅使用标准 WebKit 视图中可用的功能。</p><p>– 由加入 Apple Developer Program 并签署 Apple Developer Program License Agreement 的开发者提供。</p><p>– 遵守 App Store 审查指南的条款。</p><p>此外，如果您还没有这样做，最好在 App Store Connect 的评论注释部分提供您的应用程序中可用的软件和元数据的最新索引。 该索引应包括软件的应用程序名称、开发者名称、游戏 URL 和 App Store Connect Team ID。</p></blockquote><h3 id="信息解读"><a href="#信息解读" class="headerlink" title="信息解读"></a>信息解读</h3><h4 id="Guideline-5-1-1-v-Data-Collection-and-Storage"><a href="#Guideline-5-1-1-v-Data-Collection-and-Storage" class="headerlink" title="Guideline 5.1.1(v) - Data Collection and Storage"></a>Guideline 5.1.1(v) - Data Collection and Storage</h4><p>这个还是关于account deletion，讲了一堆关于账号注销的。</p><p>苹果的新规严格要求App必须要设置一个功能，让用户可以“从App中删除他们的账户”，但并没有明确该功能具体要怎么设置。目前来看，这个“删除账户”功能可以很简单，也可以很复杂。有些开发者采取的方式是在个人中心设置注销功能，也有开发者引导用户到客服或发送一封电子邮件告知用户来彻底删除他们的信息，这个可以根据具体需求决定。通俗一点，就是我们须在app的个人中心的设置里面添加账号注销按钮，点击按钮弹窗提示用户是否确认账号注销操作，用户点击确认或取消执行对应操作即可过审。</p><p>所以在重新提交的包中，我们就把注销账号的功能移到了设置中，并明确注销功能是可用的。</p><h4 id="Guideline-4-7-Design-HTML5-Games-Bots-etc"><a href="#Guideline-4-7-Design-HTML5-Games-Bots-etc" class="headerlink" title="Guideline 4.7 - Design - HTML5 Games, Bots, etc."></a>Guideline 4.7 - Design - HTML5 Games, Bots, etc.</h4><p>这里明确了在<code>xxWebVC</code>中，不适当的扩展了web功能，而且，应用程序中可能包含了未嵌入二进制文件中的代码。正因为我们忽略了未嵌入的二进制代码，造成了又一次的审核失败。</p><p>在<code>xxWebVC</code>中，代码的逻辑已经好久没有更新了，关于这个被拒信息，也没有找到合适的解决方案，而我们在这个迭代为了增加H5的秒开率，添加了web复用池的逻辑，所以大家一致认为，可能是这里的逻辑导致的。</p><p>然后我们注销掉了相关逻辑，重新打包上传，这里需要注意的是，即使重新打包上传，也不需要重新提审，只需要回复邮件说明情况，就可以继续进入审核队列。</p><h2 id="第3次被拒"><a href="#第3次被拒" class="headerlink" title="第3次被拒"></a>第3次被拒</h2><blockquote><p>Hello,</p><p>The issues we previously identified still need your attention.</p><p>If you have any questions, we are here to help. Reply to this message in App Store Connect and let us know. </p><p>Guideline 3.2.2 - Business - Other Business Model Issues - Unacceptable</p><p>The primary purpose of your app is to encourage users to watch ads or perform marketing-oriented tasks, which is not appropriate for the App Store.</p><p>Next Steps</p><p>We encourage you to review your app concept and incorporate different content and features that are in compliance with the App Store Review Guidelines.</p><p>Guideline 5.1.1(v) - Data Collection and Storage</p><p>We noticed that your app supports account creation but does not appear to include an option to initiate account deletion.</p><p>Apps that support account creation must also offer account deletion to give App Store users more control of the data they’ve shared while using your app.</p><p>Next Steps</p><p>If your app already supports account deletion, reply to this message and let us know how to locate this feature. If your app does not support account deletion, revise your app to include an option to initiate account deletion.</p><p>If you are unable to offer account deletion or need to provide additional customer service flows to facilitate and confirm account deletion, either because your app operates in a highly-regulated industry or for some other reason, reply to this message in App Store Connect and provide additional information or documentation. If you have questions regarding your legal obligations, check with your legal counsel.</p><p>Keep these requirements in mind when updating your app to support account deletion:</p><ul><li><p>Only offering to temporarily deactivate or disable an account is insufficient.</p></li><li><p>If users need to visit a website to finish deleting their account, include a link directly to the page on your website where they can complete the process.</p></li><li><p>You may include confirmation steps to prevent users from accidentally deleting their account. However, only apps in highly-regulated industries may require users to use customer service resources, such as making a phone call or sending an email, to complete account deletion.</p></li></ul><p>Resources</p><ul><li>Review frequently asked questions and learn more about the account deletion requirements.</li></ul><p>Guideline 4.7 - Design - HTML5 Games, Bots, etc.</p><p>We noticed that your app includes code that is not embedded in the binary, but the software does not fulfill all of the requirements outlined in Guideline 4.7 of the App Store Review Guidelines or you have not provided us with an index of the software available in your app.</p><p>Next Steps</p><p>To resolve this issue, please ensure the software offered in your app:</p><p>– Is not offered in a store or store-like interface.</p><p>– Is free or purchased using in-app purchase.</p><p>– Does not allow e-commerce to transfer funds or game currency.</p><p>– Only uses capabilities available in a standard WebKit view.</p><p>– Is offered by developers that have joined the Apple Developer Program and signed the Apple Developer Program License Agreement.</p><p>– Adheres to the terms of the App Store Review Guidelines.</p><p>Additionally, if you have not done so already, it would be appropriate to provide an up-to-date index of the software and metadata available in your app in the Review Notes section of App Store Connect. This index should include the app name, developer name, game URL, and App Store Connect Team ID for the software.</p><p>拒绝原因：<br>3.2.2 Business: Other Business Model Issues - Unacceptable<br>4.7.0 Design: HTML5 Games, Bots, etc.<br>5.1.1 Legal: Privacy - Data Collection and Storage</p></blockquote><h3 id="翻译-1"><a href="#翻译-1" class="headerlink" title="翻译"></a>翻译</h3><blockquote><p>您好，</p><p>我们之前发现的问题仍然需要您的注意。</p><p>如果您有任何疑问，我们随时为您提供帮助。 在 App Store Connect 中回复此消息并告知我们。</p><p>指南 3.2.2 - 商业 - 其他商业模式问题 - 不可接受</p><p>您的应用程序的主要目的是鼓励用户观看广告或执行面向营销的任务，这不适合 App Store。</p><p>下一步</p><p>我们鼓励您审查您的应用程序概念，并纳入符合 App Store 审查指南的不同内容和功能。</p><p>指南 5.1.1(v) - 数据收集和存储</p><p>我们注意到您的应用程序支持创建帐户，但似乎不包含启动帐户删除的选项。</p><p>支持帐户创建的应用程序还必须提供帐户删除功能，以便 App Store 用户能够更好地控制他们在使用您的应用程序时共享的数据。</p><p>下一步</p><p>如果您的应用程序已经支持删除帐户，请回复此消息并告诉我们如何找到此功能。 如果您的应用不支持帐户删除，请修改您的应用以包含启动帐户删除的选项。</p><p>如果您无法提供帐户删除或需要提供额外的客户服务流程来促进和确认帐户删除，无论是因为您的应用程序在高度监管的行业中运行还是出于其他原因，请在 App Store Connect 中回复此消息并 提供额外的信息或文件。 如果您对您的法律义务有疑问，请咨询您的法律顾问。</p><p>更新您的应用程序以支持帐户删除时，请牢记这些要求：</p><ul><li><p>仅提供暂时停用或禁用帐户是不够的。</p></li><li><p>如果用户需要访问一个网站来完成删除他们的帐户，请在您的网站上包含一个直接指向他们可以完成该过程的页面的链接。</p></li><li><p>您可以包括确认步骤以防止用户意外删除他们的帐户。 但是，只有高度监管行业的应用程序可能需要用户使用客户服务资源，例如拨打电话或发送电子邮件来完成帐户删除。</p></li></ul><p>资源</p><ul><li>查看常见问题并了解有关帐户删除要求的更多信息。</li></ul><p>指南 4.7 - 设计 - HTML5 游戏、机器人等。</p><p>我们注意到您的应用程序包含未嵌入二进制文件中的代码，但该软件不满足 App Store 审查指南第 4.7 条中概述的所有要求，或者您没有向我们提供可用软件的索引 你的应用程序。</p><p>下一步</p><p>要解决此问题，请确保您的应用程序中提供的软件：</p><p>– 不在商店或类似商店的界面中提供。</p><p>– 免费或使用应用内购买购买。</p><p>– 不允许电子商务转移资金或游戏货币。</p><p>– 仅使用标准 WebKit 视图中可用的功能。</p><p>– 由已加入 Apple Developer Program 并签署 Apple Developer Program License Agreement 的开发人员提供。</p><p>– 遵守 App Store 审查指南的条款。</p><p>此外，如果您还没有这样做，最好在 App Store Connect 的评论注释部分提供您的应用程序中可用的软件和元数据的最新索引。 该索引应包括软件的应用程序名称、开发者名称、游戏 URL 和 App Store Connect Team ID。</p></blockquote><h3 id="信息解读-1"><a href="#信息解读-1" class="headerlink" title="信息解读"></a>信息解读</h3><p>好嘛<del>~</del>  又多了一条被拒信息。这里不得不说，如果你的APP一直被拒，那他审查的程度就会越仔细。</p><h3 id="3-2-2-Business-Other-Business-Model-Issues-Unacceptable"><a href="#3-2-2-Business-Other-Business-Model-Issues-Unacceptable" class="headerlink" title="3.2.2 Business: Other Business Model Issues - Unacceptable"></a>3.2.2 Business: Other Business Model Issues - Unacceptable</h3><p>关于这一条新增的被拒，其实已经给明了原因，就是鼓励用户观看广告或执行面向营销的任务。这个在不是游戏的APP中做这些是不被允许的。</p><p>关于另外2条被拒的信息，我们已经没有办法处理了，而且也没有给出确切的信息，所以我们打算通过电话沟通，所以回复了苹果审核我们需要更确切的信息。</p><h1 id="回复信息"><a href="#回复信息" class="headerlink" title="回复信息"></a>回复信息</h1><blockquote><p>尊敬的审核团队：<br>   你们好！</p><p>   我们已经收到了贵司的审核回复，但是我们感到很迷惑，不太明白审核团队所指的我们的应用存在的具体问题是什么。期间我们优化了代码，重新做了提交，但是还是被拒绝。</p><p>   我们很乐意你们给出明确的原因，以便我们进一步修改我们的APP。</p><p>   1、关于encourage users to watch ads or perform marketing-oriented tasks，我们会修改、优化代码之后重新打包提交审核。<br>   2、关于account deletion，我们确认我们的APP有注销账号的功能（需要登录），路径为：我–&gt;设置–&gt;注销账号。我们需要更进一步的信息来了解具体的原因。<br>   3、关于includes code that is not embedded in the binary，我们仔细检查了代码，并没有发现相关内容，还请指出具体原因。</p><p>   综上，我们需要更进一步的信息，来帮助我们按照App Store 审核指南的真实意图修改代码，使我们的应用真正符合App Store 审核指南。</p><p>   我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</p><p>   您可以电话沟通来帮助我们处理这次APP被拒绝。<br>   电话：0086 187xxxx  姓名：xxx<br>   我们将在在北京时间的9:00-21:00接听电话，我们需要中文服务。</p><p>   期待您的回复！</p><p>   最后，祝您工作愉快！</p></blockquote><p>回复完成之后，就是等着就行，期间他们会回复邮件，确认电话沟通。</p><blockquote><p>Hello liu,</p><p>Thank you for your response. Your call with an Apple representative is confirmed.</p><p>An Apple Representative will call you on the number you provided in the App Review Information section of App Store Connect within the next 3 to 5 business days to discuss your app.</p><p>We look forward to helping you address the issues we found in our review.</p><p>Best regards,</p><p>App Store Review</p></blockquote><p>说的是3-5个工作日会电话联系，结果会很快就会有人联系，大概也就1天的时间。但是中间有一个插曲，导致我没有接到电话，然后他们会回复你没有人接通电话，并会给你一个电话号码让你在指定时间回拨过去。我一看好家伙，地址为加利福尼亚。</p><h2 id="电话沟通"><a href="#电话沟通" class="headerlink" title="电话沟通"></a>电话沟通</h2><p>一定要提前准备好你要问的问题，一定要有调理的进行问答。如果可以，请进行录音，因为外国人说汉语还是会有点不太好理解的。</p><p><b>问：关于4.7.0 Design: HTML5 Games, Bots, etc，应用程序包含未嵌入二进制文件中的代码，这一点我们很疑惑，能否详细说明？</b></p><blockquote><p>答：APP中有一个H5小游戏，游戏中可以通过一些操作，浏览帖子，发帖、评论等操作可以获取积分，通过在系统WKWebView打开的H5页面，应该与Safari打开没有区别。<br>这个游戏应该属于第三方软件。只要不是我们原生的代码，都属于第三方。而不是只要拥有账号权限的开发人员开发的。H5不应该调用客户端的API。</p></blockquote><p>这里所说的大概意思就是，在APP中不应该存在H5游戏积分与客户端的交互兑换的逻辑。不应该存在h5调用客户端APP相关功能API来消耗积分。</p><p><b>问：请问这个小游戏是哪个？能否给出具体的小游戏名称？</b></p><blockquote><p>答：你们没有看到截图吗？（这个是他们的疏忽，确实没有给截图附件）。会补充邮件说明截图情况，并告知了我们使用的是哪个小游戏。</p></blockquote><p><b>问：H5有自己的一套积分系统，是否可以使用WKWebView？</b></p><blockquote><p>答：在APP中为什么要H5的游戏有一套积分系统，那要怎么消耗积分呢？</p></blockquote><p>既然都已经电话沟通了，那就索性把其他的问题也问一下：</p><p><b>问：关于3.2.2 Business: Other Business Model Issues - Unacceptable，这个能否详细说明哪里有鼓励用户观看广告吗？</b></p><blockquote><p>答：在H5小游戏中提供了观看视频可以获得积分的操作。</p></blockquote><p>这个小游戏与上面问题中的小游戏是同一个。</p><p><b>问：关于注销账号这个问题，我们确定我们有该功能，为什么每次都还会有这个？是还需要有什么特殊逻辑吗？</b></p><blockquote><p>审核答：你们现在注销账号的逻辑是什么？<br>我们：把注销账号功能相关逻辑说了一下，申请注销后，会发送验证码进行确认，需要用户14天不登录才会注销。<br>审核答：那就没有问题</p></blockquote><p>最后结束通话，他们会发送一封邮件说明本次通话的大概内容，也就是通话的日志。所以这些未嵌入的二进制代码绝对不是在ipa包中的，那就是线上的的html代码。</p><p>我们把之前的代码回退之后，重新打包上传ipa。这里我们犯了一个错误，就是我们 没有真正理解整个上传的流程。</p><p>当重新上传ipa包之后，不要再次点提审，应该回复邮件说明情况。而我们不仅点了提审，还没有回复邮件说明，所以我们又被拒了。。。</p><h2 id="第4次被拒"><a href="#第4次被拒" class="headerlink" title="第4次被拒"></a>第4次被拒</h2><p>这次被拒跟第三次被拒的内容完全一致。所以我们回复了一下说明大概情况。</p><blockquote><p>尊敬的审核团队：<br>   你们好！</p><p>   我们已经收到了贵司的审核回复，在9月30日我们也通过电话进行了沟通，确定了被拒的具体原因，我们也修改并优化了代码，重新提交了审核，但还是被拒绝了。</p><p>   1、关于Guideline 3.2.2 - Business - Other Business Model Issues - Unacceptable，通过电话沟通确定是与Guideline 4.7的拒绝内容是一致的。<br>   2、关于Guideline 4.7 - Design - HTML5 Games, Bots, etc. 我们已经通过服务端进行了处理，下线了相关游戏。</p><p>   我们认为的标准可能与App Store 审核指南要求的标准不一致，所以，我们需要更进一步的信息，来帮助我们按照App Store 审核指南的真实意图修改代码，使我们的应用真正符合App Store 审核指南。</p><p>   我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</p><p>   最后，祝您工作愉快！</p></blockquote><h2 id="第5次被拒"><a href="#第5次被拒" class="headerlink" title="第5次被拒"></a>第5次被拒</h2><p>又经历了漫长的等待之后，我们又被拒了。</p><blockquote><p>Hello,</p><p>The issues we previously identified still need your attention.</p><p>If you have any questions, we are here to help. Reply to this message in App Store Connect and let us know. </p><p>Guideline 2.1 - Information Needed</p><p>We’re looking forward to completing the review of your app, but we need more information to continue.</p><p>Next Steps</p><p>Please provide detailed answers to the following questions in your reply to this message in App Store Connect:</p><ol><li>Does the game intended to display to end users in this version?</li></ol><p>拒绝原因：<br>2.1.0 Performance: App Completeness</p></blockquote><h3 id="翻译-2"><a href="#翻译-2" class="headerlink" title="翻译"></a>翻译</h3><blockquote><p>你好，</p><p>我们之前发现的问题仍然需要您的注意。</p><p>如果您有任何疑问，我们随时为您提供帮助。 在 App Store Connect 中回复此消息并告知我们。</p><p>准则 2.1 - 所需信息</p><p>我们期待完成对您的应用程序的审核，但我们需要更多信息才能继续。</p><p>下一步</p><p>请在您在 App Store Connect 中回复此消息时提供以下问题的详细答案：</p><p>1.游戏是否打算在这个版本中向最终用户展示？</p></blockquote><p>这个就有点懵逼了，大家做APP的都知道，肯定是通过后台操作在审核的时候把某些模块隐藏了，而且大部分也都是这么干的，所以不要被发现。发现了就是欺骗，后果很严重（封号）。</p><p>面对灵魂拷问，不自信也要自信，并要坚定的回答审核人员。</p><h3 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h3><blockquote><p>尊敬的审核团队：<br>   你们好！</p><p>   我们已经收到了贵司的审核回复，基于之前的电话沟通，我们已经确定了被拒的具体原因，所以我们也修改并优化了代码，重新提交了审核。</p></blockquote><blockquote><p>   关于 “Does the game intended to display to end users in this version? ”这个问题，我们已经做了严格的代码审查，并确定不会向用户展示相关游戏。</p><p>   我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</p><p>   最后，祝您工作愉快！</p></blockquote><p>到这里，也就是这一次审核被拒的整个流程。希望对大家有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5-1-1-Legal-Privacy-Data-Collection-and-Storage-amp-4-7-0-Design-HTML5-Games-Bots-etc-amp-3-2-2-Business-Other-Business-Model-Issues
      
    
    </summary>
    
    
      <category term="app审核" scheme="http://liujiaboy.github.io/categories/app%E5%AE%A1%E6%A0%B8/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="审核" scheme="http://liujiaboy.github.io/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS审核被拒梳理 - 2.1.0</title>
    <link href="http://liujiaboy.github.io/2022/12/14/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8-2/"/>
    <id>http://liujiaboy.github.io/2022/12/14/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8-2/</id>
    <published>2022-12-14T10:31:19.000Z</published>
    <updated>2022-12-20T11:19:29.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-0-Performance-App-Completeness"><a href="#2-1-0-Performance-App-Completeness" class="headerlink" title="2.1.0 Performance: App Completeness"></a>2.1.0 Performance: App Completeness</h1><p>被拒时间：2022.11.17 07:50<br>回复时间：2022.11.17 11:16<br>过审时间：2022.11.18 07:46</p><blockquote><p>Guideline 2.1 - Information Needed</p><p>We’re looking forward to completing our review, but we need more information to continue. Your app uses the AppTrackingTransparency framework, but we are unable to locate the App Tracking Transparency permission request when reviewed on iOS 15.5.</p><p>Next Steps</p><p>Please explain where we can find the App Tracking Transparency permission request in your app. The request should appear before any data is collected that could be used to track the user.</p><p>If you’ve implemented App Tracking Transparency but the permission request is not appearing on devices running the latest OS, please review the available documentation and confirm App Tracking Transparency has been correctly implemented.</p><p>If your app does not track users, update your app privacy information in App Store Connect to not declare tracking. You must have the Account Holder or Admin role to update app privacy information.</p><p>Resources</p><ul><li>Tracking is linking data collected from your app with third-party data for advertising purposes, or sharing the collected data with a data broker. Learn more about tracking.</li><li>See Frequently Asked Questions about the <a href="https://developer.apple.com/app-store/user-privacy-and-data-use/#permission-to-track" target="_blank" rel="noopener">requirements for apps that track users</a>.</li><li>Review developer documentation for <a href="https://developer.apple.com/documentation/apptrackingtransparency" target="_blank" rel="noopener">App Tracking Transparency</a>.</li></ul><p>拒绝原因：<br>2.1.0 Performance: App Completeness</p></blockquote><p>本次被拒主要是因为在某个机型上没有发现使用idfa权限申请的地方，但是确使用了idfa的信息。所以我们只要回复我们有idfa权限申请，没有区分版本就可以了。</p><p>另外需要补充的是，注意引用在info.plist文件中为什么要获取idfa信息。</p><h1 id="回复信息"><a href="#回复信息" class="headerlink" title="回复信息"></a>回复信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">尊敬的审核团队：</span><br><span class="line">你们好！</span><br><span class="line"></span><br><span class="line">关于“unable to locate the App Tracking Transparency permission request when reviewed on iOS 15.5.”的问题，我们确定使用了相关API，但是我们不会对系统和设备进行区分，在代码中iOS14以上的设备都会请求该权限。之所以需要该权限，是因为我们的APP宝宝树孕育需要访问您的idfa信息，从而精准的推荐广告服务。</span><br><span class="line"></span><br><span class="line">安装APP之后，首次点击运行APP时会有获取该权限的弹窗，请查看附件中的视频和截图。</span><br><span class="line"></span><br><span class="line">我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</span><br><span class="line"></span><br><span class="line">最后，祝您工作愉快！</span><br><span class="line"></span><br><span class="line">消息附件：</span><br><span class="line">idfa.MP4</span><br><span class="line">idfa.PNG</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-1-0-Performance-App-Completeness&quot;&gt;&lt;a href=&quot;#2-1-0-Performance-App-Completeness&quot; class=&quot;headerlink&quot; title=&quot;2.1.0 Performance: App C
      
    
    </summary>
    
    
      <category term="app审核" scheme="http://liujiaboy.github.io/categories/app%E5%AE%A1%E6%A0%B8/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="审核" scheme="http://liujiaboy.github.io/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS审核被拒梳理 - 1.4.1 &amp; 2.3.0</title>
    <link href="http://liujiaboy.github.io/2022/12/12/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8-1/"/>
    <id>http://liujiaboy.github.io/2022/12/12/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8-1/</id>
    <published>2022-12-12T07:13:19.000Z</published>
    <updated>2022-12-20T11:19:37.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-1-Safety-Physical-Harm-amp-2-3-0-Performance-Accurate-Metadata"><a href="#1-4-1-Safety-Physical-Harm-amp-2-3-0-Performance-Accurate-Metadata" class="headerlink" title="1.4.1 Safety: Physical Harm &amp; 2.3.0 Performance: Accurate Metadata"></a>1.4.1 Safety: Physical Harm &amp; 2.3.0 Performance: Accurate Metadata</h1><p>被拒时间：2022.12.09 03:21<br>回复时间：2022.12.09 15:20<br>过审时间：2022.12.10 12:16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Bug Fix Submissions</span><br><span class="line"> </span><br><span class="line">The issues we&#39;ve identified below are eligible to be resolved on your next update. If this submission includes bug fixes and you&#39;d like to have it approved at this time, reply to this message and let us know. You do not need to resubmit your app for us to proceed.</span><br><span class="line"></span><br><span class="line">Alternatively, if you&#39;d like to resolve these issues now, please review the details, make the appropriate changes, and resubmit.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Guideline 1.4.1 - Safety - Physical Harm</span><br><span class="line"></span><br><span class="line">Your app provides medical diagnoses or treatment advice but does not include the required medical disclaimer.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Please revise your app&#39;s description to include a disclaimer reminding users to seek a doctor’s advice in addition to using this app and before making any medical decisions.</span><br><span class="line"></span><br><span class="line">Once you have made the appropriate changes to your app’s description, please reply to this message in App Store Connect, and we will continue with the review.</span><br><span class="line"></span><br><span class="line">Guideline 2.3 - Performance - Accurate Metadata</span><br><span class="line"></span><br><span class="line">We were unable to locate some of the features described in your screenshot.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">If these features are located in your app, please reply to this message in App Store Connect to provide information on how to locate them.</span><br><span class="line"></span><br><span class="line">Alternatively, please revise your app to ensure that these features are fully implemented or revise your app description, release notes, and screenshots to remove all references to the features.</span><br><span class="line"></span><br><span class="line">Please see attached screenshot for details.</span><br></pre></td></tr></table></figure><p>出现这种问题，如果已经提前说明了<b>Bug Fix Submissions</b>，那就好说了，我们可以直接回复有相应的bug fixes，为了不影响用户体验，所以需要尽快审核，关于相关内容的修改，会在下次提交更新时做出修改。一般情况下，回复邮件之后，等24小时左右就会过审。但是在下次提交时，一定要把对应的问题解决掉。</p><p>如果想解决对应的问题，就需要继续梳理问题原因了。</p><h2 id="Guideline-1-4-1-Safety-Physical-Harm"><a href="#Guideline-1-4-1-Safety-Physical-Harm" class="headerlink" title="Guideline 1.4.1 - Safety - Physical Harm"></a>Guideline 1.4.1 - Safety - Physical Harm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your app provides medical diagnoses or treatment advice but does not include the required medical disclaimer.</span><br></pre></td></tr></table></figure><p>翻译：APP提过了医疗诊断或治疗建议，但不包含所需的医疗免责声明。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在APP信息页面，描述中增加免责声明，可以参考一下“丁香园”APP，为了安全保险起见，在用户协议或者相关协议中，添加对应的免责声明。</p><h2 id="Guideline-2-3-Performance-Accurate-Metadata"><a href="#Guideline-2-3-Performance-Accurate-Metadata" class="headerlink" title="Guideline 2.3 - Performance - Accurate Metadata"></a>Guideline 2.3 - Performance - Accurate Metadata</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We were unable to locate some of the features described in your screenshot.</span><br></pre></td></tr></table></figure><p>翻译：无法找到屏幕截图中描述的某些功能。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>这种情况属于，我们添加的APP截图（iOS预览和截屏）中提供了某些功能，但是审核人员却没有找到对应的路径。</p><p>通常情况下，他们会提供对应的截图，我们只需要根据截图内容，找到对应的实现路径就可以。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>这个可能会出现两种情况：</p><p>1、查看截图内容，是否为我们已经下线的功能。</p><p>我们犯的错误是，APP提审是另外一个团队，在其中一个版本更新预览图片时，有一些尺寸没有删除干净，4.7英才显示屏下对应的图片还是老的功能，但是已经下线了。所以找不到对应的路径。</p><p>这种情况，就需要删除对应的预览截图即可。回复邮件时说明情况。</p><p>2、如果确实存在该功能，但是审核人员没有找到。</p><p>这种情况，我们只需要回复邮件给出明确路径，并添加录屏附件即可。</p><h1 id="最后回复"><a href="#最后回复" class="headerlink" title="最后回复"></a>最后回复</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">尊敬的审核团队：</span><br><span class="line">你们好！</span><br><span class="line"></span><br><span class="line">我们这个版本的更新包含了一些bug fixes，我们希望尽快得到审核，以免影响用户体验。</span><br><span class="line">关于提到的两个问题，我们会在下一次更新中解决。</span><br><span class="line"></span><br><span class="line">我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</span><br><span class="line"></span><br><span class="line">最后，祝您工作愉快！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-4-1-Safety-Physical-Harm-amp-2-3-0-Performance-Accurate-Metadata&quot;&gt;&lt;a href=&quot;#1-4-1-Safety-Physical-Harm-amp-2-3-0-Performance-Accur
      
    
    </summary>
    
    
      <category term="app审核" scheme="http://liujiaboy.github.io/categories/app%E5%AE%A1%E6%A0%B8/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="审核" scheme="http://liujiaboy.github.io/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS审核被拒不要慌</title>
    <link href="http://liujiaboy.github.io/2022/12/10/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E4%B8%8D%E8%A6%81%E6%85%8C/"/>
    <id>http://liujiaboy.github.io/2022/12/10/OC%E5%85%B6%E5%AE%83/iOS%E5%AE%A1%E6%A0%B8/iOS%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E4%B8%8D%E8%A6%81%E6%85%8C/</id>
    <published>2022-12-10T07:44:36.000Z</published>
    <updated>2022-12-20T11:19:33.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS审核"><a href="#iOS审核" class="headerlink" title="iOS审核"></a>iOS审核</h1><h2 id="审核团队"><a href="#审核团队" class="headerlink" title="审核团队"></a>审核团队</h2><p>苹果在全球多个地方都拥有审核团队，比如我们的上海就有。所以不用担心纯中文的APP，老外看不明白，他们一定会有懂中文的审核人员进行审核。</p><p>基于以上内容，我们在审核被拒时就不用慌张，不是必须用英文回复。</p><ol><li>在APP Store Connect信息页面回复时，都可以全程使用中文，即使在沟通过程中需要电话沟通，也可以指定使用中文，并指定电话沟通的时间。但是如果我们的APP着急上架，那最好附上英文翻译，这将有助于审核。</li><li>在邮件回复中，要引用被拒的内容，并给出明确的答复。</li><li>苹果全球都有审核点，所以你的APP不一定会是哪个团队做的审核，除了苹果明确通知的节假日或其他时间，一般是一周七天都会审核。</li></ol><h2 id="审核效率"><a href="#审核效率" class="headerlink" title="审核效率"></a>审核效率</h2><p>苹果现在大大提升了审核效率，几乎所有的APP在24小时内都会完成审核，我经历过最快的一次审核是，被拒之后回复邮件，3个小时后就通过了审核。</p><h2 id="审核过程"><a href="#审核过程" class="headerlink" title="审核过程"></a>审核过程</h2><p>一次审核的流程从提交审核开始，到审核结束，APP发布上线。</p><p>大致流程为：填写APP应用消息 – 后台创建版本 – 提交版本 – 提交审核 – 等待审核（机审）– 审核中（人工）– 审核通过/拒绝 – 发布上线</p><p>机审：扫描APP代码，（主要为了防范马甲包），基本会喜提4.3和2.1大礼包。之后就是人审。</p><p>即使中间审核被拒了，也还是在审核流程中，当你修改完内容，重新提交APP包后，<b>也不需要重新提交审核</b>。最优的做法是，回复审核人员，已经完成了修改（引用被拒内容，一一做出回复），希望继续审核。</p><p>之后可能会出现两种情况：</p><ol><li>对应的审核人员会对上次的问题继续审核，而不会把APP所有内容重新审核一次。</li><li>也有可能会重新排队审核，这时的审核人员就不一定是上次的审核人员了。</li></ol><p>所以建议不要重新提交审核。</p><h2 id="加急审核"><a href="#加急审核" class="headerlink" title="加急审核"></a>加急审核</h2><p>可以利用加急审核，但不要滥用。只要诉求合理，一般会进入加急队列。<br>比如：紧急bug修复，指定时间发布需要配合营销活动等。<br><a href="https://developer.apple.com/contact/app-store/?topic=expedite" target="_blank" rel="noopener">加急审核</a></p><h2 id="添加备注、附件"><a href="#添加备注、附件" class="headerlink" title="添加备注、附件"></a>添加备注、附件</h2><p>在App Store Connect中有<b>备注、附件</b>一栏，可以添加一些功能的操作路径，录屏文件、截图、政策说明等等，这有助于APP过审。</p><h2 id="审核被拒"><a href="#审核被拒" class="headerlink" title="审核被拒"></a>审核被拒</h2><p>不要害怕和审核人员沟通，大部分人都是很友善的。</p><p>在回复审核邮件时，一定要一条一条引用被拒的原因，给出具体的解决方案，可以使用录屏和截图，一定要注意的是要给出明确的答复，不要模棱两可，更不要欺骗，后果很严重。</p><p>如果认为被拒绝的理由或者确认不是自己的问题，最好还是直接回复审核团队加以说明情况，可以使用录屏和截图，如有必要可以进行申诉。</p><p>对于审核回复的信息不是很理解，或者信息不充分，可以回复审核追要截图等关键信息，也可以提出使用电话沟通的方式。</p><h2 id="常用回复模板"><a href="#常用回复模板" class="headerlink" title="常用回复模板"></a>常用回复模板</h2><h3 id="1-需要电话沟通"><a href="#1-需要电话沟通" class="headerlink" title="1.需要电话沟通"></a>1.需要电话沟通</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">尊敬的审核团队：</span><br><span class="line">你们好！</span><br><span class="line"></span><br><span class="line">我们已经收到了贵司的审核回复，但是我们感到很迷惑，不太明白审核团队所指的我们的应用存在的具体问题是什么。期间我们优化了代码，重新做了提交，但是还是被拒绝。</span><br><span class="line"></span><br><span class="line">我们很乐意你们给出明确的原因，以便我们进一步修改我们的APP。</span><br><span class="line"></span><br><span class="line">1、关于encourage users to watch ads or perform marketing-oriented tasks，我们会修改、优化代码之后重新打包提交审核。</span><br><span class="line">2、关于account deletion，我们确认我们的APP有注销账号的功能（需要登录），路径为：我--&gt;设置--&gt;注销账号。我们需要更进一步的信息来了解具体的原因。</span><br><span class="line">3、关于includes code that is not embedded in the binary，我们仔细检查了代码，并没有发现相关内容，还请指出具体原因。</span><br><span class="line"></span><br><span class="line">综上，我们需要更进一步的信息，来帮助我们按照App Store 审核指南的真实意图修改代码，使我们的应用真正符合App Store 审核指南。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</span><br><span class="line"></span><br><span class="line">您可以电话沟通来帮助我们处理这次APP被拒绝。</span><br><span class="line">电话：0086 187xxx  姓名：xxx</span><br><span class="line">我们将在在北京时间的9:00-21:00接听电话，我们需要中文服务。</span><br><span class="line"></span><br><span class="line">期待您的回复！</span><br><span class="line"></span><br><span class="line">最后，祝您工作愉快！</span><br></pre></td></tr></table></figure><h3 id="2-正常回复继续审核"><a href="#2-正常回复继续审核" class="headerlink" title="2. 正常回复继续审核"></a>2. 正常回复继续审核</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">尊敬的审核团队：</span><br><span class="line">你们好！</span><br><span class="line"></span><br><span class="line">关于“unable to locate the App Tracking Transparency permission request when reviewed on iOS 15.5.”的问题，我们确定使用了相关API，但是我们不会对系统和设备进行区分，在代码中iOS14以上的设备都会请求该权限。之所以需要该权限，是因为我们的APP宝宝树孕育需要访问您的idfa信息，从而精准的推荐广告服务。</span><br><span class="line"></span><br><span class="line">安装APP之后，首次点击运行APP时会有获取该权限的弹窗，请查看附件中的视频和截图。</span><br><span class="line"></span><br><span class="line">我们喜爱App Store这个平台，也希望维护这个平台的生态健康。使我们的app完全符合App Store 审核指南的要求，是我们工作的方向。</span><br><span class="line"></span><br><span class="line">最后，祝您工作愉快！</span><br><span class="line"></span><br><span class="line">附件视频</span><br><span class="line">附件图片</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p><a href="https://developer.apple.com/cn/app-store/review/guidelines/" target="_blank" rel="noopener">App Store 审核指南</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS审核&quot;&gt;&lt;a href=&quot;#iOS审核&quot; class=&quot;headerlink&quot; title=&quot;iOS审核&quot;&gt;&lt;/a&gt;iOS审核&lt;/h1&gt;&lt;h2 id=&quot;审核团队&quot;&gt;&lt;a href=&quot;#审核团队&quot; class=&quot;headerlink&quot; title=&quot;审核团队&quot;
      
    
    </summary>
    
    
      <category term="app审核" scheme="http://liujiaboy.github.io/categories/app%E5%AE%A1%E6%A0%B8/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="审核" scheme="http://liujiaboy.github.io/tags/%E5%AE%A1%E6%A0%B8/"/>
    
      <category term="App Review" scheme="http://liujiaboy.github.io/tags/App-Review/"/>
    
  </entry>
  
  <entry>
    <title>iOS包大小优化</title>
    <link href="http://liujiaboy.github.io/2022/04/18/OC%E5%85%B6%E5%AE%83/iOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/"/>
    <id>http://liujiaboy.github.io/2022/04/18/OC%E5%85%B6%E5%AE%83/iOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/</id>
    <published>2022-04-18T10:18:49.000Z</published>
    <updated>2022-04-18T10:20:55.949Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="包大小" scheme="http://liujiaboy.github.io/tags/%E5%8C%85%E5%A4%A7%E5%B0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Class &amp; Struct</title>
    <link href="http://liujiaboy.github.io/2021/12/28/swift/1-Class-Struct/"/>
    <id>http://liujiaboy.github.io/2021/12/28/swift/1-Class-Struct/</id>
    <published>2021-12-28T09:08:10.000Z</published>
    <updated>2022-01-24T06:35:28.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol><li>定义存储值的属性</li><li>定义方法</li><li>定义下标以及使用下标语法提供对其值的访问</li><li>定义初始化器</li><li>使用extension来拓展功能</li><li>遵循协议来提供功能</li></ol><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><ol><li>类有继承特性，结构体没有</li><li>类型转换，在运行时检查和解释类实例的类型</li><li>类有析构函数用来释放器分配的资源</li><li>引用计数允许对一个类实例有多个引用</li><li>类是引用类型，存储在堆上，也就意味着一个类类型的变量并不是直接存储具体的的实例对象，是对当前存储具体实例内存地址的引用。</li><li>Struct结构体是值类型，存储在栈上。如果值类型中有引用类型的属性，则该属性的地址在栈上，但是引用的值存储在堆上。</li><li>尽可能多的使用值类型，是内存安全的，运行效率也会比值类型高。</li></ol><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><ol><li>类中添加属性，不会自动提供成员初始化器，必须提供对应的的指定初始化器（或者提供便捷初始化器）。</li><li>结构体会提供默认的成员初始化器。</li></ol><h3 id="便捷初始化器"><a href="#便捷初始化器" class="headerlink" title="便捷初始化器"></a>便捷初始化器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init(name: String, age: Int) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convenience init()&#123;</span><br><span class="line">&#x2F;&#x2F; 这里需要调用初始化</span><br><span class="line">    self.init(name: &quot;name&quot;, age: 18)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便捷初始化器必须从相同的类里调用另一个初始化器，否则会报错。</p><h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><ol><li>指定初始化器必须在调用父类初始化器之前，对其所有属性完成初始化。（确保成员变量使用安全）</li><li>指定初始化器必须在调用父类初始化器之后，才能为继承的属性设置新值，否则指定初始化器中赋的新值会被父类的初始化所覆盖。</li><li>便捷初始化器必须先调用同类中的初始化器之后，再为任意属性赋值，否则会报错，（属性的值也会被指定初始化覆盖）。</li><li>初始化器在初始化完成之前，不能调用任何实例方法，不能读取任何实例属性的值，也不能引用self作为值。必须保证内存是安全的</li></ol><h4 id="可失败初始化：init"><a href="#可失败初始化：init" class="headerlink" title="可失败初始化：init?"></a>可失败初始化：init?</h4><p>当参数不合法或者条件不满足时存在失败的情况，return nil。</p><h4 id="必要初始化：require"><a href="#必要初始化：require" class="headerlink" title="必要初始化：require"></a>必要初始化：require</h4><p>在类的初始化之前添加required关键字来修饰。表明该类的子类都必须实现该初始化器。</p><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>refCount ：64位的位域信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同点&quot; class=&quot;headerlink&quot; title=&quot;相同点&quot;&gt;&lt;/a&gt;相同点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;定义存储值的属性&lt;/li&gt;
&lt;li&gt;定义方法&lt;/li&gt;
&lt;li&gt;定义下标以及使用下标语法提供对其值的访问&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://liujiaboy.github.io/categories/Swift/"/>
    
    
      <category term="Swift," scheme="http://liujiaboy.github.io/tags/Swift/"/>
    
      <category term="Class" scheme="http://liujiaboy.github.io/tags/Class/"/>
    
      <category term="Struct" scheme="http://liujiaboy.github.io/tags/Struct/"/>
    
  </entry>
  
  <entry>
    <title>flutter-规范</title>
    <link href="http://liujiaboy.github.io/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/"/>
    <id>http://liujiaboy.github.io/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/</id>
    <published>2021-12-27T02:04:25.000Z</published>
    <updated>2021-12-28T09:10:46.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h2><p>代码应该简洁易懂，逻辑清晰；<br>代码应优先保证正确性、可用性；<br>在保证程序可用的情况下，代码应该具备可扩展性，易修改，而不是需求有一点改动代码就需要大动干戈；</p><h2 id="禁止使用print直接提交到发版分支，使用debugPrint替换。"><a href="#禁止使用print直接提交到发版分支，使用debugPrint替换。" class="headerlink" title="禁止使用print直接提交到发版分支，使用debugPrint替换。"></a>禁止使用print直接提交到发版分支，使用debugPrint替换。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void tryCatch(Function f) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    f?.call();</span><br><span class="line">  &#125; catch (e, stack) &#123;</span><br><span class="line">    debugPrint(&#39;$e&#39;);</span><br><span class="line">    debugPrint(&#39;$stack&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。"><a href="#两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。" class="headerlink" title="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。"></a>两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(</span><br><span class="line">    &#39;ERROR: Parts of the spaceship are on fire. Other &#39;</span><br><span class="line">    &#39;parts are overrun by martians. Unclear which are which.&#39;);</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;ERROR: Parts of the spaceship are on fire. Other &#39; +</span><br><span class="line">    &#39;parts are overrun by martians. Unclear which are which.&#39;);</span><br></pre></td></tr></table></figure><h3 id="优先使用插值来组合字符串和值。"><a href="#优先使用插值来组合字符串和值。" class="headerlink" title="优先使用插值来组合字符串和值。"></a>优先使用插值来组合字符串和值。</h3><p>如果您之前是用其他语言做开发的，那么您习惯使用+的长链来构建文字和其他值的字符串。 这在Dart中有效，但使用插值总是更清晰，更简短：</p><p>推荐写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hello, $name! You are $&#123;year - birth&#125; years old.&#39;;</span><br></pre></td></tr></table></figure><p>不推荐的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hello, &#39; + name + &#39;! You are &#39; + (year - birth).toString() + &#39; y...&#39;;</span><br></pre></td></tr></table></figure><h3 id="不要在字符串中使用不必要的大括号"><a href="#不要在字符串中使用不必要的大括号" class="headerlink" title="不要在字符串中使用不必要的大括号"></a>不要在字符串中使用不必要的大括号</h3><p>当表达式的值可以为真、假或null，并且您需要将结果传递给不接受null的对象时，此规则适用。一个常见的情况是一个判断空值的方法调用被用作条件:</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hi, $name!&#39;</span><br><span class="line">&quot;Wear your wildest $decade&#39;s outfit.&quot;</span><br><span class="line">&#x2F;&#x2F;标识符后面有紧跟着的字母了 加上大括号用以区分</span><br><span class="line">&#39;Wear your wildest $&#123;decade&#125;s outfit.&#39;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hi, $&#123;name&#125;!&#39;</span><br><span class="line">&quot;Wear your wildest $&#123;decade&#125;&#39;s outfit.&quot;</span><br></pre></td></tr></table></figure><h3 id="使用-将空值转换为布尔值。"><a href="#使用-将空值转换为布尔值。" class="headerlink" title="使用? ?将空值转换为布尔值。"></a>使用? ?将空值转换为布尔值。</h3><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (optionalThing?.isEnabled) &#123;</span><br><span class="line">  print(&quot;Have enabled thing.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果optionalThing为空，此代码将抛出异常。（if只支持判断bool值，不支持null）要解决这个问题，您需要将null值“转换”为true或false。虽然您可以使用==来完成此操作，但我们建议使用?? :</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled ?? false;</span><br><span class="line">&#x2F;&#x2F;如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled ?? true;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled &#x3D;&#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled !&#x3D; false;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="尽可能的使用集合字面量。"><a href="#尽可能的使用集合字面量。" class="headerlink" title="尽可能的使用集合字面量。"></a>尽可能的使用集合字面量。</h3><p>两种方式来构造一个空的可变 list ： [] 和 List() 。 同样，有三种方式来构造一个空的Map map：{}， Map()， 和 LinkedHashMap() 。 如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。 否则，使用字面量语法更加优雅。 核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; [];</span><br><span class="line">var addresses &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; List();</span><br><span class="line">var addresses &#x3D; Map();</span><br></pre></td></tr></table></figure><h3 id="如果需要的话，你可以提供一个泛型"><a href="#如果需要的话，你可以提供一个泛型" class="headerlink" title="如果需要的话，你可以提供一个泛型"></a>如果需要的话，你可以提供一个泛型</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; &lt;Point&gt;[];</span><br><span class="line">var addresses &#x3D; &lt;String, Address&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; List&lt;Point&gt;();</span><br><span class="line">var addresses &#x3D; Map&lt;String, Address&gt;();</span><br></pre></td></tr></table></figure><p>注意，对于集合类的 命名 构造函数则不适用上面的规则。 List.from()、 Map.fromIterable() 都有其使用场景。 如果需要一个固定长度的结合，使用 List() 来创建一个固定长度的 list 也是合理的。</p><h3 id="不要使用-length-来判断一个集合是否为空。"><a href="#不要使用-length-来判断一个集合是否为空。" class="headerlink" title="不要使用 .length 来判断一个集合是否为空。"></a>不要使用 .length 来判断一个集合是否为空。</h3><p>通过调用 .length 来判断集合是否包含内容是非常低效的。相反，Dart 提供了更加高效率和易用的 getter 函数：.isEmpty 和.isNotEmpty。 使用这些函数并不需要对结果再次取非(list.length ! =0)</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.isEmpty) return &#39;so hungry...&#39;;</span><br><span class="line">if (words.isNotEmpty) return words.join(&#39; &#39;);</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.length &#x3D;&#x3D; 0) return &#39;so hungry...&#39;;</span><br><span class="line">if (!words.isEmpty) return words.join(&#39; &#39;);</span><br></pre></td></tr></table></figure><h3 id="不要使用-List-from-除非想修改结果的类型。"><a href="#不要使用-List-from-除非想修改结果的类型。" class="headerlink" title="不要使用 List.from() 除非想修改结果的类型。"></a>不要使用 List.from() 除非想修改结果的类型。</h3><p>给定一个可迭代的对象，有两种常见方式来生成一个包含相同元素的 list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var copy1 &#x3D; iterable.toList();</span><br><span class="line">var copy2 &#x3D; List.from(iterable);</span><br></pre></td></tr></table></figure><p>推荐的写法<br>明显的区别是前一个更短。 更重要的区别在于第一个保留了原始对象的类型参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable &#x3D; [1, 2, 3];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 输出 &quot;List&lt;int&gt;&quot;:</span><br><span class="line">print(iterable.toList().runtimeType);</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出 &quot;List&lt;dynamic&gt;&quot;:</span><br><span class="line">print(List.from(iterable).runtimeType);</span><br></pre></td></tr></table></figure><h3 id="如果你想要改变原始对象的类型参数，那么可以调用-List-from-："><a href="#如果你想要改变原始对象的类型参数，那么可以调用-List-from-：" class="headerlink" title="如果你想要改变原始对象的类型参数，那么可以调用 List.from() ："></a>如果你想要改变原始对象的类型参数，那么可以调用 List.from() ：</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers &#x3D; [1, 2.3, 4]; &#x2F;&#x2F; List&lt;num&gt;.</span><br><span class="line">numbers.removeAt(1); &#x2F;&#x2F; 现在集合里只包含int型</span><br><span class="line">var ints &#x3D; List&lt;int&gt;.from(numbers);</span><br></pre></td></tr></table></figure><p>但是如果你的目的只是复制可迭代对象并且保留元素原始类型， 或者并不在乎类型，那么请使用 toList() 。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="使用-来分隔参数名和参数默认值。"><a href="#使用-来分隔参数名和参数默认值。" class="headerlink" title="使用 = 来分隔参数名和参数默认值。"></a>使用 = 来分隔参数名和参数默认值。</h3><p>由于遗留原因，Dart 同时支持 : 和 = 作为参数名和默认值的分隔符。 为了与可选的位置参数保持一致，请使用 = 。</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at &#x3D; 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at: 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="不要-为字段创建不必要的-getter-和-setter-方法"><a href="#不要-为字段创建不必要的-getter-和-setter-方法" class="headerlink" title="不要 为字段创建不必要的 getter 和 setter 方法"></a>不要 为字段创建不必要的 getter 和 setter 方法</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var _contents;</span><br><span class="line">  get contents &#x3D;&gt; _contents;</span><br><span class="line">  set contents(value) &#123;</span><br><span class="line">    _contents &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要使用this-在重定向命名函数和避免冲突的情况下除外"><a href="#不要使用this-在重定向命名函数和避免冲突的情况下除外" class="headerlink" title="不要使用this. 在重定向命名函数和避免冲突的情况下除外"></a>不要使用this. 在重定向命名函数和避免冲突的情况下除外</h3><p>只有当局部变量和成员变量名字一样的时候，你才需要使用 this. 来访问成员变量。 只有两种情况需要使用 this. 。其中一种情况是要访问的局部变量和成员变量命名一样的时候：</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    this.update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要尽可能的在定义变量的时候初始化变量值。"><a href="#要尽可能的在定义变量的时候初始化变量值。" class="headerlink" title="要尽可能的在定义变量的时候初始化变量值。"></a>要尽可能的在定义变量的时候初始化变量值。</h3><p>如果一个字段不依赖于构造函数中的参数， 则应该在定义的时候就初始化字段值。 这样可以减少需要的代码并可以确保在有多个构造函数的时候你不会忘记初始化该字段。</p><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents;</span><br><span class="line"> </span><br><span class="line">  Folder(this.name) : contents &#x3D; [];</span><br><span class="line">  Folder.temp() : name &#x3D; &#39;temporary&#39;; &#x2F;&#x2F; Oops! Forgot contents.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents &#x3D; [];</span><br><span class="line"> </span><br><span class="line">  Folder(this.name);</span><br><span class="line">  Folder.temp() : name &#x3D; &#39;temporary&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于变量取值依赖构造函数参数的情况以及不同的构造函数取值也不一样的情况， 则不适合本条规则。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="不要-使用-new"><a href="#不要-使用-new" class="headerlink" title="不要 使用 new"></a>不要 使用 new</h3><p>创建对象不要使用new</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Row(</span><br><span class="line">    children: [</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(&#39;Increment&#39;),</span><br><span class="line">      ),</span><br><span class="line">      Text(&#39;Click!&#39;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return new Row(</span><br><span class="line">    children: [</span><br><span class="line">      new RaisedButton(</span><br><span class="line">        child: new Text(&#39;Increment&#39;),</span><br><span class="line">      ),</span><br><span class="line">      new Text(&#39;Click!&#39;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要用-来替代空的构造函数体-。"><a href="#要用-来替代空的构造函数体-。" class="headerlink" title="要用 ; 来替代空的构造函数体 {}。"></a>要用 ; 来替代空的构造函数体 {}。</h3><p>在 Dart 中，没有具体函数体的构造函数可以使用分号结尾。 （事实上，这是不可变构造函数的要求。）</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要尽可能的使用初始化形式。"><a href="#要尽可能的使用初始化形式。" class="headerlink" title="要尽可能的使用初始化形式。"></a>要尽可能的使用初始化形式。</h3><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Point(num x, num y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y,z;</span><br><span class="line">  Point(this.x, this.y,&#123;this.z&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的位于构造函数参数之前的 this. 语法被称之为初始化形式（initializing formal）。 有些情况下这无法使用这种形式。特别是，这种形式下在初始化列表中无法看到变量。 但是如果能使用该方式，就应该尽量使用。（如果使用命名参数）</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"><a href="#dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。" class="headerlink" title="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"></a>dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。</h3><p>不推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br></pre></td></tr></table></figure><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="推荐-使用-async-await-而不是直接使用底层的特性。"><a href="#推荐-使用-async-await-而不是直接使用底层的特性。" class="headerlink" title="推荐 使用 async/await 而不是直接使用底层的特性。"></a>推荐 使用 async/await 而不是直接使用底层的特性。</h3><p>显式的异步代码是非常难以阅读和调试的， 即使使用很好的抽象（比如 future）也是如此。 这就是为何 Dart 提供了 async/await。 这样可以显著的提高代码的可读性并且让你可以在异步代码中使用语言提供的所有流程控制语句。</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) async &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var team &#x3D; await downloadTeam(teamName);</span><br><span class="line">    if (team &#x3D;&#x3D; null) return 0;</span><br><span class="line"></span><br><span class="line">    var players &#x3D; await team.roster;</span><br><span class="line">    return players.where((player) &#x3D;&gt; player.isActive).length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) &#123;</span><br><span class="line">  return downloadTeam(teamName).then((team) &#123;</span><br><span class="line">    if (team &#x3D;&#x3D; null) return Future.value(0);</span><br><span class="line"></span><br><span class="line">    return team.roster.then((players) &#123;</span><br><span class="line">      return players.where((player) &#x3D;&gt; player.isActive).length;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).catchError((e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 Dart 中标识符有三种类型。 • UpperCamelCase 每个单词的首字母都大写，包含第一个单词。 • lowerCamelCase 每个单词的首字母都大写，除了第一个单词， 第一个单词首字母小写，即使是缩略词。 • lowercase_with_underscores 只是用小写字母单词，即使是缩略词， 并且单词之间使用 _ 连接。</p><h3 id="使用-UpperCamelCase-风格命名类型。"><a href="#使用-UpperCamelCase-风格命名类型。" class="headerlink" title="使用 UpperCamelCase 风格命名类型。"></a>使用 UpperCamelCase 风格命名类型。</h3><p>Classes（类名）、 enums（枚举类型）、 typedefs（类型定义）、 以及 type parameters（类型参数）应该把每个单词的首字母都大写（包含第一个单词）， 不使用分隔符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SliderMenu &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">class HttpRequest &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">typedef Predicate &#x3D; bool Function&lt;T&gt;(T value);</span><br></pre></td></tr></table></figure><h3 id="要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。"><a href="#要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。" class="headerlink" title="要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。"></a>要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library peg_parser.source_scanner;</span><br><span class="line"></span><br><span class="line">import &#39;file_system.dart&#39;;</span><br><span class="line">import &#39;slider_menu.dart&#39;;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library pegparser.SourceScanner;</span><br><span class="line">import &#39;file-system.dart&#39;;</span><br><span class="line">import &#39;SliderMenu.dart&#39;;</span><br></pre></td></tr></table></figure><h3 id="要使用-lowercase-with-underscores-风格命名导入的前缀"><a href="#要使用-lowercase-with-underscores-风格命名导入的前缀" class="headerlink" title="要使用 lowercase_with_underscores 风格命名导入的前缀"></a>要使用 lowercase_with_underscores 风格命名导入的前缀</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39; as math;</span><br><span class="line">import &#39;package:angular_components&#x2F;angular_components&#39;</span><br><span class="line">    as angular_components;</span><br><span class="line">import &#39;package:js&#x2F;js.dart&#39; as js;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39; as Math;</span><br><span class="line">import &#39;package:angular_components&#x2F;angular_components&#39;</span><br><span class="line">    as angularComponents;</span><br><span class="line">import &#39;package:js&#x2F;js.dart&#39; as JS;</span><br></pre></td></tr></table></figure><h3 id="要-使用-lowerCamelCase-风格来命名其他的标识符。"><a href="#要-使用-lowerCamelCase-风格来命名其他的标识符。" class="headerlink" title="要 使用 lowerCamelCase 风格来命名其他的标识符。"></a>要 使用 lowerCamelCase 风格来命名其他的标识符。</h3><p>类成员、顶级定义、变量、参数以及命名参数等 除了第一个单词，每个单词首字母都应大写，并且不使用分隔符。</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var item;</span><br><span class="line"></span><br><span class="line">HttpRequest httpRequest;</span><br><span class="line"></span><br><span class="line">void align(bool clearItems) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"><a href="#要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。" class="headerlink" title="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"></a>要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。</h3><p>首字母大写缩略词比较难阅读， 特别是多个缩略词连载一起的时候会引起歧义。 例如，一个以 HTTPSFTP 开头的名字， 没有办法判断它是指 HTTPS FTP 还是 HTTP SFTP 。 为了避免上面的情况，缩略词和缩写词要像普通单词一样首字母大写， 两个字母的单词除外。 （像 ID 和 Mr. 这样的双字母缩写词仍然像一般单词一样首字母大写。）</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpConnectionInfo</span><br><span class="line">uiHandler</span><br><span class="line">IOStream</span><br><span class="line">HttpRequest</span><br><span class="line">Id</span><br><span class="line">DB</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPConnection</span><br><span class="line">UiHandler</span><br><span class="line">IoStream</span><br><span class="line">HTTPRequest</span><br><span class="line">ID</span><br><span class="line">Db</span><br></pre></td></tr></table></figure><p>• acronyms ：首字母缩略词，指取若干单词首字母组成一个新单词，如：HTTP = HyperText Transfer Protocol • abbreviations : 缩写词，指取某一单词的部分字母（或其他缩短单词的方式）代表整个单词，如：ID = identification</p><h3 id="不要-使用前缀字母"><a href="#不要-使用前缀字母" class="headerlink" title="不要 使用前缀字母"></a>不要 使用前缀字母</h3><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTimeout</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kDefaultTimeout</span><br></pre></td></tr></table></figure><h3 id="要-使用-googlestyle-格式化你的代码"><a href="#要-使用-googlestyle-格式化你的代码" class="headerlink" title="要 使用 googlestyle 格式化你的代码"></a>要 使用 googlestyle 格式化你的代码</h3><p>格式化是一项繁琐的工作，尤其在重构过程中特别耗时。 庆幸的是，你不必担心。 使用Android studio默认的googlestyle。</p><h3 id="要对所有流控制结构使用花括号。"><a href="#要对所有流控制结构使用花括号。" class="headerlink" title="要对所有流控制结构使用花括号。"></a>要对所有流控制结构使用花括号。</h3><p>这样可以避免 dangling else （else悬挂）的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isWeekDay) &#123;</span><br><span class="line">  print(&#39;Bike to work!&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&#39;Go dancing or read a book!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个例外：一个没有 else 的 if 语句， 并且这个 if 语句以及它的执行体适合在一行中实现。 在这种情况下，如果您愿意，可以不用括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (arg &#x3D;&#x3D; null) return defaultValue;</span><br></pre></td></tr></table></figure><p>但是，如果执行体包含下一行，请使用大括号：</p><p>推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars !&#x3D; other.overflowChars) &#123;</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars !&#x3D; other.overflowChars)</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;核心原则&quot;&gt;&lt;a href=&quot;#核心原则&quot; class=&quot;headerlink&quot; title=&quot;核心原则&quot;&gt;&lt;/a&gt;核心原则&lt;/h2&gt;&lt;p&gt;代码应该简洁易懂，逻辑清晰；&lt;br&gt;代码应优先保证正确性、可用性；&lt;br&gt;在保证程序可用的情况下，代码应该具备可扩展性，易修
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://liujiaboy.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://liujiaboy.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>coderunner使用问题</title>
    <link href="http://liujiaboy.github.io/2021/09/15/SoftWare/coderunner/"/>
    <id>http://liujiaboy.github.io/2021/09/15/SoftWare/coderunner/</id>
    <published>2021-09-15T11:01:29.000Z</published>
    <updated>2021-09-15T11:14:44.733Z</updated>
    
    <content type="html"><![CDATA[<p>CodeRunner本身是一个收费软件，功能强大，好处就不说了。在一些破解网站上可以找到破解版的，断网输入对应的激活码就能破解成功。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>每次重新打开，都需要重新破解。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>猜想的是每次打开CodeRunner时都会向其主站发送消息，查看是否激活，这里就是通过直接断开链接的方式来处理。</p><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>Mac系统下打开<code>/private/etc/</code>文件，hosts是文本。</p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>在hosts文件中，增加一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CodeRunner App</span><br><span class="line">127.0.0.1 coderunnerapp.com</span><br></pre></td></tr></table></figure><p>这样就可以验证成功了，不需要每次都重新激活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CodeRunner本身是一个收费软件，功能强大，好处就不说了。在一些破解网站上可以找到破解版的，断网输入对应的激活码就能破解成功。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2
      
    
    </summary>
    
    
    
      <category term="coderunner" scheme="http://liujiaboy.github.io/tags/coderunner/"/>
    
  </entry>
  
  <entry>
    <title>nx-8-logos</title>
    <link href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/"/>
    <id>http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/</id>
    <published>2021-09-13T08:27:26.000Z</published>
    <updated>2021-09-13T08:27:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nx-8-lldb</title>
    <link href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/"/>
    <id>http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/</id>
    <published>2021-09-13T08:11:20.000Z</published>
    <updated>2021-09-13T08:11:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nx-7-hook</title>
    <link href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/"/>
    <id>http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/</id>
    <published>2021-09-13T06:37:29.000Z</published>
    <updated>2021-09-13T06:37:29.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>github-443解决方案</title>
    <link href="http://liujiaboy.github.io/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://liujiaboy.github.io/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-06-19T03:12:52.000Z</published>
    <updated>2021-06-21T06:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p>在使用github的时候，执行<code>git pull</code>或者<code>git push</code>时，经常会出现以下错误：</p><blockquote><p>【Failed to connect to github.com port 443: Operation timed out】</p></blockquote><p>这个时候就一通百度、google发现有解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意啊、这个是不行的</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>这个时候你可能觉得：OK终于解决了。</p><p>但是，可能再你下次使用的时候又会出现类似的问题，或者又有新的问题出现。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>打开网站：<a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></p><p><img src="step-1.jpg" alt=""></p><p>web页面不要关，一会要用</p><h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p>打开网站：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></p><p><img src="step-2.jpg" alt=""></p><p>web页面不要关，一会要用</p><h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><p>打开网站<a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></p><p><img src="step-3.jpg" alt=""></p><p>web页面不要关，一会要用</p><h2 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h2><p>打开系统host，进行编辑，我这里使用的是Mac，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p><code>sudo</code>命令需要输入密码，之后，把我们上面打开的3个web对应的ip和host绑定，如下图：</p><p><img src="step-4.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ip            对应的host    </span><br><span class="line"># Github</span><br><span class="line">140.82.114.4    github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure><p>ip以自己打开的那3个web显示的为准。Windows请自行百度如何操作host。</p><h2 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h2><p>如果设置了<code>http.proxy</code>和<code>https.proxy</code> http/https代理，需要取消代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h2><p>刷新DNS，如果机型不同，不起作用，请自行查看<a href="https://support.apple.com/zh-cn/HT202516" target="_blank" rel="noopener">还原OS X 中的DNS缓存</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;support.apple.com&#x2F;zh-cn&#x2F;HT202516</span><br></pre></td></tr></table></figure><p>到这里就可以正常使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;出现的问题&quot;&gt;&lt;a href=&quot;#出现的问题&quot; class=&quot;headerlink&quot; title=&quot;出现的问题&quot;&gt;&lt;/a&gt;出现的问题&lt;/h1&gt;&lt;p&gt;在使用github的时候，执行&lt;code&gt;git pull&lt;/code&gt;或者&lt;code&gt;git push&lt;/code
      
    
    </summary>
    
    
      <category term="github" scheme="http://liujiaboy.github.io/categories/github/"/>
    
    
      <category term="github" scheme="http://liujiaboy.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>OC原理/oc-4-类的本质</title>
    <link href="http://liujiaboy.github.io/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://liujiaboy.github.io/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2021-06-18T10:04:13.000Z</published>
    <updated>2021-06-18T10:04:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对象、类对象、元类"><a href="#1-对象、类对象、元类" class="headerlink" title="1. 对象、类对象、元类"></a>1. 对象、类对象、元类</h1><h2 id="1-1-isa指向、superClass指向"><a href="#1-1-isa指向、superClass指向" class="headerlink" title="1.1 isa指向、superClass指向"></a>1.1 isa指向、superClass指向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#x2F;&#x2F;先把这里的协议注释掉，用到的时候再打开</span><br><span class="line">@protocol PersonProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *p_address;</span><br><span class="line"></span><br><span class="line">- (void)p_func1;</span><br><span class="line">+ (void)p_func1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_hobby;</span><br><span class="line">    CGFloat _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic) int age;</span><br><span class="line"></span><br><span class="line">- (void)func1;</span><br><span class="line">- (void)func2;</span><br><span class="line">+ (void)func3;</span><br><span class="line">+ (void)func4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后执行，直接打断点。</span><br><span class="line">Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">Teacher *t &#x3D; [[Teacher alloc] init];</span><br></pre></td></tr></table></figure><p>我们根据述代码进行分析，isa指针的指向。</p><blockquote><p>注意，这里是用的是模拟器</p></blockquote><h2 id="1-2-实例对象的isa"><a href="#1-2-实例对象的isa" class="headerlink" title="1.2 实例对象的isa"></a>1.2 实例对象的isa</h2><p>首先我们先看Person的实例p的isa指向情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先打印一下p的内存情况</span><br><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x1006460b0&gt;</span><br><span class="line">&#x2F;&#x2F; 输出p指针的情况</span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x1006460b0: 0x011d8001000083f9 0x0000000000000000</span><br><span class="line">0x1006460c0: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) p p 0x011d8001000083f9</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br></pre></td></tr></table></figure><p>这里拿到p指针指向的内存情况，我们知道第一块内存区域存放的是isa指针，直接打印的话，发现就是一串数字，啥也看不出来。还记得上一章中object_getClass反向验证isa指向最后的”&amp;”运算吗？<code>0x011d8001000083f9</code>这个值就是isa-&gt;bits，我们用它与<code>ISA_MASK</code>进行&amp;运算。因为这里是用的真机，所以<code>ISA_MASK = 0x00007ffffffffff8</code>，如果是用Mac或者模拟器，根据芯片类型判断是否是ARM64架构还是x86，然后使用对应的值进行换算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; p&#x2F;x输出内存的16进制</span><br><span class="line">(lldb) p&#x2F;x 0x011d8001000083f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $2 &#x3D; 0x00000001000083f8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里po就是Person类</span><br><span class="line">(lldb) po 0x00000001000083f8</span><br><span class="line">Person</span><br></pre></td></tr></table></figure><p>打印出来是Person。所以isa指向的就是Person类。那我们做一下验证，直接通过<code>object_getClass</code>方法来找一下Person这个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x object_getClass(p)</span><br><span class="line">(Class) $12 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure><p>是不是发现，Person类的内存地址是一样的。如果再实例化一个p1，看p1-&gt;isa指向的和p-&gt;isa指向的是否是同一个Person类的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接使用object_getClass获取类对象。</span><br><span class="line">lldb) p&#x2F;x object_getClass([Person alloc])</span><br><span class="line">(Class) $26 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure><p>答案是肯定的，Person类在内存中只有一份，也就是说所有的类对象在内存中都只有一份。</p><h2 id="1-3-类对象的isa"><a href="#1-3-类对象的isa" class="headerlink" title="1.3 类对象的isa"></a>1.3 类对象的isa</h2><p>接下来，我们继续寻找Person类对象的isa指向情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083f8</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x0000000100645d60 0x0001803000000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 &#x3D; 0x00000001000083d0</span><br><span class="line">(lldb) po 0x00000001000083d0</span><br><span class="line">Person</span><br></pre></td></tr></table></figure><p>发现Person类对象的isa指向的还是Person，但是这个Person所在的内存地址与Person类对象不一样。</p><p>这里就出现了元类的概念（Meta Class）。</p><h2 id="1-4-元类的isa"><a href="#1-4-元类的isa" class="headerlink" title="1.4 元类的isa"></a>1.4 元类的isa</h2><p>我们继续寻找元类的isa</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0x00000001000083d0是Person元类所在的内存</span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083d0</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x0000000100714d10 0x0002e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $9 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到NSObject的地址继续x&#x2F;4gx</span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a0f0</span><br><span class="line">0x10036a0f0: 0x000000010036a0f0 0x000000010036a140</span><br><span class="line">0x10036a100: 0x00000001007877b0 0x0003e03100000007</span><br></pre></td></tr></table></figure><p>使用相同的方法找到元类的<code>isa</code>指向的是<code>NSObject</code>，这个<code>NSObject</code>是类对象吗？</p><p>对<code>NSObject</code>继续<code>x/4gx</code>发现<code>isa</code>锁指向的内存地址是一样的。</p><p>我们通过<code>object_getClass([[NSObject alloc] init])</code>来看看<code>NSObject</code>类对象的内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取NSObject类的地址，与p&#x2F;x NSObject.class效果一致</span><br><span class="line">(lldb) p&#x2F;x object_getClass([NSObject alloc])</span><br><span class="line">(Class) $13 &#x3D; 0x000000010036a140 NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a140</span><br><span class="line">0x10036a140: 0x000000010036a0f0 0x0000000000000000</span><br><span class="line">0x10036a150: 0x0000000100786740 0x0002801000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从这里开始，就已经跟上面的内存地址重复了</span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $14 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure><p>到这里，是不是看明白了点啥？<code>NSObject</code>类对象也有指向<code>NSObject</code>的元类，<code>Person</code>的元类的<code>isa</code>指向的是<code>NSObject</code>的元类。</p><h3 id="1-5-使用相同的办法查看Teacher的isa"><a href="#1-5-使用相同的办法查看Teacher的isa" class="headerlink" title="1.5 使用相同的办法查看Teacher的isa"></a>1.5 使用相同的办法查看Teacher的isa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里使用简单的方式，直接使用Teacher类</span><br><span class="line">(lldb) x&#x2F;4gx Teacher.class</span><br><span class="line">0x100008380: 0x00000001000083a8 0x00000001000083f8</span><br><span class="line">0x100008390: 0x0000000100362370 0x0000803000000000</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083a8 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $18 &#x3D; 0x00000001000083a8</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000001000083a8</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083a8</span><br><span class="line">0x1000083a8: 0x000000010036a0f0 0x00000001000083d0</span><br><span class="line">0x1000083b8: 0x0000000101138140 0x0001e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $20 &#x3D; 0x000000010036a0f0</span><br><span class="line">&#x2F;&#x2F; 这里又指向了NSObject</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure><p>看到这里应该发现了点东西吧。实例对象的isa-&gt;类对象的isa-&gt;NSObject的isa，中间类对象与继承没有一丢丢关系。</p><h3 id="1-6-类的继承链"><a href="#1-6-类的继承链" class="headerlink" title="1.6 类的继承链"></a>1.6 类的继承链</h3><p>上面我们查看了isa的走向，接下来看一下继承链。首先看一下类的继承关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void testSuperClass(void)&#123;</span><br><span class="line">    Teacher *t &#x3D; [Teacher alloc];</span><br><span class="line">    Person  *p &#x3D; [Person alloc];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Teacher.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Person.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(NSObject.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出一下对应类的<code>superclass</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">NSObject</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure><p>从打印出来的信息可以看到:</p><ul><li>Teacher   -&gt; superclass = Person</li><li>Person    -&gt; superClass = NSObject</li><li>NSObject  -&gt; superClass = null</li></ul><h3 id="1-7-元类的继承链"><a href="#1-7-元类的继承链" class="headerlink" title="1.7 元类的继承链"></a>1.7 元类的继承链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void testNSObject(void) &#123;</span><br><span class="line">    &#x2F;&#x2F; NSObject实例对象</span><br><span class="line">    NSObject *object1 &#x3D; [NSObject alloc];</span><br><span class="line">    &#x2F;&#x2F; NSObject类</span><br><span class="line">    Class cls &#x3D; object_getClass(object1);</span><br><span class="line">    &#x2F;&#x2F; NSObject元类</span><br><span class="line">    Class metaClass &#x3D; object_getClass(cls);</span><br><span class="line">    &#x2F;&#x2F; NSObject根元类</span><br><span class="line">    Class rootMetaClass &#x3D; object_getClass(metaClass);</span><br><span class="line">    &#x2F;&#x2F; NSObject根根元类</span><br><span class="line">    Class rootRootMetaClass &#x3D; object_getClass(rootMetaClass);</span><br><span class="line">    NSLog(@&quot;\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类&quot;,object1,cls,metaClass,rootMetaClass,rootRootMetaClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Person元类</span><br><span class="line">    Class pMetaClass &#x3D; object_getClass(Person.class);</span><br><span class="line">    Class psuperClass &#x3D; class_getSuperclass(pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,pMetaClass,pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,psuperClass,psuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Teacher -&gt; Person -&gt; NSObject</span><br><span class="line">    &#x2F;&#x2F; 元类也有一条继承链</span><br><span class="line">    Class tMetaClass &#x3D; object_getClass(Teacher.class);</span><br><span class="line">    Class tsuperClass &#x3D; class_getSuperclass(tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tMetaClass,tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tsuperClass,tsuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; NSObject 根类特殊情况</span><br><span class="line">    Class nsuperClass &#x3D; class_getSuperclass(NSObject.class);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,nsuperClass,nsuperClass);</span><br><span class="line">    &#x2F;&#x2F; 根元类 -&gt; NSObject</span><br><span class="line">    Class rnsuperClass &#x3D; class_getSuperclass(metaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,rnsuperClass,rnsuperClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下输出结果：</p><ol><li><p>首先输出的NSObject的isa走位。NSObject实例对象 -&gt; 类 -&gt; 元类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x10124ba40 实例对象</span><br><span class="line">0x10036a140 类</span><br><span class="line">0x10036a0f0 元类</span><br><span class="line">0x10036a0f0 根元类</span><br><span class="line">0x10036a0f0 根根元类</span><br></pre></td></tr></table></figure><p> 从这里的输出结果可以进一步判断出NSObject类对象的元类指向它自己。</p></li><li><p>Person类对象的元类 -&gt; super</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Person类对象的元类</span><br><span class="line">Person - 0x100008498</span><br><span class="line">&#x2F;&#x2F; Person类对象的元类 -&gt; super</span><br><span class="line">NSObject - 0x10036a0f0</span><br></pre></td></tr></table></figure><p> 从地址的打印信息可以看出来，person类的元类的super指向的是NSObject类的元类。</p></li><li><p>Teacher元类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Teacher类对象的元类</span><br><span class="line">Teacher - 0x100008470</span><br><span class="line">&#x2F;&#x2F; Teacher类对象的元类 -&gt; super</span><br><span class="line">Person - 0x100008498</span><br></pre></td></tr></table></figure><p> 从这里可以看出来，Teacher元类的super指向的Person的元类，地址信息都是相同的。</p></li></ol><p>从上面的流程可以看到，类的继承关系和对应元类的继承关系是相对应的。可以用一张图完美的诠释isa的走向和super的指向。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="isa_metaclass.png" alt=""></p><ul><li>每个实例对象的isa指针指向与之对应的类对象(Class)。</li><li>每个类对象(Class)都有一个isa指针指向一个唯一的元类(Meta Class)。</li><li>每一个元类(Meta Class)的isa指针都指向最上层的元类(Meta Class)（图中的NSObject的Meta Class）。最上层的元类(Meta Class)的isa指针指向自己，形成一个回路。</li><li>每一个元类(Meta Class)的Super Class指向它原本Class的Super Class的Meta Class。最上层的Meta Class的Super Class指向NSObject Class本身。</li><li>最上层的NSObject Class的Super Class指向nil。</li><li>只有Class才有继承关系，实例对象与实例对象不存在继承关系。</li><li>每一个类对象(Class)在内存中都只有一份。</li></ul><h1 id="2-通过源码分析"><a href="#2-通过源码分析" class="headerlink" title="2. 通过源码分析"></a>2. 通过源码分析</h1><p>接下来我们从objc的源码上分析这些都是什么东西。</p><h2 id="2-1-实例对象-id（Instance）"><a href="#2-1-实例对象-id（Instance）" class="headerlink" title="2.1 实例对象 id（Instance）"></a>2.1 实例对象 id（Instance）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>id 这个struct的定义本身就带了 个 ＊, 所以我们在使用其他NSObject类型的实例时需要在前加上 ＊, 使 id 时却不用 。</p><p>什么是objc_object?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class. </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体, 在这个struct中有 个 isa 指针,指向它的类别 Class。 </p><h2 id="2-2-类对象-Class"><a href="#2-2-类对象-Class" class="headerlink" title="2.2 类对象 Class"></a>2.2 类对象 Class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>Class的本质就是一个<code>objc_class</code>的结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意，这个源码是被简化之后的。</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    Class getSuperclass() const &#123;</span><br><span class="line">        return superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setSuperclass(Class newSuperclass) &#123;</span><br><span class="line">        superclass &#x3D; newSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 用这个是无法获取rw_t，只能通过内存偏移获取bits，然后再获取rw_t</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isRootClass() &#123;</span><br><span class="line">        return getSuperclass() &#x3D;&#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isRootMetaclass() &#123;</span><br><span class="line">        return ISA() &#x3D;&#x3D; (Class)this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个结构体，大家可能会觉得不对，这个源码是错的，不是我们经常看到的，里头没有那些我们常说的变量，methodLists、ivars等等。<br>大家看仔细了哦，下面这个实现基本都是大家常看到的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;  </span><br><span class="line">    ...</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE</span><br></pre></td></tr></table></figure><p>里头确实有ivars、methodLists等，但是这个是<code>OBJC2_UNAVAILABLE</code>（我们目前使用的Objective-C的版本是2.0版本）。其内部确实有这些东西的，我们一步步去探究。</p><p>继续回到上面的结构体，发现ISA变量被注释掉了，其实也没有影响的，因为<code>objc_class</code> 继承自 <code>objc_object</code>（内部有isa变量）。那我们的属性、方法是存放在哪了呢？</p><p>通过查看源码，我们看到有这么一个属性<code>class_data_bits_t bits;</code>，这个东西里可能存放着我们需要的东西。稍后我们做验证。</p><h2 id="2-3-元类-Meta-Class"><a href="#2-3-元类-Meta-Class" class="headerlink" title="2.3 元类 Meta Class"></a>2.3 元类 Meta Class</h2><p>OC中一切皆为对象<br>Class在设计中本身也是一个对象,也有superclass。而这个Class对应的类我们叫“元类”（Meta Class）。也就是说Class中有一个isa指向的是Meta Class。</p><h1 id="3-验证属性、方法、协议存在的位置"><a href="#3-验证属性、方法、协议存在的位置" class="headerlink" title="3 验证属性、方法、协议存在的位置"></a>3 验证属性、方法、协议存在的位置</h1><h2 id="3-1-验证之前的准备-源码"><a href="#3-1-验证之前的准备-源码" class="headerlink" title="3.1 验证之前的准备 - 源码"></a>3.1 验证之前的准备 - 源码</h2><p>在2.2小结我们说了属性、方法、等可能存在于<code>class_data_bits_t</code>这个结构体内部，我们查看它的源码：</p><h3 id="3-1-1-class-data-bits-t"><a href="#3-1-1-class-data-bits-t" class="headerlink" title="3.1.1 class_data_bits_t"></a>3.1.1 class_data_bits_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">            return maybe_rw-&gt;ro();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">            return (class_ro_t *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在public的方法中有<code>class_rw_t* data()</code>这个方法，我们进一步探索：</p><h3 id="3-1-2-class-rw-t"><a href="#3-1-2-class-rw-t" class="headerlink" title="3.1.2 class_rw_t"></a>3.1.2 class_rw_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t witness;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint16_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实如我们所说的，这里确实存在着我们想要的东西：methods()、properties()、protocols()等。</p><p>那我们该怎么获取到这些数据，来证明这些就是我们想要的东西呢？</p><h3 id="3-1-3-内存偏移"><a href="#3-1-3-内存偏移" class="headerlink" title="3.1.3 内存偏移"></a>3.1.3 内存偏移</h3><p>我们知道在c语言中，一个数组，获取数组中的某个元素的值有多种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">printf(&quot;index 1 &#x3D; %d - %d&quot;, a[1], *(a+1));</span><br></pre></td></tr></table></figure><p>比如上面的代码，我们可以直接输出某个元素的下标，也可以通过内存地址来偏移进行读取，同样，我们也可以采取地址偏移来获取<code>objc_class-&gt;bits</code>的值。</p><p>需要偏移多少呢？</p><p>第一个变量是Class，这是一个结构体，内部有一个isa指针，所以这是8个字节。<br>第二个变量是cache_t，我们进源码看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">private:</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;    &#x2F;&#x2F; 8</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask;      &#x2F;&#x2F; 4</span><br><span class="line">#if __LP64__</span><br><span class="line">            uint16_t                   _flags;          &#x2F;&#x2F; 2</span><br><span class="line">#endif</span><br><span class="line">            uint16_t                   _occupied;       &#x2F;&#x2F; 2</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache; &#x2F;&#x2F; 8</span><br><span class="line">    &#125;;</span><br><span class="line">...   </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这些就能算出来我们需要多少字节，我已经标好了。静态变量和方法是没有算在结构体内部的哈，而且cache_t内部有一个共用体，所以其所占用的空间一共是8，再加上<code>_bucketsAndMaybeMask</code>变量一共是16个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class ISA;              &#x2F;&#x2F; 8</span><br><span class="line">Class superclass;       &#x2F;&#x2F; 8</span><br><span class="line">cache_t cache;          &#x2F;&#x2F; 16</span><br><span class="line">class_data_bits_t bits;</span><br></pre></td></tr></table></figure><p>所以8+8+16 = 32个字节。</p><p>也就是我们获取到的<code>objc_class</code>的isa指针，然后偏移32个字节，也就是<code>0x20</code>。当然也可以直接通过lldb输出<code>sizeOf(cache_t)</code>来获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $4 &#x3D; 16</span><br></pre></td></tr></table></figure><p>我们做一下验证，看看属性在哪。其实需要注意的一点是，我们要获取的是类对象，从类对象中查看我们的变量、方法和协议等，而不是从实例对象中获取，因为实例对象是已经在内存中了，比如属性已经有了具体的值了。</p><h3 id="3-1-4-method-array-t"><a href="#3-1-4-method-array-t" class="headerlink" title="3.1.4 method_array_t"></a>3.1.4 method_array_t</h3><p>我们继续跟踪源码，查看<code>method_array_t</code>是个啥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_array_t() : Super() &#123; &#125;</span><br><span class="line">    method_array_t(method_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *beginCategoryMethodLists() const &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *endCategoryMethodLists(Class cls) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们猜测我们想要的数据是在<code>method_list_t</code>中，而<code>method</code>就是我们的每一个的方法等结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    struct big &#123;</span><br><span class="line">        SEL name;</span><br><span class="line">        const char *types;</span><br><span class="line">        MethodListIMP imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">public:</span><br><span class="line">    big &amp;big() const &#123;</span><br><span class="line">        ASSERT(!isSmall());</span><br><span class="line">        return *(struct big *)this;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-5-property-array-t"><a href="#3-1-5-property-array-t" class="headerlink" title="3.1.5 property_array_t"></a>3.1.5 property_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class property_array_t : </span><br><span class="line">    public list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;property_t, property_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    property_array_t() : Super() &#123; &#125;</span><br><span class="line">    property_array_t(property_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同methods方法，我们看一下property_t</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-1-6-protocol-array-t"><a href="#3-1-6-protocol-array-t" class="headerlink" title="3.1.6 protocol_array_t"></a>3.1.6 protocol_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class protocol_array_t : </span><br><span class="line">    public list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    protocol_array_t() : Super() &#123; &#125;</span><br><span class="line">    protocol_array_t(protocol_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure><p>这三个分别对应<code>methods()、properties()、protocols()</code>方法，里头也一个共同点就是<code>protocol_array_t</code>。那我们重点看一下list_array_tt的结构。</p><h3 id="3-1-7-list-array-tt"><a href="#3-1-7-list-array-tt" class="headerlink" title="3.1.7 list_array_tt"></a>3.1.7 list_array_tt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class list_array_tt &#123;</span><br><span class="line">    struct array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        Ptr&lt;List&gt; lists[0];</span><br><span class="line"></span><br><span class="line">        static size_t byteSize(uint32_t count) &#123;</span><br><span class="line">            return sizeof(array_t) + count*sizeof(lists[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t byteSize() &#123;</span><br><span class="line">            return byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">    &#x2F;&#x2F; 这是一个迭代器</span><br><span class="line">    class iterator &#123;</span><br><span class="line">        const Ptr&lt;List&gt; *lists;</span><br><span class="line">        const Ptr&lt;List&gt; *listsEnd;</span><br><span class="line">        typename List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 迭代器相关的方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    union &#123;</span><br><span class="line">        Ptr&lt;List&gt; list;</span><br><span class="line">        uintptr_t arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>list_array_tt</code>结构体大概的可以看出来，<code>list_array_tt</code>只是一个list的封装。以<code>property_array_t</code>为例：</p><p><code>list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</code>就是一个存放了<code>property_t</code>类型的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    Ptr&lt;List&gt; list;</span><br><span class="line">    uintptr_t arrayAndFlag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>union</code>共用体才是一个list_array_tt对外暴露的真是结构，一会我们通过lldb进行验证。</p><h1 id="4-lldb-验证属性存放的位置"><a href="#4-lldb-验证属性存放的位置" class="headerlink" title="4 lldb 验证属性存放的位置"></a>4 lldb 验证属性存放的位置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line">0x100008418: 0x00000001012042e4 0x00000001000b9970</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过指针偏移0x20，也就是0x1000083f8+0x20，加上强制转换</span><br><span class="line">(lldb) p (class_data_bits_t *)0x100008418</span><br><span class="line">(class_data_bits_t *) $1 &#x3D; 0x0000000100008418</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到变量bits之后，通过class_data_bits_t -&gt; data()函数获取rw_t</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 &#x3D; 0x00000001012042e0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 看一下class_rw_t都有哪些值</span><br><span class="line">(lldb) p *$2</span><br><span class="line">(class_rw_t) $4 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2156396544</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4295000480</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; Teacher</span><br><span class="line">  nextSiblingClass &#x3D; NSBinder</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果有Subclass，则会有firstSubclass&#x3D;Teacher，如果没有子类则是nil</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们在class_rw_t中已经查看过源码，可以通过properties()获取属性列表</span><br><span class="line">(lldb) p $2-&gt;properties()</span><br><span class="line">(const property_array_t) $5 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008320</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000864</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合我们上面分析的结果，<code>property_array_t</code>输出的数据与上方<code>list_array_tt</code>内部的<code>union</code>共用体的结构是一直的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取属性列表</span><br><span class="line">(lldb) p $5.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $6 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008320</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">(lldb) p $6.ptr</span><br><span class="line">(property_list_t *const) $7 &#x3D; 0x0000000100008320</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; $8也就是我们的ptr内存储的列表</span><br></pre></td></tr></table></figure><p>但是<code>entsize_list_tt</code>又是什么类型？我们又该通过那种方式来获取我们最后想要的property呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt;&#x3D; count);</span><br><span class="line">        return *PointerModifier::modify(*this, (Element *)((uint8_t *)this + sizeof(*this) + i*entsize()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 注意。这里有一个 【&amp;】符号，调用getOrEnd，返回的是一个指针，进行转换</span><br><span class="line">    Element&amp; get(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt; count);</span><br><span class="line">        return getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>entsize_list_tt</code>内部有get方法，来获取其中的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $8.get(0)</span><br><span class="line">(property_t) $9 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $8.get(1)</span><br><span class="line">(property_t) $10 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) </span><br><span class="line">(lldb) p $8.get(2)</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br></pre></td></tr></table></figure><p>到这里，我们就输出了我们定义的2个属性，但是变量却没有在这里提现出来。我们继续看ivar存放在哪。</p><h1 id="5-lldb-成员变量"><a href="#5-lldb-成员变量" class="headerlink" title="5. lldb 成员变量"></a>5. lldb 成员变量</h1><p>从上面我们知道属性都存放在<code>class_rw_t</code>中，在查看<code>class_data_bits_t</code>源码的时候，也有看到<code>class_ro_t</code>。那ivar会不会就在这里呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class_data_bits_t 内部</span><br><span class="line"></span><br><span class="line">const class_ro_t *safe_ro() const &#123;</span><br><span class="line">    class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">    if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">        return maybe_rw-&gt;ro();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">        return (class_ro_t *)maybe_rw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    union &#123;</span><br><span class="line">        const uint8_t * ivarLayout;</span><br><span class="line">        Class nonMetaclass;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;const char *&gt; name;</span><br><span class="line">    &#x2F;&#x2F; With ptrauth, this is signed if it points to a small list, but</span><br><span class="line">    &#x2F;&#x2F; may be unsigned if it points to a big list.</span><br><span class="line">    void *baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    &#x2F;&#x2F; 这里存放的是ivars</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了获取property的经验，这里就方便多了，我们按照相同的方式来获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $1 (class_data_bits_t *) </span><br><span class="line">(lldb) p $1-&gt;safe_ro()</span><br><span class="line">(const class_ro_t *) $11 &#x3D; 0x00000001000081a0</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(const class_ro_t) $12 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 0</span><br><span class="line">  instanceStart &#x3D; 8</span><br><span class="line">  instanceSize &#x3D; 40</span><br><span class="line">  reserved &#x3D; 0</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    ivarLayout &#x3D; 0x0000000000000000</span><br><span class="line">    nonMetaclass &#x3D; nil</span><br><span class="line">  &#125;</span><br><span class="line">  name &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;const char *&gt; &#x3D; &quot;Person&quot; &#123;</span><br><span class="line">      Value &#x3D; 0x0000000100003edc &quot;Person&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList &#x3D; 0x00000001000081e8</span><br><span class="line">  baseProtocols &#x3D; 0x0000000000000000</span><br><span class="line">  ivars &#x3D; 0x0000000100008298</span><br><span class="line">  weakIvarLayout &#x3D; 0x0000000000000000</span><br><span class="line">  baseProperties &#x3D; 0x0000000100008320</span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE &#x3D; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从打印中的内容可以大致的猜测ivar应该存放在ivars。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $11.ivars</span><br><span class="line">(const ivar_list_t *const) $13 &#x3D; 0x0000000100008298</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $11-&gt;ivars</span><br><span class="line">(lldb) p $11-&gt;ivars</span><br><span class="line">(const ivar_list_t *const) $14 &#x3D; 0x0000000100008298</span><br><span class="line">(lldb) p *$14</span><br><span class="line">(const ivar_list_t) $15 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;ivar_t, ivar_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 32, count &#x3D; 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与property list是相同的结构</span><br><span class="line">(lldb) p $15.get(0)</span><br><span class="line">(ivar_t) $16 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008360</span><br><span class="line">  name &#x3D; 0x0000000100003f06 &quot;_hobby&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(1)</span><br><span class="line">(ivar_t) $17 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008368</span><br><span class="line">  name &#x3D; 0x0000000100003f0d &quot;_height&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f6f &quot;d&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(2)</span><br><span class="line">(ivar_t) $18 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008370</span><br><span class="line">  name &#x3D; 0x0000000100003f15 &quot;_age&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f71 &quot;i&quot;</span><br><span class="line">  alignment_raw &#x3D; 2</span><br><span class="line">  size &#x3D; 4</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(3)</span><br><span class="line">(ivar_t) $19 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008378</span><br><span class="line">  name &#x3D; 0x0000000100003f1a &quot;_name&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>到这里，我们也获取到了变量的位置，也说明了定义的属性会默认生成带下划线的同名变量。</p><p>接下来就是方法了。</p><h1 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $20 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x00000001000081e8</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与属性一致</span><br><span class="line">(lldb) p $20.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $21 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x00000001000081e8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $21.ptr</span><br><span class="line">(method_list_t *const) $22 &#x3D; 0x00000001000081e8</span><br><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $23.get(0)</span><br><span class="line">(method_t) $24 &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们按照属性的方式继续输出，结果<code>$23.get(0)</code>输出的确实空内容。</p><p>在说method_t时，结构体内部有<code>big()</code>的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $23.get(0).big()</span><br><span class="line">(method_t::big) $26 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func1&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c90 (AL-Objc&#96;-[Person func1])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(1).big()</span><br><span class="line">(method_t::big) $27 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func2&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cc0 (AL-Objc&#96;-[Person func2])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(2).big()</span><br><span class="line">(method_t::big) $28 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;name&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f53 &quot;@16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cf0 (AL-Objc&#96;-[Person name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(3).big()</span><br><span class="line">(method_t::big) $29 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setName:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f73 &quot;v24@0:8@16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d20 (AL-Objc&#96;-[Person setName:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(4).big()</span><br><span class="line">(method_t::big) $30 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;age&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f7e &quot;i16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d50 (AL-Objc&#96;-[Person age])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(5).big()</span><br><span class="line">(method_t::big) $31 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setAge:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f86 &quot;v20@0:8i16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d70 (AL-Objc&#96;-[Person setAge:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(6).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>我们在类中声明的方法都在<code>method_list_t</code>中，这里有我们自己声明的方法，还有属性自动生成的set和get方法。</p><p>发现这里并没有我们的类方法。因为类方法在元类里。</p><h1 id="7-类方法"><a href="#7-类方法" class="headerlink" title="7. 类方法"></a>7. 类方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取元类</span><br><span class="line">(lldb) p 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $33 &#x3D; 4295001040</span><br><span class="line">(lldb) po $33</span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;6gx $33</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x00000001006959d0 0x0002e03100000003</span><br><span class="line">0x1000083f0: 0x0000000101204304 0x00000001000083d0</span><br><span class="line">&#x2F;&#x2F; 获取元类的bits</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000083f0</span><br><span class="line">(class_data_bits_t *) $34 &#x3D; 0x00000001000083f0</span><br><span class="line">(lldb) p $34-&gt;data()</span><br><span class="line">(class_rw_t *) $35 &#x3D; 0x0000000101204300</span><br><span class="line">(lldb) p *$35</span><br><span class="line">(class_rw_t) $36 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2684878849</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4302330705</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; 0x00000001000083a8</span><br><span class="line">  nextSiblingClass &#x3D; 0x00007fff883ac410</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $35-&gt;methods()</span><br><span class="line">(const method_array_t) $37 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008168</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000424</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $37.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $38 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008168</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $38.ptr</span><br><span class="line">(method_list_t *const) $39 &#x3D; 0x0000000100008168</span><br><span class="line">(lldb) p *$39</span><br><span class="line">(method_list_t) $40 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; count &#x3D; 2告诉我们有2个</span><br><span class="line"></span><br><span class="line">(lldb) p $40.get(0).big()</span><br><span class="line">(method_t::big) $41 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func3&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c00 (AL-Objc&#96;+[Person func3])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(1).big()</span><br><span class="line">(method_t::big) $42 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func4&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c30 (AL-Objc&#96;+[Person func4])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(2).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>这里是获取类方法所在的位置。</p><h1 id="8-协议"><a href="#8-协议" class="headerlink" title="8 协议"></a>8 协议</h1><p>属性、变量、方法都已经有所了解，接下来看一下协议。把我们一开始注释的协议打开，重新运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000088d0: 0x00000001000088a8 0x000000010036a140</span><br><span class="line">0x1000088e0: 0x0000000100362370 0x0000803400000000</span><br><span class="line">0x1000088f0: 0x0000000100604204 0x00000001000b9970</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000088f0</span><br><span class="line">(class_data_bits_t *) $4 &#x3D; 0x00000001000088f0</span><br><span class="line">(lldb) p $4-&gt;data()</span><br><span class="line">(class_rw_t *) $5 &#x3D; 0x0000000100604200</span><br><span class="line">(lldb) p $5-&gt;protocols()</span><br><span class="line">(const protocol_array_t) $6 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008560</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001440</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $6.list</span><br><span class="line">(const RawPtr&lt;protocol_list_t&gt;) $7 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008560</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $7.ptr</span><br><span class="line">(protocol_list_t *const) $8 &#x3D; 0x0000000100008560</span><br><span class="line">(lldb) p *$8</span><br><span class="line">(protocol_list_t) $9 &#x3D; (count &#x3D; 1, list &#x3D; protocol_ref_t [] @ 0x00007ff5f7e1e9f8)</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>到此时，就不知道怎么处理，我们看一下<code>protocol_list_t</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    &#x2F;&#x2F; count is pointer-sized by accident.</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0]; &#x2F;&#x2F; variable-size</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是其内部的主要结构。我们用<code>list[0]</code>打印一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $9.list[0]</span><br><span class="line">(protocol_ref_t) $11 &#x3D; 4295002464</span><br></pre></td></tr></table></figure><p>上面我们已经说过<code>protocol_ref_t</code>只是一个定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure><p>接下来强转一下，看是否可以转成<code>protocol_t *</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (protocol_t *)$11</span><br><span class="line">(protocol_t *) $12 &#x3D; 0x0000000100008960</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们查看protocol_t内部的结构有demangledName()方法.</span><br><span class="line">(lldb) p $12-&gt;demangledName()</span><br><span class="line">(const char *) $13 &#x3D; 0x0000000100003b51 &quot;PersonProtocol&quot;</span><br></pre></td></tr></table></figure><p>到这里呢，协议存放的位置也找到了。</p><h1 id="9-补充添加协议之后"><a href="#9-补充添加协议之后" class="headerlink" title="9. 补充添加协议之后"></a>9. 补充添加协议之后</h1><h2 id="9-1-多了4个属性"><a href="#9-1-多了4个属性" class="headerlink" title="9.1 多了4个属性"></a>9.1 多了4个属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $5-&gt;properties()</span><br><span class="line">(const property_array_t) $15 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008710</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001872</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $16 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008710</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $16.ptr</span><br><span class="line">(property_list_t *const) $17 &#x3D; 0x0000000100008710</span><br><span class="line">(lldb) p *$17</span><br><span class="line">(property_list_t) $18 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加协议之后，又返回去重新打印了一下属性列表，发现这里变成了7个。明明之前只有2个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前打印的数据</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再加上协议中定义的一个，加起来也才3个，为什么会变成7个？这7个又是哪个属性？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $18.get(0)</span><br><span class="line">(property_t) $19 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $18.get(1)</span><br><span class="line">(property_t) $20 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) p $18.get(2)</span><br><span class="line">(property_t) $21 &#x3D; (name &#x3D; &quot;p_address&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N&quot;)</span><br><span class="line">(lldb) p $18.get(3)</span><br><span class="line">(property_t) $22 &#x3D; (name &#x3D; &quot;hash&quot;, attributes &#x3D; &quot;TQ,R&quot;)</span><br><span class="line">(lldb) p $18.get(4)</span><br><span class="line">(property_t) $23 &#x3D; (name &#x3D; &quot;superclass&quot;, attributes &#x3D; &quot;T#,R&quot;)</span><br><span class="line">(lldb) p $18.get(5)</span><br><span class="line">(property_t) $24 &#x3D; (name &#x3D; &quot;description&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br><span class="line">(lldb) p $18.get(6)</span><br><span class="line">(property_t) $25 &#x3D; (name &#x3D; &quot;debugDescription&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br></pre></td></tr></table></figure><p>发现，添加了协议之后，会增加<code>hash、superclass、description、debugDescription</code>4个属性。是因为我们定义的协议都遵循<code>&lt;NSObject&gt;</code>协议，在<code>&lt;NSObject&gt;</code>协议内部有这4个属性的声明。</p><h2 id="9-2-方法找不到了"><a href="#9-2-方法找不到了" class="headerlink" title="9.2 方法找不到了"></a>9.2 方法找不到了</h2><p>我们按照上面获取方法等顺序，结果在最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $3 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100722d01</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4302449921</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $4 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100722d01</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $4.ptr</span><br><span class="line">(method_list_t *const) $5 &#x3D; 0x0000000100722d01</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 0, count &#x3D; 2281701376)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在第6节的时候，输出过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有7个，但是这里怎么变成了这么大的一个值？？？<br>有知道的大佬，欢迎指导，谢谢。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul><li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li><li>isa的走位图，superClass的指向</li><li>属性、变量，实例方法、类方法的存放<ul><li>属性、变量的区别，存放的位置</li><li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li></ul></li><li>添加协议之后<ul><li>多了4个属性</li><li>方法找不到了，待补充</li></ul></li></ul><p>这里我们以name的get方法为例子，说明一下这都是什么意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;</span><br></pre></td></tr></table></figure><p><img src="function_table.png" alt=""></p><blockquote><p>@16@0:8</p></blockquote><ul><li>‘@’：第一个@表示返回值，对象</li><li>‘16’：16个字节</li><li>‘@’：第二个@表示对象类型(id)</li><li>‘0’：我们知道@表示对象，0表示从0开始，占8个字节</li><li>‘:’：SEL，方法明</li><li>‘8’：表示从8开始，占8个字节，满足一共16个字节</li></ul><p>sel 和 imp<br>sel：方法名<br>imp：方法实现。函数指针地址</p><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ul><li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li><li>isa的走位图，superClass的指向</li><li>属性、变量，实例方法、类方法的存放<ul><li>属性、变量的区别，存放的位置</li><li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li></ul></li><li>sel、imp的区别</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-对象、类对象、元类&quot;&gt;&lt;a href=&quot;#1-对象、类对象、元类&quot; class=&quot;headerlink&quot; title=&quot;1. 对象、类对象、元类&quot;&gt;&lt;/a&gt;1. 对象、类对象、元类&lt;/h1&gt;&lt;h2 id=&quot;1-1-isa指向、superClass指向&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nx-6-dyld</title>
    <link href="http://liujiaboy.github.io/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/"/>
    <id>http://liujiaboy.github.io/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/</id>
    <published>2021-06-04T03:45:14.000Z</published>
    <updated>2021-06-04T03:45:14.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MachO</title>
    <link href="http://liujiaboy.github.io/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/"/>
    <id>http://liujiaboy.github.io/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/</id>
    <published>2021-06-02T03:11:58.000Z</published>
    <updated>2021-06-04T03:44:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h1><p>Mach-O其实是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式， 类似于windows上的PE格式 (Portable Executable )， linux上的elf格式 (Executable and Linking Format)。</p><p>Mach-O是一种用于可执行文件、目标代码、动态库的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性。</p><h1 id="MachO格式的常见文件"><a href="#MachO格式的常见文件" class="headerlink" title="MachO格式的常见文件"></a>MachO格式的常见文件</h1><ul><li>目标文件.o </li><li>库文件<ul><li>.a</li><li>.dylib</li><li>.Framework</li></ul></li><li>可执行文件<ul><li>dyld</li><li>.dsym</li></ul></li></ul><p>关于静态库、动态库，这里有一篇文章，写的很好。<br><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a></p><h2 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h2><p>可以通过clang命令把对应的文件编译成mach-o文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -c test.c</span><br></pre></td></tr></table></figure><p>就会出现一个test.o的文件，这个就是mach-o类型的文件。</p><p>可以通过file命令查看文件类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ file [文件路径]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比如：</span><br><span class="line">$ file test.o</span><br><span class="line">test.o: Mach-O 64-bit object x86_64</span><br></pre></td></tr></table></figure><p>说明test.o文件是Mach-O，64位的object，适用于x86架构，64位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译为可执行文件</span><br><span class="line">$ clang text.o</span><br></pre></td></tr></table></figure><p>这个命令会吧test.o文件转换为可执行文件，类型为.out</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.out</span><br><span class="line">test.out: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure><p>text.out是一个可执行文件。</p><h2 id="clang编译多个文件"><a href="#clang编译多个文件" class="headerlink" title="clang编译多个文件"></a>clang编译多个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo test.c test1.c</span><br></pre></td></tr></table></figure><p>就是把<code>test.c</code>和<code>test1.c</code>两个文件合并为一个可执行文件demo</p><p>如果更改链接到顺序，则生成的可执行文件是不同的，md5值不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo1 test1.c test.c</span><br></pre></td></tr></table></figure><p>可以查看一下两个文件的md5值，是不同的，命令为<code>md5 [filename]</code>。</p><p>也可以通过<code>objdump</code>命令查看内容是否一样，这个命令类似于<code>MachOView</code>工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ objdump --macho -d [可执行文件file name]</span><br><span class="line">&#x2F;&#x2F; 查看demo可执行文件</span><br><span class="line">$ objdump --macho -d demo</span><br></pre></td></tr></table></figure><h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><p>dyld（the dynamic link editor）是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。</p><h2 id="dsym文件"><a href="#dsym文件" class="headerlink" title="dsym文件"></a>dsym文件</h2><p>当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。</p><p>在release下，编译之后查看dsym文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file file HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O dSYM companion file arm_v7] [arm64:Mach-O 64-bit dSYM companion file arm64]</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture armv7):Mach-O dSYM companion file arm_v7</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture arm64):Mach-O 64-bit dSYM companion file arm64</span><br></pre></td></tr></table></figure><p>这里出现了<code>universal binary</code>。这是个啥？就是通用二进制文件</p><h2 id="通用二进制文件"><a href="#通用二进制文件" class="headerlink" title="通用二进制文件"></a>通用二进制文件</h2><p>mac系统所支持的cpu及硬件平台发生了很大的变化，为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）,又称胖二进制（Fat Binary）。</p><ul><li>苹果公司提出的一种程序代码。能同时适用多种架构的二进制文件</li><li>同一个程序包中同时为多种架构提供最理想的性能。</li><li>因为需要储存多种代码，通用二进制应用程序通常比单一平台二进制的程序要大。但是由于两种架构有共通的非执行资源(代码以外的，图片等)，所以并不会达到单一版本的两倍之多。</li><li>而且由于执行中只调用一部分代码，运行起来也不需要额外的内存。</li></ul><p>在xcode中可以更改Mach-O Type：</p><p><img src="macho_xcode.jpg" alt=""></p><p>对于现在的Xcode来说，iOS11以上通过真机生成的可执行文件都是arm64架构，是单一架构。如果把最低版本修改为iOS10，重新真机编译，发现生成的可执行文件就是两种架构<code>armv7 + arm64</code>。</p><p>接下来，随便找个工程，release下编译，然后查看<code>HookDemo.app -&gt; HookDemo</code>可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file HookDemo</span><br><span class="line">HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O executable arm_v7] [arm64:Mach-O 64-bit executable arm64]</span><br><span class="line">HookDemo (for architecture armv7):Mach-O executable arm_v7</span><br><span class="line">HookDemo (for architecture arm64):Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure><p>也可以通过<code>Targets -&gt; Build Setting - Architectures</code>修改架构，只不过目前来说都是arm64。可以添加armv7、armv7s。</p><p>armv7s是一种临时的支持iPhone5c上可用的架构。</p><p><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p><p>原则上来说，架构都是向下兼容的。</p><h3 id="lipo命令拆分、合并通用二进制文件"><a href="#lipo命令拆分、合并通用二进制文件" class="headerlink" title="lipo命令拆分、合并通用二进制文件"></a>lipo命令拆分、合并通用二进制文件</h3><ul><li><p>查看Mach-O文件包含的架构信息</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info [MachO文件]</span><br></pre></td></tr></table></figure></li><li><p>拆分某种架构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</span><br><span class="line">$ lipo HookDemo -thin armv7 -output HookDemo_armv7</span><br></pre></td></tr></table></figure></li><li><p>合并多种架构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</span><br><span class="line">lipo -create HookDemo_armv7 HookDemo_arm64 -output HookDemo_v7_64</span><br></pre></td></tr></table></figure></li></ul><p>可以在通过file命令查看拆分、合并的文件。</p><h1 id="Macho文件结构"><a href="#Macho文件结构" class="headerlink" title="Macho文件结构"></a>Macho文件结构</h1><ul><li>Header ：包含该二进制文件的一般信息<ul><li>字节顺序、架构类型、加载指令的数量等。</li><li>使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么、文件类型是什么</li></ul></li><li>Load commands：包含加载所需要的指令（动态库、静态库等）<ul><li>内容包括区域的位置、符号表、动态符号表等</li></ul></li><li>Data ：内容包括区域的位置、符号表、动态符号表等<ul><li>包含Segement的具体数据</li></ul></li></ul><p><img src="macho_1.jpg" alt=""></p><p>接下来使用MachOView工具来分析可执行文件，有两种类型：</p><ol><li>通用二进制文件，则显示的是Fat Binary</li><li>单一架构的文件，直接显示对应的Executable</li></ol><p><img src="MachOView_Fat.jpg" alt=""></p><h2 id="Fat-Binary"><a href="#Fat-Binary" class="headerlink" title="Fat Binary"></a>Fat Binary</h2><p>在上图中可以看到，首先是一个Fat Header的结构。在header中，可以猜到两个架构之间必定存在某些关联。</p><p>armv7：offset=16384，size=79872<br>arm64：offset=98304，size=80672</p><p>arm64是从98304开始的，比armv7多了 98304-(16384+79872)=2048，这个值只是一个差值，而从偏移的差值来看98304-16384=81920 = 5 * 16 * 1024</p><p>正好是5页数据，iOS中1页是16k，所以armv7是5页数据，最后的2038只是第5页数据没有排满而已。</p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>接下来看看arm64架构下的内容：</p><p><img src="MachOView.png" alt=""></p><p>在Xcode中，我们可以在<code>loader.h</code>文件中找到Header的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;      &#x2F;* 魔数，快速定位属于64还是32位 *&#x2F;</span><br><span class="line">    cpu_type_t  cputype;    &#x2F;* CPU类型 *&#x2F;</span><br><span class="line">    cpu_subtype_t   cpusubtype; &#x2F;* CPU的具体类型 *&#x2F;</span><br><span class="line">    uint32_t    filetype;   &#x2F;* 文件类型，比如可执行文件 *&#x2F;</span><br><span class="line">    uint32_t    ncmds;      &#x2F;* Load Commands的条数 *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds; &#x2F;* Load Commands的大小 *&#x2F;</span><br><span class="line">    uint32_t    flags;      &#x2F;* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 *&#x2F;</span><br><span class="line">    uint32_t    reserved;   &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只放了arm64下的内容，当然也有32位的，内容基本一致。<br>这里需要注意的是filettype类型，是一组宏定义，也能找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#defineMH_OBJECT0x1&#x2F;* relocatable object file *&#x2F; object文件</span><br><span class="line">#defineMH_EXECUTE0x2&#x2F;* demand paged executable file *&#x2F; 可执行文件</span><br><span class="line">#defineMH_FVMLIB0x3&#x2F;* fixed VM shared library file *&#x2F;</span><br><span class="line">#defineMH_CORE0x4&#x2F;* core file *&#x2F;</span><br><span class="line">#defineMH_PRELOAD0x5&#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#defineMH_DYLIB0x6&#x2F;* dynamically bound shared library *&#x2F; dylib文件</span><br><span class="line">#defineMH_DYLINKER0x7&#x2F;* dynamic link editor *&#x2F;</span><br><span class="line">#defineMH_BUNDLE0x8&#x2F;* dynamically bound bundle file *&#x2F;</span><br><span class="line">#defineMH_DYLIB_STUB0x9&#x2F;* shared library stub for static</span><br><span class="line">   linking only, no section contents *&#x2F;</span><br><span class="line">#defineMH_DSYM0xa&#x2F;* companion file with only debug</span><br><span class="line">   sections *&#x2F; dsym文件</span><br><span class="line">#defineMH_KEXT_BUNDLE0xb&#x2F;* x86_64 kexts *&#x2F;</span><br><span class="line">#define MH_FILESET0xc&#x2F;* a file composed of other Mach-Os to</span><br><span class="line">   be run in the same userspace sharing</span><br><span class="line">   a single linkedit. *&#x2F;</span><br></pre></td></tr></table></figure><p>所以当看到0x2时，标识的就是可执行文件。在MachOView中，在Header中，可以看到对应的数据信息。</p><h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><table><thead><tr><th align="left">LoadCommands</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">LC_SEGMENT_64</td><td align="left">将文件中（32位或64位）的段映射到进程地址空间中，<br>主要分为<strong>TEXT、</strong>DATA、LINKEDIT几大块</td></tr><tr><td align="left">LC_DYLD_INFO_ONLY</td><td align="left">动态链接相关信息</td></tr><tr><td align="left">LC_SYMTAB</td><td align="left">符号地址</td></tr><tr><td align="left">LC_DYSYMTAB</td><td align="left">动态符号表地址</td></tr><tr><td align="left">LC_LOAD_DYLINKER</td><td align="left">使用谁加载，我们使用dyld</td></tr><tr><td align="left">LC_UUID</td><td align="left">Mach-O文件的唯一识别标识 UUID</td></tr><tr><td align="left">LC_VERSION_MIN_MACOSX</td><td align="left">支持最低的操作系统版本</td></tr><tr><td align="left">LC_SOURCE_VERSION</td><td align="left">源代码版本</td></tr><tr><td align="left">LC_MAIN</td><td align="left">设置程序主线程的入口地址和栈大小<br>当别人的app做了防护时，运行就是闪退，这个时候就需要从这里找切入点</td></tr><tr><td align="left">LC_ENCRYPTION_INFO_64</td><td align="left">加密信息</td></tr><tr><td align="left">LC_LOAD_DYLIB</td><td align="left">依赖库的路径，包含三方库</td></tr><tr><td align="left">LC_FUNCTION_STARTS</td><td align="left">函数起始地址表</td></tr><tr><td align="left">LC_CODE_SIGNATURE</td><td align="left">代码签名</td></tr></tbody></table><h3 id="LC-SEGMENT-64"><a href="#LC-SEGMENT-64" class="headerlink" title="LC_SEGMENT_64"></a>LC_SEGMENT_64</h3><p>这里面包含了一些基本信息：</p><ul><li><code>VM Address</code>：虚拟内存地址</li><li><code>VM Size</code>：(虚拟内存)大小为4G</li><li><code>File Offset</code>：数据在文件中的偏移地址</li><li><code>File Size</code>：数据在文件中的大小</li></ul><h3 id="LC-DYLD-INFO-ONLY"><a href="#LC-DYLD-INFO-ONLY" class="headerlink" title="LC_DYLD_INFO_ONLY"></a>LC_DYLD_INFO_ONLY</h3><p>这里主要说一下<code>Rebase Info Offset</code>，这个是重定向的偏移地址。</p><p>系统为了安全，在运行时，把Mach-O放在虚拟内存中，会随机生成一个<code>ASLR</code>，在运行时会进行重定向，比如查找字符串、方法等，都需要重定向，而重定向的方式是<code>ASLR</code>+<code>Rebase Info Offset</code>的值。</p><h2 id="Section64"><a href="#Section64" class="headerlink" title="Section64"></a>Section64</h2><p>主要氛围两大部分：</p><p>###__TEXT</p><p>主要存放：代码、字符常量、类、方法等。</p><table><thead><tr><th align="left">Section</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">__TEXT, __text</td><td align="left">主程序代码段</td></tr><tr><td align="left">__TEXT, __stubs</td><td align="left">Stub可以理解为一段占位空间，placeholder，用于符号的lazy binding。</td></tr><tr><td align="left">__TEXT, __stubs_helper</td><td align="left">辅助绑定</td></tr><tr><td align="left">__TEXT, __cstring</td><td align="left">C语言字符串</td></tr><tr><td align="left">__TEXT, __entitlements</td><td align="left">__entitlements</td></tr><tr><td align="left">__TEXT, __unwind_info</td><td align="left">C语言字符串</td></tr><tr><td align="left">__TEXT, __const</td><td align="left">常量段（const修饰）</td></tr><tr><td align="left">__TEXT, __objc_classname</td><td align="left">OC的类名</td></tr><tr><td align="left">__TEXT, __objc_methname</td><td align="left">OC方法名称</td></tr><tr><td align="left">__TEXT, __objc_methtype</td><td align="left">OC方法类型，即方法签名</td></tr></tbody></table><h3 id="DATA"><a href="#DATA" class="headerlink" title="__DATA:"></a>__DATA:</h3><table><thead><tr><th align="left">Section</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">__DATA_CONST, __got</td><td align="left">__got</td></tr><tr><td align="left">__DATA, __got</td><td align="left">__got</td></tr><tr><td align="left"><strong>DATA</strong>data</td><td align="left">已初始化的全局变量。static int a = 1;</td></tr><tr><td align="left">__DATA, __bss</td><td align="left">未初始化的静态变量。static int a;</td></tr><tr><td align="left">__DATA, __const</td><td align="left">常量。 char * const p = “foo”;</td></tr><tr><td align="left">__DATA, __cfstring</td><td align="left">字符串（CFStringRefs）</td></tr><tr><td align="left">__DATA, __common</td><td align="left">未初始化的外部全局变量。 int a;</td></tr><tr><td align="left">__DATA, __la_symbol_ptr</td><td align="left">懒绑定的符号指针表。</td></tr><tr><td align="left">__DATA, __nl_symbol_ptr</td><td align="left">非懒绑定的符号指针表。</td></tr><tr><td align="left">__DATA, __objc_classlist</td><td align="left">OC的类列表，存储一个个指向objc_class结构体的指针</td></tr><tr><td align="left">__DATA, __objc_nlclslist</td><td align="left">OC的类列表，+load相关？</td></tr><tr><td align="left">__DATA, __objc_catlist</td><td align="left">OC的category列表，存储一个个指向__objc_category结构体的指针</td></tr><tr><td align="left">__DATA, __objc_protolist</td><td align="left">OC的协议列表，存储一个个指向protocol_t结构体的指针</td></tr><tr><td align="left">__DATA, __objc_imginfo</td><td align="left">OC的image信息</td></tr><tr><td align="left">__DATA, __objc_selrefs</td><td align="left">哪些SEL对应的字符串被引用了</td></tr><tr><td align="left">__DATA, __objc_classrefs</td><td align="left">类的引用，即msg_objSend相关</td></tr><tr><td align="left">__DATA, __objc_superrefs</td><td align="left">super引用，记录了super方法调用的类。<br>如ViewController中的viewDidLoad中调用了<code>[super viewDidLoad]</code>，<br>则ViewController class即被记录。<br>也可以理解为objc_msgSendSuper相关。</td></tr><tr><td align="left">__DATA, __objc_protorefs</td><td align="left">协议引用</td></tr><tr><td align="left">__DATA, __objc_ivar</td><td align="left">成员变量</td></tr><tr><td align="left">__DATA, __objc_const</td><td align="left">这里的const与<code>__TEXT-&gt;const</code>完全不同。<br><code>__objc_const</code>指的是OC内存布局中的不可变部分，即class_ro_t类型。</td></tr><tr><td align="left">__DATA, __objc_data</td><td align="left">保存类所需的数据？</td></tr></tbody></table><p>篇幅原因，动态加载以及符号表下一篇再介绍。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Mach-O简介</li><li>clang命令<ul><li>编译成点O文件：$ clang -c test.c</li><li>把点O文件编译为可执行文件：$ clang text.o</li><li>查看文件类型：$ file text.out</li></ul></li><li>lipo命令<ul><li>查看二进制文件 $ lipo -info [MachO文件]</li><li>拆分为某一种架构：$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</li><li>合并多种架构：$ lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</li></ul></li><li>MachO就结构<ul><li>Header<ul><li>用于快速群定该文件的CPU类型、文件类型</li></ul></li><li>Load Commands<ul><li>指示加载器如何设置并且加载二进制数据</li></ul></li><li>Section64<ul><li>存放数据：代码、数据、字符串常量、类、方法等</li></ul></li></ul></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a><br><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mach-O简介&quot;&gt;&lt;a href=&quot;#Mach-O简介&quot; class=&quot;headerlink&quot; title=&quot;Mach-O简介&quot;&gt;&lt;/a&gt;Mach-O简介&lt;/h1&gt;&lt;p&gt;Mach-O其实是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>runloop</title>
    <link href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/"/>
    <id>http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/</id>
    <published>2021-05-30T05:34:10.000Z</published>
    <updated>2021-05-31T02:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RunLoop是事件接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个RunLoop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。</p><p>RunLoop本质是一个 do-while循环，没事做就休息，来活了就干活。与普通的while循环是有区别的，普通的while循环会导致CPU进入忙等待状态，即一直消耗cpu，而RunLoop则不会，RunLoop是一种闲等待，即RunLoop具备休眠功能。</p><h2 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h2><ul><li>保持程序的持续运行</li><li>处理App中的各种事件（触摸、定时器、performSelector）</li><li>节省cpu资源，提供程序的性能，该做事就做事，该休息就休息</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p><h2 id="runloop与线程"><a href="#runloop与线程" class="headerlink" title="runloop与线程"></a>runloop与线程</h2><p>通常情况下获取runloop的两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主运行循环</span><br><span class="line">CFRunLoopRef mainRunloop &#x3D; CFRunLoopGetMain();</span><br><span class="line">&#x2F;&#x2F; 当前运行循环</span><br><span class="line">CFRunLoopRef currentRunloop &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure><p>接下来看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    &#x2F;&#x2F; 这是一个静态变量</span><br><span class="line">    static CFRunLoopRef __main &#x3D; NULL; &#x2F;&#x2F; no retain needed</span><br><span class="line">    &#x2F;&#x2F; 没有获取到，则通过_CFRunLoopGet0函数去获取，参数是主线程</span><br><span class="line">    if (!__main) __main &#x3D; _CFRunLoopGet0(pthread_main_thread_np()); &#x2F;&#x2F; no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下<code>_CFRunLoopGet0</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如参数t不存在，则默认为主线程</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t &#x3D; pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建一个字典</span><br><span class="line">        CFMutableDictionaryRef dict &#x3D; CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        &#x2F;&#x2F; 创建mainLoop</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; dict : key value</span><br><span class="line">        &#x2F;&#x2F; 把main_thread和mainloop通过key-value的形式绑定</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从字典中通过线程获取run loop</span><br><span class="line">    CFRunLoopRef loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有则创建</span><br><span class="line">        CFRunLoopRef newLoop &#x3D; __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有loop也要存，存的是新创建的。</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop &#x3D; newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 &#x3D;&#x3D; _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看出，runloo只有两种类型，一种主线程的mainloop，还有就是其它runloop。</p><h2 id="runloop的创建"><a href="#runloop的创建" class="headerlink" title="runloop的创建"></a>runloop的创建</h2><p>接下来看runloop是怎么创建的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    CFRunLoopRef loop &#x3D; NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size &#x3D; sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop &#x3D; (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</span><br><span class="line">    &#x2F;&#x2F; 如果loop为空，则直接返回NULL</span><br><span class="line">    if (NULL &#x3D;&#x3D; loop) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; runloop属性赋值</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort &#x3D; __CFPortAllocate();</span><br><span class="line">    if (CFPORT_NULL &#x3D;&#x3D; loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems &#x3D; NULL;</span><br><span class="line">    loop-&gt;_currentMode &#x3D; NULL;</span><br><span class="line">    loop-&gt;_modes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head &#x3D; NULL;</span><br><span class="line">    loop-&gt;_blocks_tail &#x3D; NULL;</span><br><span class="line">    loop-&gt;_counterpart &#x3D; NULL;</span><br><span class="line">    loop-&gt;_pthread &#x3D; t;</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    loop-&gt;_winthread &#x3D; GetCurrentThreadId();</span><br><span class="line">#else</span><br><span class="line">    loop-&gt;_winthread &#x3D; 0;</span><br><span class="line">#endif</span><br><span class="line">    rlm &#x3D; __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL !&#x3D; rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面又有了一个CFRunLoopRef,盲猜应该是结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            &#x2F;* locked for accessing mode list *&#x2F;</span><br><span class="line">    __CFPort _wakeUpPort;            &#x2F;&#x2F; used for CFRunLoopWakeUp</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              &#x2F;&#x2F; reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义中可以得出，一个RunLoop有多个Mode，意味着一个RunLoop需要处理多个事务，即一个Mode对应多个Item，而一个item中，包含了timer、source、observer，如图：</p><p><img src="runloop_1.jpg" alt=""></p><h3 id="mode类型"><a href="#mode类型" class="headerlink" title="mode类型"></a>mode类型</h3><p>其中mode在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code>和<code>NSRunLoopCommonModes</code>。</p><p><code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p><ul><li>NSDefaultRunLoopMode：默认的mode，正常情况下都是在这个mode</li><li>NSConnectionReplyMode</li><li>NSModalPanelRunLoopMode</li><li>NSEventTrackingRunLoopMode：使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</li><li>NSRunLoopCommonModes：伪模式，灵活性更好</li></ul><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><ul><li>Source0 表示 非系统事件，即用户自定义的事件</li><li>Source1 表示系统事件，主要负责底层的通讯，具备唤醒能力</li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入RunLoop</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),</span><br><span class="line">    &#x2F;&#x2F;即将处理Timers</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),</span><br><span class="line">    &#x2F;&#x2F;即将处理Source</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),</span><br><span class="line">    &#x2F;&#x2F;即将进入休眠</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),</span><br><span class="line">    &#x2F;&#x2F;被唤醒</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),</span><br><span class="line">    &#x2F;&#x2F;退出RunLoop</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mode对应的items"><a href="#mode对应的items" class="headerlink" title="mode对应的items"></a>mode对应的items</h3><ul><li>block：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></li><li>timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></li><li>source0： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></li><li>source1： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></li><li>主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></li><li>observer： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></li></ul><h3 id="以Timer为例"><a href="#以Timer为例" class="headerlink" title="以Timer为例"></a>以Timer为例</h3><p>在子线程创建的timer是没有办法一直执行的，而想让它继续执行，则需要添加到runloop中，并且run才行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">self.isStopping &#x3D; NO;</span><br><span class="line">NSThread *thread &#x3D; [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; thread.name &#x3D; nil 因为这个变量只是捕捉</span><br><span class="line">    &#x2F;&#x2F; LGThread *thread &#x3D; nil</span><br><span class="line">    &#x2F;&#x2F; thread &#x3D; 初始化 捕捉一个nil进来</span><br><span class="line">    NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">    NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;~~hello word&quot;);            &#x2F;&#x2F; 退出线程--结果runloop也停止了</span><br><span class="line">        if (self.isStopping) &#123;</span><br><span class="line">            [NSThread exit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">thread.name &#x3D; @&quot;lgcode.com&quot;;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure><p>我们看一下addTimer是怎么操作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">oid CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</span><br><span class="line">    if (!__CFIsValid(rlt) || (NULL !&#x3D; rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop !&#x3D; rl)) return;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点 : kCFRunLoopCommonModes</span><br><span class="line">    if (modeName &#x3D;&#x3D; kCFRunLoopCommonModes) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是kCFRunLoopCommonModes 类型</span><br><span class="line">        CFSetRef set &#x3D; rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        </span><br><span class="line">        if (NULL &#x3D;&#x3D; rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            &#x2F;&#x2F; modeItems是空，则创建一个defalut</span><br><span class="line">            rl-&gt;_commonModeItems &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;runloop与mode 是一对多的， mode与item也是一对多的</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        if (NULL !&#x3D; set) &#123;</span><br><span class="line">            CFTypeRef context[2] &#x3D; &#123;rl, rlt&#125;;</span><br><span class="line">            &#x2F;* add new item to all common-modes *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;执行</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是非commonMode类型</span><br><span class="line">        &#x2F;&#x2F;查找runloop的模型</span><br><span class="line">        CFRunLoopModeRef rlm &#x3D; __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb &#x3D; kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal &#x3D; NULL;</span><br><span class="line">                rlm-&gt;_timers &#x3D; CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断mode是否匹配</span><br><span class="line">        if (NULL !&#x3D; rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop &#x3D; rl;</span><br><span class="line">            &#125; else if (rl !&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Normally we don&#39;t do this on behalf of clients, but for</span><br><span class="line">                &#x2F;&#x2F; backwards compatibility due to the change in timer handling...</span><br><span class="line">                if (rl !&#x3D; CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要目的就是把timer添加到对应的mode中。mode 和 item是一对多的关系，timer是item的一种。</p><h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><p>接下来上源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    do &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是timer</span><br><span class="line">        else if (modeQueuePort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                &#x2F;&#x2F; Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是source1</span><br><span class="line">        CFRunLoopSourceRef rls &#x3D; __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            mach_msg_header_t *reply &#x3D; NULL;</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            if (NULL !&#x3D; reply) &#123;</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__CFRunLoopDoTimers源码，主要是通过for循环，对单个timer进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;循环遍历，做下层单个timer的执行</span><br><span class="line">    for (CFIndex idx &#x3D; 0, cnt &#x3D; timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt &#x3D; (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        Boolean did &#x3D; __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled &#x3D; timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mode and rl are locked on entry and exit</span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    Boolean timerHandled &#x3D; false;</span><br><span class="line">    uint64_t oldFireTSR &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* Fire a timer *&#x2F;</span><br><span class="line">    CFRetain(rlt);</span><br><span class="line">    __CFRunLoopTimerLock(rlt);</span><br><span class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;&#x3D; mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop &#x3D;&#x3D; rl) &#123;</span><br><span class="line">    __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">        __CFRunLoopTimerFireTSRLock();</span><br><span class="line">        oldFireTSR &#x3D; rlt-&gt;_fireTSR;</span><br><span class="line">        __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">        </span><br><span class="line">        __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        if (doInvalidate) &#123;</span><br><span class="line">            CFRunLoopTimerInvalidate(rlt);      &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        if (context_release) &#123;</span><br><span class="line">            context_release(context_info);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        __CFRunLoopTimerLock(rlt);</span><br><span class="line">        timerHandled &#x3D; true;</span><br><span class="line">        __CFRunLoopTimerUnsetFiring(rlt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在timer执行的位置打上断点，使用lldb -&gt; bt命令查看调用栈：</p><p><img src="runloop_2.jpg" alt=""></p><h3 id="timer的调用顺序"><a href="#timer的调用顺序" class="headerlink" title="timer的调用顺序"></a>timer的调用顺序</h3><ol><li>自定义的timer，设置Mode，并将其加入RunLoop中</li><li>在RunLoop的run方法执行时，会调用__CFRunLoopDoTimers执行所有timer</li><li>在__CFRunLoopDoTimers方法中，会通过for循环执行单个timer的操作</li><li>在__CFRunLoopDoTimer方法中，timer执行完毕后，会执行对应的timer回调函数</li></ol><p>是针对timer的执行分析，对于observer、block、source0、source1，其执行原理与timer是类似的</p><p><img src="runloop_3.jpg" alt=""></p><h1 id="runloop底层原理"><a href="#runloop底层原理" class="headerlink" title="runloop底层原理"></a>runloop底层原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.0e10 : 科学计数 1*10^10，很大的值</span><br><span class="line">        result &#x3D; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped !&#x3D; result &amp;&amp; kCFRunLoopRunFinished !&#x3D; result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runloop就是一个do-while循环。当stop或者执行完成之后，则退出循环。</p><p>看一下<code>CFRunLoopRunSpecific</code>的内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内部函数，进入loop，seconds是一个很大的值</span><br><span class="line">    result &#x3D; __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来又回到<code>__CFRunLoopRun</code>的代码，上面提到的逻辑只是针对timer的，这里详细的说明一下，使用伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;核心函数</span><br><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;通过GCD开启一个定时器，然后开始跑圈</span><br><span class="line">    dispatch_source_t timeout_timer &#x3D; NULL;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    int32_t retVal &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;处理事务,即处理items</span><br><span class="line">    do &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理timer事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理Source事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 判断有无端口消息(Source1)</span><br><span class="line">        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理消息</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 等待被唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 被唤醒，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;else if (被GCD唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 处理gcd</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;else if (被source1唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 被Source1唤醒，处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunHandledSource;&#x2F;&#x2F;处理源</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunTimedOut;&#x2F;&#x2F;超时</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunFinished;&#x2F;&#x2F;结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理一下runloop的整体流程如下：</p><p><img src="runloop_4.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Runloop&quot;&gt;&lt;a href=&quot;#Runloop&quot; class=&quot;headerlink&quot; title=&quot;Runloop&quot;&gt;&lt;/a&gt;Runloop&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
    
      <category term="OC原理" scheme="http://liujiaboy.github.io/categories/OC%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="Objective-C," scheme="http://liujiaboy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>内存管理-自动释放池</title>
    <link href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/"/>
    <id>http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/</id>
    <published>2021-05-30T02:05:30.000Z</published>
    <updated>2021-05-31T02:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h1><p>新建一个工程，在main.m中就有一个autoreleasepool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过clang编译一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc main.m -o main.cpp</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">$ xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc main.m -o main-arm64.cpp</span><br></pre></td></tr></table></figure><p>我们打开对应的cpp文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    __AtAutoreleasePool() &#123;</span><br><span class="line">        atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 析构函数</span><br><span class="line">    ~__AtAutoreleasePool() &#123;</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        &#x2F;&#x2F; 是一个结构体</span><br><span class="line">         __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">&#123;__AtAutoreleasePool __autoreleasepool; &#125;</span><br></pre></td></tr></table></figure><p>__AtAutoreleasePool是一个结构体，有<code>构造函数</code> 和 <code>析构函数</code>，在结构体定义的对象在作用域结束后，会自动调用析构函数。</p><p>在源码中有这么一段话：</p><blockquote><p>  Autorelease pool implementation</p></blockquote><blockquote><p>  A thread’s autorelease pool is a stack of pointers.<br>  Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.<br>  A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.<br> The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary.<br> Thread-local storage points to the hot page, where newly autoreleased objects are stored. </p></blockquote><p>通过上述描述，可以大概的知道以下几点：</p><p>通过描述，有以下几点说明</p><ol><li>自动释放池 是一个 关于指针的栈结构</li><li>其中的指针是指要释放的对象或者 pool_boundary 哨兵（现在经常被称为 边界）</li><li>自动释放池是一个页的结构（虚拟内存中提及过） ，而且这个页是一个双向链表（表示有父节点 和 子节点，在类中有提及，即类的继承链）</li><li>自动释放池和线程有关系</li></ol><p>接下来看一下源码中的实现：</p><h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都有一个<code>AutoreleasePoolPage</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#96;class AutoreleasePoolPage : private AutoreleasePoolPageData&#96;</span><br><span class="line"></span><br><span class="line">struct AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;用来校验AutoreleasePoolPage的结构是否完整</span><br><span class="line">    magic_t const magic;    &#x2F;&#x2F;16个字节，以结构体中的变量对齐后的值为准，m[4] &#x3D; 4*4 &#x3D;16字节</span><br><span class="line">    &#x2F;&#x2F;指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()</span><br><span class="line">    __unsafe_unretained id *next;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向当前线程</span><br><span class="line">    pthread_t const thread;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向父节点，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage * const parent;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向子节点，最后一个结点的child值为nil</span><br><span class="line">    AutoreleasePoolPage *child;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;表示深度，从0开始，往后递增1</span><br><span class="line">    uint32_t const depth;&#x2F;&#x2F;4字节</span><br><span class="line">    &#x2F;&#x2F;表示high water mark 最大入栈数量标记</span><br><span class="line">    uint32_t hiwat;&#x2F;&#x2F;4字节</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们在回过头看看<code>objc_autoreleasePoolPush</code></p><h2 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    &#x2F;&#x2F;判断是否有pool</span><br><span class="line">    if (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Each autorelease pool starts on a new pool page</span><br><span class="line">        &#x2F;&#x2F; 自动释放池从新池页面开始</span><br><span class="line">        &#x2F;&#x2F;如果没有，则创建</span><br><span class="line">        dest &#x3D; autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;压栈一个POOL_BOUNDARY，即压栈哨兵</span><br><span class="line">        dest &#x3D; autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER || *dest &#x3D;&#x3D; POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoreleaseNewPage"><a href="#autoreleaseNewPage" class="headerlink" title="autoreleaseNewPage"></a>autoreleaseNewPage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建新页</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNewPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    &#x2F;&#x2F;如果存在，则压栈对象</span><br><span class="line">    if (page) return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#x2F;&#x2F;如果不存在，则创建页</span><br><span class="line">    else return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** hotPage方法 ********</span><br><span class="line">&#x2F;&#x2F;获取当前操作页</span><br><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前页</span><br><span class="line">    AutoreleasePoolPage *result &#x3D; (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    &#x2F;&#x2F;如果是一个空池，则返回nil，否则，返回当前线程的自动释放池</span><br><span class="line">    if ((id *)result &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** autoreleaseNoPage方法 ********</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; &quot;No page&quot; could mean no pool has been pushed</span><br><span class="line">    &#x2F;&#x2F; or an empty placeholder pool has been pushed and has no contents yet</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing a second pool over the empty placeholder pool</span><br><span class="line">        &#x2F;&#x2F; or pushing the first object into the empty placeholder pool.</span><br><span class="line">        &#x2F;&#x2F; Before doing that, push a pool boundary on behalf of the pool </span><br><span class="line">        &#x2F;&#x2F; that is currently represented by the empty placeholder.</span><br><span class="line">        pushExtraBoundary &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果对象不是哨兵对象，且没有Pool，则报错</span><br><span class="line">    else if (obj !&#x3D; POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place, </span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                     objc_thread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span><br><span class="line">    else if (obj &#x3D;&#x3D; POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;&#x2F;&#x2F;如果传入参数为哨兵</span><br><span class="line">        &#x2F;&#x2F; We are pushing a pool with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and alloc-per-pool debugging was not requested.</span><br><span class="line">        &#x2F;&#x2F; Install and return the empty pool placeholder.</span><br><span class="line">        return setEmptyPoolPlaceholder();&#x2F;&#x2F;设置空的占位符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We are pushing an object or a non-placeholder&#39;d pool.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    &#x2F;&#x2F;初始化第一页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    &#x2F;&#x2F;设置page为当前聚焦页</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push a boundary on behalf of the previously-placeholder&#39;d pool.</span><br><span class="line">    &#x2F;&#x2F;压栈哨兵的标识符为YES，则压栈哨兵对象</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        &#x2F;&#x2F;压栈哨兵</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object or pool.</span><br><span class="line">    &#x2F;&#x2F;压栈对象</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中autoreleaseNoPage方法中发现当前线程的自动释放池是通过AutoreleasePoolPage创建的，其定义中有构造方法，而构造方法的实现是通过父类AutoreleasePoolPageData的初始化方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;**********AutoreleasePoolPage构造方法**********</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),&#x2F;&#x2F;开始存储的位置</span><br><span class="line">                                objc_thread_self(),&#x2F;&#x2F;传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,&#x2F;&#x2F;如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">&#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        ASSERT(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        &#x2F;&#x2F;this 表示 新建页面，将当前页面的子节点 赋值为新建页面</span><br><span class="line">        parent-&gt;child &#x3D; this;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;**********AutoreleasePoolPageData初始化方法**********</span><br><span class="line">AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看一下几个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AutoreleasePoolPageData(begin(),&#x2F;&#x2F;开始存储的位置</span><br><span class="line">                                objc_thread_self(),&#x2F;&#x2F;传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,&#x2F;&#x2F;如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br></pre></td></tr></table></figure><ul><li><p><code>begin()</code>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;页的开始位置</span><br><span class="line">id * begin() &#123;</span><br><span class="line">    &#x2F;&#x2F;等于 首地址+56（AutoreleasePoolPage类所占内存大小）</span><br><span class="line">    return (id *) ((uint8_t *)this+sizeof(*this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>objc_thread_self()</code>： 表示的是当前线程，而当前线程时通过tls获取</p></li><li><p><code>newParent</code>： 父节点</p></li><li><p>后面两个参数是通过父节点的深度、最大入栈个数计算depth以及hiwat</p></li></ul><h3 id="自动释放池内存结构"><a href="#自动释放池内存结构" class="headerlink" title="自动释放池内存结构"></a>自动释放池内存结构</h3><p>由于在ARC模式下，是无法手动调用autorelease，所以将Demo切换至MRC模式。<br><code>Build Settings</code> -&gt; <code>Objectice-C Automatic Reference Counting</code>设置为<code>NO</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动释放池打印</span><br><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;************运行代码************</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F;循环创建对象，并加入自动释放池</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">             NSObject *objc &#x3D; [[NSObject alloc] sutorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用</span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="autorelease_1.png" alt=""></p><p>查看自动释放池的内存结构，发现page的开始与第一个对象的地址差是0x38，转换成十进制刚好是56，也就是 AutoreleasePoolPage自己本身的内存大小。</p><p>但是打印的是5个对象，但是这里有6个。第一个<code>pool</code>是啥？</p><p>哨兵对象。只在第一页有，防止释放时越界。</p><p>接着我们修改i的最大值为505。发现第二页开始有1个数据了。<br>接着在继续修改最大值为504+506，发现第三页也开始有1个数据了。</p><p>所以第一页有哨兵对象，可以存504个对象。第二页之后可以存505个对象。</p><p>在源码中<code>AutoreleasePoolPage</code>-&gt;size可以看到一页的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">static size_t const SIZE &#x3D; PAGE_MIN_SIZE;</span><br><span class="line"></span><br><span class="line">#define PAGE_MIN_SHIFT          12</span><br><span class="line">#define PAGE_MIN_SIZE           (1 &lt;&lt; PAGE_MIN_SHIFT)</span><br></pre></td></tr></table></figure><p>size = 1&lt;&lt;12 = 4096。</p><p>首地址是从0x38开始的，也就是56个字节，4096-46 = 4040 = 505 * 8<br>所以一页有506个对象。</p><p><img src="autorelease_2.jpg" alt=""></p><h3 id="autoreleaseFast压栈"><a href="#autoreleaseFast压栈" class="headerlink" title="autoreleaseFast压栈"></a>autoreleaseFast压栈</h3><p>push方法的第二步，第一步是创建，第二步是直接存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    &#x2F;&#x2F;判断页是否满了</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果未满，则压栈</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果满了，则安排新的页面</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;页不存在，则新建页</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前页没有满，则添加<code>add</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加释放对象</span><br><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    &#x2F;&#x2F;传入对象存储的位置</span><br><span class="line">    id *ret &#x3D; next;  &#x2F;&#x2F; faster than &#96;return next-1&#96; because of aliasing</span><br><span class="line">    &#x2F;&#x2F;将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置</span><br><span class="line">    *next++ &#x3D; obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果页满了则处理<code>autoreleaseFullPage</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full. </span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    ASSERT(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do-while遍历循环查找界面是否满了</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;如果子页面存在，则将页面替换为子页面</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        &#x2F;&#x2F;如果子页面不存在，则新建页面</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置为当前操作页面</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    &#x2F;&#x2F;对象压栈</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压栈流程"><a href="#压栈流程" class="headerlink" title="压栈流程"></a>压栈流程</h4><ol><li>如果页存在，且未满，则通过add方法压栈对象</li><li>如果页存在，且满了，则通过autoreleaseFullPage方法安排新的页面</li><li>如果页不存在，则通过autoreleaseNoPage方法创建新页</li></ol><h2 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 析构函数</span><br><span class="line">~__AtAutoreleasePool() &#123;</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在析构函数中传了一个参数，就是<code>atautoreleasepoolobj</code>对象，这样就可以和创建的autoreleasepool关联上了。接下来看一下pop的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;出栈</span><br><span class="line">static inline void</span><br><span class="line">pop(void *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">   &#x2F;&#x2F;判断对象是否是空占位符</span><br><span class="line">    if (token &#x3D;&#x3D; (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当是空占位符</span><br><span class="line">        &#x2F;&#x2F; Popping the top-level placeholder pool.</span><br><span class="line">        &#x2F;&#x2F;获取当前页</span><br><span class="line">        page &#x3D; hotPage();</span><br><span class="line">        if (!page) &#123;</span><br><span class="line">            &#x2F;&#x2F; Pool was never used. Clear the placeholder.</span><br><span class="line">            &#x2F;&#x2F;如果当前页不存在，则清除空占位符</span><br><span class="line">            return setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Pool was used. Pop its contents normally.</span><br><span class="line">        &#x2F;&#x2F; Pool pages remain allocated for re-use as usual.</span><br><span class="line">        &#x2F;&#x2F;如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置</span><br><span class="line">        page &#x3D; coldPage();</span><br><span class="line">        token &#x3D; page-&gt;begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;获取token所在的页</span><br><span class="line">        page &#x3D; pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stop &#x3D; (id *)token;</span><br><span class="line">    &#x2F;&#x2F;判断最后一个位置，是否是哨兵</span><br><span class="line">    if (*stop !&#x3D; POOL_BOUNDARY) &#123;</span><br><span class="line">        &#x2F;&#x2F;最后一个位置不是哨兵，即最后一个位置是一个对象</span><br><span class="line">        if (stop &#x3D;&#x3D; page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是第一个位置，且没有父节点，什么也不做</span><br><span class="line">            &#x2F;&#x2F; Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            &#x2F;&#x2F; 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            &#x2F;&#x2F; 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是第一个位置，且有父节点，则出现了混乱</span><br><span class="line">            &#x2F;&#x2F; Error. For bincompat purposes this is not </span><br><span class="line">            &#x2F;&#x2F; fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        return popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;出栈页</span><br><span class="line">    return popPage&lt;false&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下popPage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;出栈页面</span><br><span class="line">template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    if (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line">    &#x2F;&#x2F; 出栈当前操作页面对象</span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; memory: delete empty children 删除空子项</span><br><span class="line">    if (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        &#x2F;&#x2F; special case: delete everything during page-per-pool debugging</span><br><span class="line">        &#x2F;&#x2F;调试期间删除每个特殊情况下的所有池</span><br><span class="line">        &#x2F;&#x2F;获取当前页面的父节点</span><br><span class="line">        AutoreleasePoolPage *parent &#x3D; page-&gt;parent;</span><br><span class="line">        &#x2F;&#x2F;将当前页面杀掉</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        &#x2F;&#x2F;设置操作页面为父节点页面</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        &#x2F;&#x2F; special case: delete everything for pop(top)</span><br><span class="line">        &#x2F;&#x2F; when debugging missing autorelease pools</span><br><span class="line">        &#x2F;&#x2F;特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        &#x2F;&#x2F; hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stop就是自动释放池创建的位置。拿到stop的位置后，释放到stop位置之后的所有对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;释放到stop位置之前的所有对象</span><br><span class="line">void releaseUntil(id *stop) </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Not recursive: we don&#39;t want to blow out the stack  </span><br><span class="line">    &#x2F;&#x2F; 不是递归的：我们不想破坏堆栈</span><br><span class="line">    &#x2F;&#x2F; if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    &#x2F;&#x2F;判断下一个对象是否等于stop，如果不等于，则进入while循环</span><br><span class="line">    while (this-&gt;next !&#x3D; stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; Restart from hotPage() every time, in case -release </span><br><span class="line">        &#x2F;&#x2F; autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象</span><br><span class="line">        &#x2F;&#x2F;获取当前操作页面，即hot页面</span><br><span class="line">        AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fixme I think this &#96;while&#96; can be &#96;if&#96;, but I can&#39;t prove it</span><br><span class="line">        &#x2F;&#x2F;如果当前页是空的</span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;将page赋值为父节点页</span><br><span class="line">            page &#x3D; page-&gt;parent;</span><br><span class="line">            &#x2F;&#x2F;并设置当前页为父节点页</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        &#x2F;&#x2F;next进行--操作，即出栈</span><br><span class="line">        id obj &#x3D; *--page-&gt;next;</span><br><span class="line">        &#x2F;&#x2F;将页索引位置置为SCRIBBLE，表示已经被释放</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        if (obj !&#x3D; POOL_BOUNDARY) &#123;</span><br><span class="line">            &#x2F;&#x2F;释放</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置当前页</span><br><span class="line">    setHotPage(this);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; we expect any children to be completely empty</span><br><span class="line">    for (AutoreleasePoolPage *page &#x3D; child; page; page &#x3D; page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下<code>kill</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;销毁</span><br><span class="line">void kill() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Not recursive: we don&#39;t want to blow out the stack </span><br><span class="line">    &#x2F;&#x2F; if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F;获取最后一个页</span><br><span class="line">    while (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr &#x3D; page;</span><br><span class="line">        &#x2F;&#x2F;子节点 变成 父节点</span><br><span class="line">        page &#x3D; page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            &#x2F;&#x2F;子节点为nil</span><br><span class="line">            page-&gt;child &#x3D; nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr !&#x3D; this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autorelease-pop流程"><a href="#autorelease-pop流程" class="headerlink" title="autorelease pop流程"></a>autorelease pop流程</h3><ol><li>是否是空页，做容错处理</li><li>releaseUntil(stop)，按页倒序进行，循环释放所有对象，直到位置执行stop。先从child开始</li><li>页中的对象释放之后，page执行kill，循环删除child节点</li></ol><h2 id="autorelease底层"><a href="#autorelease底层" class="headerlink" title="autorelease底层"></a>autorelease底层</h2><p>看一下mrc下autorelease的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;如果不是对象，则直接返回</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    &#x2F;&#x2F;如果是小对象，也直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是小对象，则直接return，不处理。</li><li>如果是对象，执行<code>obj-&gt;autorelease()</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    &#x2F;&#x2F; 自定义对象</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootAutorelease();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 系统</span><br><span class="line">    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义对象，执行<code>rootAutorelease</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否为小对象</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象执行<code>rootAutorelease2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行的还是<code>AutoreleasePoolPage</code>这个对象，调用<code>autorelease</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    static inline id autorelease(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(obj);</span><br><span class="line">        ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused &#x3D; autoreleaseFast(obj);</span><br><span class="line">        ASSERT(!dest  ||  dest &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER  ||  *dest &#x3D;&#x3D; obj);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里调用的就是<code>autoreleaseFast</code>。就又回到了上面的压栈流程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>@autoreleasepool {} 等价于 {__AtAutoreleasePool __autoreleasepool; }，这是构造和析构函数</li><li>autorelease push压栈流程<ol><li>如果页存在，且未满，则通过add方法压栈对象</li><li>如果页存在，且满了，则通过autoreleaseFullPage方法安排新的页面</li><li>如果页不存在，则通过autoreleaseNoPage方法创建新页</li></ol></li><li>autorelease pop流程<ol><li>是否是空页，做容错处理</li><li>releaseUntil(stop)，按页倒序进行，循环释放所有对象，直到位置执行stop。先从child开始</li><li>页中的对象释放之后，page执行kill，循环删除child节点</li></ol></li><li>mrc下 autorelease原理<ol><li>判断是否为小对象，是直接return</li><li>执行<code>autoreleaseFast</code>，执行autorelease push压栈流程</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;autoreleasepool&quot;&gt;&lt;a href=&quot;#autoreleasepool&quot; class=&quot;headerlink&quot; title=&quot;autoreleasepool&quot;&gt;&lt;/a&gt;autoreleasepool&lt;/h1&gt;&lt;p&gt;新建一个工程，在main.m中就有一
      
    
    </summary>
    
    
      <category term="OC原理" scheme="http://liujiaboy.github.io/categories/OC%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="Objective-C," scheme="http://liujiaboy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://liujiaboy.github.io/2021/05/29/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://liujiaboy.github.io/2021/05/29/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-29T11:35:15.000Z</published>
    <updated>2021-05-31T02:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h1><ol><li>ARC/MRC</li><li>TarggedPointer: 专门用来处理小对象，比如NSNumber、NSDate、（NSString中有一种是targeed pointer）</li><li>Nonpointer_isa：非指针类型的isa。主要用来优化64位地址。</li><li>SideTables：散列表。主要有两种类型的表，引用计数表，弱引用表。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; viewDidLoad添加</span><br><span class="line">- (void)taggedPointerDemo &#123;</span><br><span class="line">  self.queue &#x3D; dispatch_queue_create(&quot;com.cjl.cn&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i&lt;10000; i++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            &#x2F;&#x2F; alloc堆上，iOS优化之后变成 taggedpointer</span><br><span class="line">            &#x2F;&#x2F; nameStr是NSTaggedPointerString</span><br><span class="line">            self.nameStr &#x3D; [NSString stringWithFormat:@&quot;aaa&quot;];  </span><br><span class="line">             NSLog(@&quot;%@&quot;,self.nameStr);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;来了&quot;);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;10000; i++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            &#x2F;&#x2F; nameStr是NSCFString</span><br><span class="line">            self.nameStr &#x3D; [NSString stringWithFormat:@&quot;aa-加油&quot;];</span><br><span class="line">            NSLog(@&quot;%@&quot;,self.nameStr);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码啊，发现在<code>taggedPointerDemo</code>方法中没有问题，但是点击屏幕，执行了touchesBegan就发生了崩溃。虽然在多线程时有过类似的例子，是由于多次释放造成的。但是这里的根本原因是<code>nameStr</code>在底层的类型不一致导致的，分别在两个赋值的方法处打上断点，看看是什么类型。</p><ul><li>taggedPointerDemo方法中的nameStr类型是 NSTaggedPointerString，存储在常量区。因为nameStr在alloc分配时在堆区，由于较小，所以经过xcode中iOS的优化，成了NSTaggedPointerString类型，存储在常量区。</li><li>touchesBegan方法中的nameStr类型是 NSCFString类型，存储在堆上</li></ul><h2 id="NSString的类型"><a href="#NSString的类型" class="headerlink" title="NSString的类型"></a>NSString的类型</h2><ol><li>NSCFConstantString：字符串常量，是一种编译时常量，retainCount值很大，对其操作，不会引起引用计数变化，存储在字符串常量区。</li><li>NSCFString：是在运行时创建的NSString子类，创建后引用计数会加1，存储在堆上。</li><li>NSTaggedPointerString：标签指针，是苹果在64位环境下对NSString、NSNumber等对象做的优化。对于NSString对象来说，当字符串是由数字、英文字母组合且长度小于等于9时，会自动成为NSTaggedPointerString类型，存储在常量区。</li><li>当有中文或者其他特殊符号时，会直接成为__NSCFString类型，存储在堆区。</li></ol><h2 id="Tagged-Pointer小对象"><a href="#Tagged-Pointer小对象" class="headerlink" title="Tagged Pointer小对象"></a>Tagged Pointer小对象</h2><p>接下来看一下tagged pointer对象的引用计数相关逻辑。直接上源码：</p><p><code>void objc_setProperty</code> -&gt; <code>reallySetProperty</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; copy和mutableCopy处理</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot &#x3D;&#x3D; newValue) return;</span><br><span class="line">        &#x2F;&#x2F; retain操作</span><br><span class="line">        newValue &#x3D; objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; release操作</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看retain和release内部做了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    &#x2F;&#x2F;判断是否是小对象，如果是，则直接返回对象</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    &#x2F;&#x2F;如果不是小对象，则retain</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****************objc_release****************</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">void </span><br><span class="line">objc_release(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return;</span><br><span class="line">    &#x2F;&#x2F;如果是小对象，则直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return;</span><br><span class="line">    &#x2F;&#x2F;如果不是小对象，则release</span><br><span class="line">    return obj-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是Tagged Pointer小对象，不会对引用计数做处理。</p><h3 id="小对象地址分析"><a href="#小对象地址分析" class="headerlink" title="小对象地址分析"></a>小对象地址分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">NSString *str2 &#x3D; [NSString stringWithFormat:@&quot;啊&quot;];</span><br><span class="line">NSLog(@&quot;%p-%@&quot;,str1,str1);</span><br><span class="line">NSLog(@&quot;%p-%@&quot;,str2,str2);</span><br></pre></td></tr></table></figure><p>看一下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xd3c9816ac08c01c6-a</span><br><span class="line">0x6000033631e0-啊</span><br></pre></td></tr></table></figure><p>在类的加载时，其中的_read_images源码有一个方法对小对象进行了处理，即initializeTaggedPointerObfuscator方法。</p><p>查看一下源码：<code>_read_images</code> -&gt; <code>initializeTaggedPointerObfuscator</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">initializeTaggedPointerObfuscator(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) ||</span><br><span class="line">        &#x2F;&#x2F; Set the obfuscator to zero for apps linked against older SDKs,</span><br><span class="line">        &#x2F;&#x2F; in case they&#39;re relying on the tagged pointer representation.</span><br><span class="line">        DisableTaggedPointerObfuscation) &#123;</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &#x3D; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Pull random data into the variable, then shift away all non-payload bits.</span><br><span class="line">        arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,</span><br><span class="line">                       sizeof(objc_debug_taggedpointer_obfuscator));</span><br><span class="line">        &#x2F;&#x2F; _OBJC_TAG_MASK 进行混淆</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &amp;&#x3D; ~_OBJC_TAG_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索<code>objc_debug_taggedpointer_obfuscator</code>，找到了encode和decode方法。分别是对tagged pointer的编码和解码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline uintptr_t</span><br><span class="line">_objc_decodeTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>encode时进行了一次<code>^</code>操作，decode时也进行了一次<code>^</code>操作。可以对值进行还原。</p><p>那我们分别打印一下decode后的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">NSLog(@&quot;%p-%@&quot;,str1,str1);</span><br><span class="line">NSLog(@&quot;0x%lx&quot;,_objc_decodeTaggedPointer_(str1));</span><br><span class="line"></span><br><span class="line">NSNumber *number1 &#x3D; @1;</span><br><span class="line">NSLog(@&quot;%@-%p-%@&quot;,object_getClass(number1),number1,number1);</span><br><span class="line">NSLog(@&quot;0x%lx&quot;,_objc_decodeTaggedPointer_(number3));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xe4742f5bd16235e6-a</span><br><span class="line">0xa000000000000611</span><br><span class="line"></span><br><span class="line">__NSCFNumber-0xf4742f5bd16233e5-1</span><br><span class="line">0xb000000000000012</span><br></pre></td></tr></table></figure><p>在源码中有一个判断条件，是否为TaggedPointer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline bool </span><br><span class="line">_objc_isTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;等价于 ptr &amp; 1左移63，即2^63，相当于除了64位，其他位都为0，即只是保留了最高位的值</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以0xa、0xb主要是用于判断是否是小对象taggedpointer，即判断条件，判断第64位上是否为1（taggedpointer指针地址即表示指针地址，也表示值）</p><p>0xa 转换成二进制为 1 010（64为为1，63~61后三位表示 tagType类型 - 2），表示NSString类型</p><p>0xb 转换为二进制为 1 011（64为为1，63~61后三位表示 tagType类型 - 3），表示NSNumber类型，这里需要注意一点，如果NSNumber的值是-1，其地址中的值是用补码表示的</p><p>这里可以通过_objc_makeTaggedPointer方法的参数tag类型objc_tag_index_t进入其枚举，其中 2表示NSString，3表示NSNumber</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;&#x3D; 201103L</span><br><span class="line">enum objc_tag_index_t : uint16_t</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t objc_tag_index_t;</span><br><span class="line">enum</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 60-bit payloads</span><br><span class="line">    OBJC_TAG_NSAtom            &#x3D; 0, </span><br><span class="line">    OBJC_TAG_1                 &#x3D; 1, </span><br><span class="line">    OBJC_TAG_NSString          &#x3D; 2,     &#x2F;&#x2F; NSString</span><br><span class="line">    OBJC_TAG_NSNumber          &#x3D; 3,     &#x2F;&#x2F; NSNumber</span><br><span class="line">    OBJC_TAG_NSIndexPath       &#x3D; 4, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID &#x3D; 5, </span><br><span class="line">    OBJC_TAG_NSDate            &#x3D; 6,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 60-bit reserved</span><br><span class="line">    OBJC_TAG_RESERVED_7        &#x3D; 7, </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 52-bit payloads</span><br><span class="line">    OBJC_TAG_Photos_1          &#x3D; 8,</span><br><span class="line">    OBJC_TAG_Photos_2          &#x3D; 9,</span><br><span class="line">    OBJC_TAG_Photos_3          &#x3D; 10,</span><br><span class="line">    OBJC_TAG_Photos_4          &#x3D; 11,</span><br><span class="line">    OBJC_TAG_XPC_1             &#x3D; 12,</span><br><span class="line">    OBJC_TAG_XPC_2             &#x3D; 13,</span><br><span class="line">    OBJC_TAG_XPC_3             &#x3D; 14,</span><br><span class="line">    OBJC_TAG_XPC_4             &#x3D; 15,</span><br><span class="line">    OBJC_TAG_NSColor           &#x3D; 16,</span><br><span class="line">    OBJC_TAG_UIColor           &#x3D; 17,</span><br><span class="line">    OBJC_TAG_CGColor           &#x3D; 18,</span><br><span class="line">    OBJC_TAG_NSIndexSet        &#x3D; 19,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload &#x3D; 0, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  &#x3D; 6, </span><br><span class="line">    OBJC_TAG_First52BitPayload &#x3D; 8, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  &#x3D; 263, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      &#x3D; 264</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>跟我们上面得到的结果是一样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Tagged Pointer小对象类型（用于存储NSNumber、NSDate、小NSString），小对象指针不再是简单的地址，而是地址 + 值，即真正的值，它只是一个披着对象皮的普通变量而以。所以可以直接进行读取。优点是占用空间小，节省内存</li><li>Tagged Pointer小对象 不会进入retain 和 release，意味着不需要ARC进行管理，所以可以直接被系统自主的释放和回收。</li><li>Tagged Pointer的内存并不存储在堆中，而是在常量区中，也不需要malloc和free。</li><li>对于NSString类型，建议直接使用<code>@&quot;&quot;</code>初始化赋值。</li></ul><h1 id="SideTables-散列表"><a href="#SideTables-散列表" class="headerlink" title="SideTables 散列表"></a>SideTables 散列表</h1><p>SideTables是一个hash表。在weak修饰时会存放在SideTables这个表中。</p><p>对于OC正常的对象来说当执行retain操作时，当引用计数达到一定的值（256）时，则会存放在SideTables中。</p><p>我们接下来看一下retain 的流程</p><h2 id="retain流程"><a href="#retain流程" class="headerlink" title="retain流程"></a>retain流程</h2><p>看一些源码：进入<code>objc_retain</code> -&gt; <code>retain</code> -&gt; <code>rootRetain</code>查看源码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">LWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line">    bool transcribeToSideTable &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;为什么有isa？因为需要对引用计数+1，即retain+1，而引用计数存储在isa的bits中，需要进行新旧isa的替换</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    &#x2F;&#x2F;重点</span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable &#x3D; false;</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">        &#x2F;&#x2F;判断是否为nonpointer isa</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果不是 nonpointer isa，直接操作散列表sidetable</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return (id)this;</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">            else return sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        &#x2F;&#x2F;dealloc源码</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        &#x2F;&#x2F;执行引用计数+1操作，即对bits中的 1ULL&lt;&lt;45（arm64） 即extra_rc，用于该对象存储引用计数值</span><br><span class="line">        newisa.bits &#x3D; addc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc++</span><br><span class="line">        &#x2F;&#x2F;判断extra_rc是否满了，carry是标识符</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; newisa.extra_rc++ overflowed</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Leave half of the retain counts inline and </span><br><span class="line">            &#x2F;&#x2F; prepare to copy the other half to the side table.</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            transcribeToSideTable &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F;如果extra_rc满了，则直接将满状态的一半拿出来存到extra_rc</span><br><span class="line">            newisa.extra_rc &#x3D; RC_HALF;</span><br><span class="line">            &#x2F;&#x2F;给一个标识符为YES，表示需要存储到散列表</span><br><span class="line">            newisa.has_sidetable_rc &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Copy the other half of the retain counts to the side table.</span><br><span class="line">        &#x2F;&#x2F;将另一半存在散列表的rc_half中，即满状态下是8位，一半就是1左移7位，即除以2</span><br><span class="line">        &#x2F;&#x2F;这么操作的目的在于提高性能，因为如果都存在散列表中，当需要release-1时，需要去访问散列表，每次都需要开解锁，比较消耗性能。extra_rc存储一半的话，可以直接操作extra_rc即可，不需要操作散列表。性能会提高很多</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析：</p><ol><li>isTaggedPointer直接返回。</li><li>不是nonpointer，直接存sideTable</li><li>是否正在释放，deallocating，返回nil</li><li>引用计数+1。</li><li>判断引用计数是否存满了，满了则变成一半，另一半存放在散列表中。</li></ol><p>之所以不直接把引用计数存放在散列表中，是因为对表的操作，需要用到锁，这是耗时操作。<br>如果每一个对象都需要一个散列表，也会造成性能问题。如果所有对象公用一个散列表，则其他数据可能不安全，所以也不会公用一个表。真机上最多有8个表。</p><h2 id="release流程"><a href="#release流程" class="headerlink" title="release流程"></a>release流程</h2><p>release流程与retain相反。</p><p><code>setProperty</code> -&gt; <code>reallySetProperty</code> -&gt; <code>objc_release</code> -&gt; <code>release</code> -&gt; <code>rootRelease</code> -&gt; <code>rootRelease</code>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool </span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return false;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">        &#x2F;&#x2F;判断是否是Nonpointer isa</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果不是，则直接操作散列表-1</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return false;</span><br><span class="line">            if (sideTableLocked) sidetable_unlock();</span><br><span class="line">            return sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        &#x2F;&#x2F;进行引用计数-1操作，即extra_rc-1</span><br><span class="line">        newisa.bits &#x3D; subc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc--</span><br><span class="line">        &#x2F;&#x2F;如果此时extra_rc的值为0了，则走到underflow</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; don&#39;t ClearExclusive()</span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    &#x2F;&#x2F; newisa.extra_rc-- underflowed: borrow from side table or deallocate</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; abandon newisa to undo the decrement</span><br><span class="line">    newisa &#x3D; oldisa;</span><br><span class="line">    &#x2F;&#x2F;判断散列表中是否存储了一半的引用计数</span><br><span class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            return rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Transfer retain count from side table to inline storage.</span><br><span class="line"></span><br><span class="line">        if (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; Need to start over to avoid a race against </span><br><span class="line">            &#x2F;&#x2F; the nonpointer -&gt; raw pointer transition.</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Try to remove some retain counts from the side table.</span><br><span class="line">        &#x2F;&#x2F;从散列表中取出存储的一半引用计数</span><br><span class="line">        size_t borrowed &#x3D; sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; To avoid races, has_sidetable_rc must remain set </span><br><span class="line">        &#x2F;&#x2F; even if the side table count is now zero.</span><br><span class="line"></span><br><span class="line">        if (borrowed &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Side table retain count decreased.</span><br><span class="line">            &#x2F;&#x2F; Try to add them to the inline count.</span><br><span class="line">            &#x2F;&#x2F;进行-1操作，然后存储到extra_rc中</span><br><span class="line">            newisa.extra_rc &#x3D; borrowed - 1;  &#x2F;&#x2F; redo the original decrement too</span><br><span class="line">            bool stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                &#x2F;&#x2F; Inline update failed. </span><br><span class="line">                &#x2F;&#x2F; Try it again right now. This prevents livelock on LL&#x2F;SC </span><br><span class="line">                &#x2F;&#x2F; architectures where the side table access itself may have </span><br><span class="line">                &#x2F;&#x2F; dropped the reservation.</span><br><span class="line">                isa_t oldisa2 &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 &#x3D; oldisa2;</span><br><span class="line">                if (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits &#x3D; </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</span><br><span class="line">                    if (!overflow) &#123;</span><br><span class="line">                        stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                &#x2F;&#x2F; Inline update failed.</span><br><span class="line">                &#x2F;&#x2F; Put the retains back in the side table.</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Decrement successful after borrowing from side table.</span><br><span class="line">            &#x2F;&#x2F; This decrement cannot be the deallocating decrement - the side </span><br><span class="line">            &#x2F;&#x2F; table lock and has_sidetable_rc bit ensure that if everyone </span><br><span class="line">            &#x2F;&#x2F; else tried to -release while we worked, the last one would block.</span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Side table is empty after all. Fall-through to the dealloc path.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;此时extra_rc中值为0，散列表中也是空的，则直接进行析构，即自动触发dealloc流程</span><br><span class="line">    &#x2F;&#x2F; Really deallocate.</span><br><span class="line">    &#x2F;&#x2F;触发dealloc的时机</span><br><span class="line">    if (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return overrelease_error();</span><br><span class="line">        &#x2F;&#x2F; does not actually return</span><br><span class="line">    &#125;</span><br><span class="line">    newisa.deallocating &#x3D; true;</span><br><span class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line"></span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送一个dealloc消息</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析如下：</p><ol><li><p>判断是否是Nonpointer isa，如果不是，则直接对散列表进行-1操作</p></li><li><p>如果是Nonpointer isa，则对extra_rc中的引用计数值进行-1操作，并存储此时的extra_rc状态到carry中</p></li><li><p>如果此时的状态carray为0，则走到underflow流程</p><p> underflow流程有以下几步：</p><ol><li>判断散列表中是否存储了一半的引用计数，如果是，则从散列表中取出存储的一半引用计数，进行-1操作，然后存储到extra_rc中</li><li>如果此时extra_rc没有值，散列表中也是空的，则直接进行析构，即dealloc操作，属于自动触发</li></ol></li></ol><h2 id="dealloc分析"><a href="#dealloc分析" class="headerlink" title="dealloc分析"></a>dealloc分析</h2><p>dealloc是在retainCount为0时系统自动触发的。</p><p><code>dealloc</code> -&gt; <code>_objc_rootDealloc</code> -&gt; <code>rootDealloc</code>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;对象要释放，需要做哪些事情？</span><br><span class="line">    &#x2F;&#x2F;1、isa - cxx - 关联对象 - 弱引用表 - 引用计数表</span><br><span class="line">    &#x2F;&#x2F;2、free</span><br><span class="line">    if (isTaggedPointer()) return;  &#x2F;&#x2F; fixme necessary?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果没有这些，则直接free</span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果有</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据条件判断是否有isa、cxx、关联对象、弱引用表、引用计数表，如果没有，则直接free释放内存</li><li>如果有，则进入object_dispose方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line">    &#x2F;&#x2F; 销毁实例而不会释放内存</span><br><span class="line">    objc_destructInstance(obj);</span><br><span class="line">    &#x2F;&#x2F;释放内存</span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_destructInstance</code>为了消耗实例对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        &#x2F;&#x2F;调用C ++析构函数</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        &#x2F;&#x2F;删除关联引用</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        &#x2F;&#x2F;释放</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在内部判断是否有析构函数，如果有则调用。</li><li>是否有关联对象，有的花移除关联对象。</li><li>执行clearDeallocating</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;判断是否为nonpointer isa</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for raw pointer isa.</span><br><span class="line">        &#x2F;&#x2F;如果不是，则直接释放散列表</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果是，清空弱引用表 + 散列表</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for non-pointer isa with weak refs and&#x2F;or side table data.</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clearDeallocating</code>的目的主要是为了清空散列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        &#x2F;&#x2F;清空弱引用表</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        &#x2F;&#x2F;清空引用计数</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空引用计数，情况弱引用表。</p><p>以上就是dealloc 的流程。</p><h2 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject *objc &#x3D; [NSObject alloc];</span><br><span class="line">NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)objc));</span><br></pre></td></tr></table></figure><p>上面输出的引用计数是多少？这是一个经典的面试题。</p><p>这里输出的结果是1。但是1是不对的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return _objc_rootRetainCount(self);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">inline uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    &#x2F;&#x2F;如果是nonpointer isa，才有引用计数的下层处理</span><br><span class="line">    if (bits.nonpointer) &#123;</span><br><span class="line">        &#x2F;&#x2F;alloc创建的对象引用计数为0，包括sideTable,所以对于alloc来说，是 0+1&#x3D;1，这也是为什么通过retaincount获取的引用计数为1的原因</span><br><span class="line">        uintptr_t rc &#x3D; 1 + bits.extra_rc;</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc +&#x3D; sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果不是，则正常返回</span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对象创建时，并没有存引用计数，bits.extra_rc还是0，当调用了retainCount时执行了<code>1 + bits.extra_rc</code>，所以就变成了1 。如果reatinCount=0，相当于创建成功之后就会被释放掉。</p><p>所以这里的答案应该是0。不管我有没有执行init操作，都是0 。在读的时候才会是1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存管理方案&quot;&gt;&lt;a href=&quot;#内存管理方案&quot; class=&quot;headerlink&quot; title=&quot;内存管理方案&quot;&gt;&lt;/a&gt;内存管理方案&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ARC/MRC&lt;/li&gt;
&lt;li&gt;TarggedPointer: 专门用来处理小对象，比如NSN
      
    
    </summary>
    
    
      <category term="OC原理" scheme="http://liujiaboy.github.io/categories/OC%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="Objective-C," scheme="http://liujiaboy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>启动优化</title>
    <link href="http://liujiaboy.github.io/2021/05/27/OC%E5%8E%9F%E7%90%86/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://liujiaboy.github.io/2021/05/27/OC%E5%8E%9F%E7%90%86/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-27T13:35:54.000Z</published>
    <updated>2021-05-31T02:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="虚拟内存-amp-物理内存"><a href="#虚拟内存-amp-物理内存" class="headerlink" title="虚拟内存 &amp; 物理内存"></a>虚拟内存 &amp; 物理内存</h2><p>我们在进程和物理内存之间增加一个中间层，这个中间层就是所谓的虚拟内存，主要用于解决当多个进程同时存在时，对物理内存的管理。提高了CPU的利用率，使多个进程可以同时、按需加载。</p><p>所以虚拟内存其本质就是一张虚拟地址和物理地址对应关系的映射表。</p><ul><li>每个进程都有一个独立的虚拟内存，从0开始，大小是4G固定的，每个虚拟内存又会划分为一个一个的页（page的大小在iOS中是16K，其他的是4K），每次加载都是以页为单位加载的，进程间是无法互相访问的，保证了进程间数据的安全性。</li><li>一个进程中，只有部分功能是活跃的，所以只需要将进程中活跃的页放入物理内存，避免物理内存的浪费。</li><li>当CPU需要访问数据时，首先是访问虚拟内存，然后通过虚拟内存去寻找真正的物理内存，然后对相应的物理地址进行访问</li><li>如果在访问时，虚拟地址的内容未加载到物理内存，会发生缺页异常（pagefault），此时需要先将数据载入到物理内存（这个过程是很快的），然后再读取。这样就避免了内存浪费</li></ul><p><img src="ram_map.jpg" alt=""></p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>虚拟内存的起始地址与大小都是固定的，这意味着，当我们访问时，其数据的地址也是固定的，这会导致我们的数据非常容易被破解，为了解决这个问题，所以苹果为了解决这个问题，在iOS4.3开始引入了ASLR技术。</p><p>ASLR的概念：(Address Space Layout Randomization ) 地址空间配置随机加载，是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><p>其目的的通过利用随机方式配置数据地址空间，使某些敏感数据（例如APP登录注册、支付相关代码）配置到一个恶意程序无法事先获知的地址，令攻击者难以进行攻击。</p><p>由于ASLR的存在，导致可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要在编译时来修复镜像中的资源指针，来指向正确的地址。即<code>正确的内存地址 = ASLR地址 + 偏移值</code></p><h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p>通用二进制文件是苹果公司提出的一种新的二进制文件的存储结构，可以同时存储多种架构的二进制指令，使CPU在读取该二进制文件时可以自动检测并选用合适的架构，以最理想的方式进行读取。</p><p>由于通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间，但由于系统会自动选择最合适的，不相关的架构代码不会占用内存空间，且执行效率高了。</p><p>Mach-O文件是Mach Object文件格式的缩写，它是用于可执行文件、动态库、目标代码的文件格式。作为a.out格式的替代，Mach-O格式提供了更强的扩展性，以及更快的符号表信息访问速度。经常使用<code>MachOView</code>工具来查看Mach-O文件。</p><h3 id="Mach-O的组成"><a href="#Mach-O的组成" class="headerlink" title="Mach-O的组成"></a>Mach-O的组成</h3><ul><li>Header：主要是Mach-O的cpu架构，文件类型以及加载命令等信息</li><li>Load Commands：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。（通常为framework、dylib的加载）</li><li>Data：数据区域<ul><li>__TEXT：只读，包括函数、静态变量等</li><li>__DATA：读写，可变的全局变量等</li><li>__LINKEDIT：方法、变量</li></ul></li></ul><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>启动的过程一般是指从用户点击app图标开始到<code>[AppDelegate didFinishLaunching</code>方法执行完成为止，其中，启动也分为冷启动和热启动</p><ul><li>冷启动：内存中不包含app相关数据的启动，一般我们可以通过重启手机来实现冷启动</li><li>热启动：是指杀掉app进程后，数据仍然存在时的启动</li></ul><p>而我们这里所说的启动优化，一般是指冷启动情况下的，这种情况下的启动主要分为两部分：</p><ul><li>T1 ：pre-main阶段，即main函数之前，操作系统加载App可执行文件到内存，执行一系列的加载、链接等工作，简单来说，就是dyld加载过程。</li><li>T2：main函数之后，即从main函数开始，到Appdelegate 的didFinishLaunching方法执行完成为止，主要是构建第一个界面，并完成渲染。</li></ul><p>所以，T1+T2的过程 就是 从用户点击App图标到用户能看到app主界面的过程，即需要启动优化的部分。</p><h2 id="pre-main阶段"><a href="#pre-main阶段" class="headerlink" title="pre-main阶段"></a>pre-main阶段</h2><p>pre-main阶段的启动时间其实就是dyld加载过程的时间。</p><p>针对main函数之前的启动时间，苹果提供了内建的测量方法，在<code>Edit Scheme -&gt; Run -&gt; Arguments -&gt; Environment Variables</code>点击【+】添加环境变量 <code>DYLD_PRINT_STATISTICS 设为 1</code>，然后运行，就可以直接打印相关数据。</p><p><img src="pre_main_time.jpg" alt=""></p><p>pre-main阶段一共耗时1.7s。</p><ul><li><code>dylib loading time</code>：主要是加载动态库，用时320.32ms</li><li><code>rebase/binding time</code>：偏移修正、符号绑定耗时，耗时160.52ms<ul><li><code>rebase</code>：偏移修正，任何一个app生成的二进制文件，在二进制文件内部所有的方法、函数调用，都有一个地址，这个地址是在当前二进制文件中的偏移地址。在APP运行是，每次系统都会随机分配一个ASLR（Address Space Layout Randomization，地址空间布局随机化）地址值，然后在加上偏移值就是运行时确定的内存地址。</li><li><code>binding</code>：绑定，例如NSLog方法，在编译时期生成的mach-o文件中，会创建一个符号！NSLog（目前指向一个随机的地址），然后在运行时（从磁盘加载到内存中，是一个镜像文件），会将真正的地址给符号（即在内存中将地址与符号进行绑定，是dyld做的，也称为动态库符号绑定），一句话概括：绑定就是给符号赋值的过程</li></ul></li><li><code>ObjC setup time</code>：OC类注册的耗时，OC类越多，越耗时</li><li><code>initializer time</code>：执行load和构造函数的耗时</li></ul><h3 id="pre-main优化建议"><a href="#pre-main优化建议" class="headerlink" title="pre-main优化建议"></a>pre-main优化建议</h3><ol><li>尽量减少外部动态库的使用。苹果建议自定义动态库的数量最好不要超过6个，超过6个则合并动态库。</li><li>减少OC类</li><li>讲不要的<code>+load</code>方法去掉，延迟到<code>+initialize</code>中</li><li>尽量减少C++函数</li></ol><h2 id="main-阶段"><a href="#main-阶段" class="headerlink" title="main 阶段"></a>main 阶段</h2><p>在main函数之后的<code>didFinishLaunching</code>方法中，主要是执行了各种业务，有很多并不是必须在这里立即执行的，这种业务我们可以采取延迟加载，防止影响启动时间。</p><p>在<code>didFinishLaunching</code>中，主要做一下几件事情：</p><ol><li>初始化第三方sdk</li><li>app运行环境配置</li><li>自定义工具的初始化等</li></ol><h3 id="main-阶段的优化"><a href="#main-阶段的优化" class="headerlink" title="main 阶段的优化"></a>main 阶段的优化</h3><ol><li>减少启动时需要初始化的sdk等，使用懒加载或者多线程处理。</li><li>优化代码，去除非必须的代码逻辑。</li><li>首页UI加载最后使用纯代码，避免使用xib和storybord（需要转换，更耗时）。</li><li>删除废弃的类、方法。</li></ol><h1 id="大招-二进制重排"><a href="#大招-二进制重排" class="headerlink" title="大招 二进制重排"></a>大招 二进制重排</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9" target="_blank" rel="noopener">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a></p><h3 id="System-Trace"><a href="#System-Trace" class="headerlink" title="System Trace"></a>System Trace</h3><p>基于Page Fault，App在冷启动过程中，会有大量的类、分类、三方等需要加载和执行，此时的产生的Page Fault所带来的的耗时是很大的。我们使用System Trace看下，在启动阶段的Page Fault的堆栈。</p><p>打开<code>Instruments</code>工具，选则<code>System Trace</code>。启动之后，在第一个界面出来之后，直接停掉。</p><p><img src="system_trace.jpg" alt=""></p><p>可以看到PageFault有2800次。</p><p>所以二进制重排要怎么重排呢？</p><h2 id="二进制重排原理"><a href="#二进制重排原理" class="headerlink" title="二进制重排原理"></a>二进制重排原理</h2><p>在虚拟内存部分，我们知道，当进程访问一个虚拟内存page，而对应的物理内存不存在时，会触发缺页中断（Page Fault），因此阻塞进程。此时就需要先加载数据到物理内存，然后再继续访问。这个对性能是有一定影响的。</p><p>所以我们就需要把先优先调用的方法等按照一定的顺序进行排列，这样就避免了<code>Page Falut</code>多次执行的情况。</p><p><img src="%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92.jpg" alt=""></p><p>可以查看上面抖音的文章，通过hook，大部分的方法都可以拿到，但是block、c++、initialize等方法是没有办法hook到，最后他们提到了clang插庄。</p><p>我们写一个Demo，来看一下编译的时期的顺序以及如何进行clang插庄。</p><p>在<code>target -&gt; Build Setting -&gt; Write Link Map File</code>设置为YES，可以查看linkMap文件代码的执行顺序。</p><h2 id="步奏"><a href="#步奏" class="headerlink" title="步奏"></a>步奏</h2><h3 id="添加编译参数"><a href="#添加编译参数" class="headerlink" title="添加编译参数"></a>添加编译参数</h3><p>在<code>Target -&gt; Build Setting -&gt; Custom Complier Flags -&gt; Other C Flags</code> 添加<br><code>-fsanitize-coverage=func,trace-pc-guard</code> 这个参数。此时编译会报错。</p><p>如果存在swift混编，还需要在 <code>Other Swift Flags</code> 中加入<code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code>。</p><h3 id="导入头文件，添加代码"><a href="#导入头文件，添加代码" class="headerlink" title="导入头文件，添加代码"></a>导入头文件，添加代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sanitizer&#x2F;coverage_interface.h&gt;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;原子队列，其目的是保证写入安全，线程安全</span><br><span class="line">static  OSQueueHead queue &#x3D; OS_ATOMIC_QUEUE_INIT;</span><br><span class="line">&#x2F;&#x2F;定义符号结构体，以链表的形式</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    void *pc;</span><br><span class="line">    void *next;</span><br><span class="line">&#125; ALNode;</span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,</span><br><span class="line">                                                    uint32_t *stop) &#123;</span><br><span class="line">  static uint64_t N;  &#x2F;&#x2F; Counter for the guards.</span><br><span class="line">  if (start &#x3D;&#x3D; stop || *start) return;  &#x2F;&#x2F; Initialize only once.</span><br><span class="line">  printf(&quot;INIT: %p %p\n&quot;, start, stop);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这个会拦截load方法，所以把这个注释掉</span><br><span class="line">    &#x2F;&#x2F; if (!*guard) return;</span><br><span class="line">    &#x2F;&#x2F;当前函数返回到上一个调用的地址，可以打断点通过lldb调试，使用bt命令，可以看到pc的值与0、1的关系。</span><br><span class="line">    void *PC &#x3D; __builtin_return_address(0);</span><br><span class="line">    &#x2F;&#x2F;创建结构体</span><br><span class="line">    SYNode * node &#x3D; malloc(sizeof(SYNode));</span><br><span class="line">    &#x2F;&#x2F; node赋值</span><br><span class="line">    *node &#x3D; (SYNode)&#123;PC,NULL&#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 加入结构!</span><br><span class="line">    OSAtomicEnqueue(&amp;symbolList, node, offsetof(SYNode, next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个页面加载完成，或者didFinishLaunching之后，调用输出，生成order_file。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)createOrderFile &#123;</span><br><span class="line">NSMutableArray&lt;NSString *&gt; * symbolNames &#x3D; [NSMutableArray array];</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F;offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量</span><br><span class="line">        SymbolNode * node &#x3D; OSAtomicDequeue(&amp;symboList, offsetof(SymbolNode, next));</span><br><span class="line">        if (node &#x3D;&#x3D; NULL) break;</span><br><span class="line">        Dl_info info;</span><br><span class="line">        dladdr(node-&gt;pc, &amp;info);</span><br><span class="line">        </span><br><span class="line">        NSString * name &#x3D; @(info.dli_sname);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 添加不是OC方法，需要添加下划线</span><br><span class="line">        BOOL isObjc &#x3D; [name hasPrefix:@&quot;+[&quot;] || [name hasPrefix:@&quot;-[&quot;];</span><br><span class="line">        NSString * symbolName &#x3D; isObjc ? name : [@&quot;_&quot; stringByAppendingString:name];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;去重</span><br><span class="line">        if (![symbolNames containsObject:symbolName]) &#123;</span><br><span class="line">            [symbolNames addObject:symbolName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取反</span><br><span class="line">    NSArray * symbolAry &#x3D; [[symbolNames reverseObjectEnumerator] allObjects];</span><br><span class="line">    NSLog(@&quot;%@&quot;,symbolAry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将结果写入到文件</span><br><span class="line">    NSString * funcString &#x3D; [symbolAry componentsJoinedByString:@&quot;\n&quot;];</span><br><span class="line">    NSString * filePath &#x3D; [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;lb.order&quot;];</span><br><span class="line">    NSData * fileContents &#x3D; [funcString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    BOOL result &#x3D; [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,filePath);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;文件写入出错&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链接order-file"><a href="#链接order-file" class="headerlink" title="链接order file"></a>链接order file</h3><p>在<code>target -&gt; build setting -&gt; order file</code> 导入我们生成的<code>.order</code>文件。</p><h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9" target="_blank" rel="noopener">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a></p><p><img src="https://juejin.cn/post/6844904130406793224" alt="iOS 优化篇 - 启动优化之Clang插桩实现二进制重排"><br><img src="https://www.jianshu.com/p/bae1e9bddcc9" alt="iOS优化篇之App启动时间优化"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;虚拟内存-amp-物理内存&quot;&gt;&lt;a href=&quot;#虚拟内存-amp-物理内存&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="OC原理" scheme="http://liujiaboy.github.io/categories/OC%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://liujiaboy.github.io/tags/iOS/"/>
    
      <category term="Objective-C," scheme="http://liujiaboy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>代码注入</title>
    <link href="http://liujiaboy.github.io/2021/05/25/%E9%80%86%E5%90%91/nx-4-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <id>http://liujiaboy.github.io/2021/05/25/%E9%80%86%E5%90%91/nx-4-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</id>
    <published>2021-05-25T05:55:24.000Z</published>
    <updated>2021-06-02T03:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h1><p>我们按照上一章（应用重签名）的逻辑，先把程序跑起来。</p><p>然后再<code>.app</code>中显示包内容，查看可执行文件。这里我们使用<code>MachOView</code>工具进行分析，这里我们主要查看的是<code>Load Commands</code>。</p><p><img src="MachOView.jpg" alt=""></p><p><code>Load Commands</code>：加载命令。</p><p>在<code>Load Commands</code>里头，可以看到所有的Framework。点击每一个Framework可以看到这个Framework的执行路径。</p><h2 id="Framework注入"><a href="#Framework注入" class="headerlink" title="Framework注入"></a>Framework注入</h2><h3 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h3><ol><li><p>在工程中选择<code>WeChat.xcodeproj</code>，然后在工程配置页面，选择左下角的加号”+“ -&gt; ”iOS“ -&gt; search ”Framework“。</p><p> <img src="add_framework.jpg" alt=""></p></li><li><p>创建一个类，添加<code>+(void)load</code>方法，打印一串字符串。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;\n\n hock success...\n\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>重新运行工程（使用重签名）。这个时候我们的<code>NSLog</code>并不会执行，因为并没有链接到可执行文件。</li></ol><pre><code>然后在项目工程`project` -&gt; `show in finder` -&gt; 找到对应的APP -&gt; 显示包内容 -&gt; Framework文件夹。可以看到我们添加的ALHook.framework。然后重新用`MachOView`工具打开可以执行文件（需要这个可执行文件），看看是否有链接ALHook.framework。这里是没有的。</code></pre><h3 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h3><p>通过<code>yololib</code>工具修改Mach-O文件，目的就是链接我们添加的动态库。</p><p>把<code>yololib</code>工具放到我们的工程文件中，与<code>appSign.sh</code>文件同级。然后把上面debug的可执行文件也同样复制过来。</p><p>然后执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;yololib [可执行文件] Frameworks&#x2F;[添加的动态库].framework&#x2F;[添加的动态库的可执行文件]</span><br><span class="line"></span><br><span class="line">$ .&#x2F;yololib WeChat Frameworks&#x2F;ALHook.framework&#x2F;ALHook</span><br></pre></td></tr></table></figure><p>执行完命令之后，重新使用<code>MachOView</code>工具打开可执行文件。</p><p><img src="MachO_ALHook.jpg" alt=""></p><h3 id="重新压缩，打包ipa文件"><a href="#重新压缩，打包ipa文件" class="headerlink" title="重新压缩，打包ipa文件"></a>重新压缩，打包ipa文件</h3><ol><li>重新解压<code>8.0.2.ipa</code>文件。</li><li>替换<code>Payload/xx.app -&gt; 显示包内容</code>中的可执行文件，把上一部链接好的可执行文件做替换。</li><li>重新压缩 <code>$ zip -ry WeChat.ipa Payload/</code>。</li><li>把压缩后的ipa包重新放在工程目录APP文件夹下。</li></ol><h3 id="重新运行"><a href="#重新运行" class="headerlink" title="重新运行"></a>重新运行</h3><p>这个时候重新运行，就可以看到我们的NSLog了。</p><p><img src="hook_success.jpg" alt=""></p><h2 id="dylib注入"><a href="#dylib注入" class="headerlink" title="dylib注入"></a>dylib注入</h2><p>我们按照上一章（应用重签名）的逻辑，先把程序跑起来。</p><h3 id="创建dylib"><a href="#创建dylib" class="headerlink" title="创建dylib"></a>创建dylib</h3><p>然后选择target -&gt; “+” -&gt; “macOs” -&gt; 搜索”library” -&gt; 选择”Library”，命名为”ALHook”。步奏与创建动态库类似。</p><h3 id="修改ALHook"><a href="#修改ALHook" class="headerlink" title="修改ALHook"></a>修改ALHook</h3><p>在<code>ALHook</code> -&gt; “Build Setting”中配置</p><ol><li>base sdk改为 <code>iOS</code></li><li>code signing identify 改为 <code>iOS Developer</code></li></ol><p>然后再文件中添加load方法，注入代码输出一串文本。</p><h3 id="添加依赖-Copy-Files"><a href="#添加依赖-Copy-Files" class="headerlink" title="添加依赖 Copy Files"></a>添加依赖 Copy Files</h3><p>在当前工程中拷贝dylib。</p><p><img src="add_dylib.jpg" alt=""></p><p>这里需要注意的是，<code>run script</code>的顺序一定是在<code>Copy Files</code>上的，因为如果顺序反了，会导致最后才执行脚本。则把copy的dylib文件给重新覆盖掉，因为脚本文件执行的是app替换。</p><h3 id="使用脚本执行"><a href="#使用脚本执行" class="headerlink" title="使用脚本执行"></a>使用脚本执行</h3><p>在上方动态库中我们是手动使用<code>/.yololib</code>工具进行链接的，这里我们使用脚本，在原来的<code>appSigh.sh</code>文件末尾添加一句代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 链接手动添加的库，做代码注入</span><br><span class="line">.&#x2F;yololib &quot;$TARGET_APP_PATH&#x2F;$APP_BINARY&quot; &quot;Frameworks&#x2F;libALHook.dylib&quot;</span><br></pre></td></tr></table></figure><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p>直接运行代码，可以在Framework中看到<code>libALHook.dylib</code>文件。</p><p>运行成功之后，可以看到我们的输出。</p><h1 id="代码注入流程总结"><a href="#代码注入流程总结" class="headerlink" title="代码注入流程总结"></a>代码注入流程总结</h1><ul><li>Framework手动注入，是为了熟悉原理，真正操作的时候我们使用的都是脚本文件，从繁到简。</li><li>Framework流程：<ol><li>Xcode新建Framework。</li><li>通过yololib工具是Mach-O文件链接Framework文件。<ul><li>所有的Framework加载都是由DYLD加载进入内存被执行的</li><li>注入成功的库路径会写入到Mach-O文件的<code>LC_LOAD_DYLIB</code>字段中</li></ul></li></ol></li><li>dylib注入流程：<ol><li>Xcode新建<code>dylib</code>库，然后修改”Build Setting”<ol><li>base sdk改为 <code>iOS</code></li><li>code signing identify 改为 <code>iOS Developer</code></li></ol></li><li>添加依赖，<code>Copy Files</code>将dylib文件拷贝到APP包中</li><li>通过yololib工具链接dylib文件。</li></ol></li></ul><p>这里需要注意的是，顺序不能错误，如下图：</p><p><img src="script_framework.jpg" alt=""></p><h1 id="真正的代码注入"><a href="#真正的代码注入" class="headerlink" title="真正的代码注入"></a>真正的代码注入</h1><p>我们使用Framework的形式进行注入。因为比较方便，dylib需要修改一些东西。</p><p>这里也直接使用dylib中使用脚本的方式进行注入。</p><h2 id="Debug-View-Hierarchy调试"><a href="#Debug-View-Hierarchy调试" class="headerlink" title="Debug View Hierarchy调试"></a>Debug View Hierarchy调试</h2><p><img src="hook_register.jpg" alt=""></p><p>我们看一下图片上的内容，通过<code>Debug View Hierarchy</code>的方式，先获取到我们想要的东西。</p><p>这里可以看到注册按钮的相关信息：</p><ol><li>是一个<code>FixTitleColorButton</code>的类，应该是封装的Button</li><li>指定的target是<code>WCAccountLoginControlLogic</code>。</li><li>相应的action是<code>onFirstViewRegister</code>。</li></ol><p>能拿到这些信息，就可以直接通过runtime的方法替换就可以直接修改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method oldRegister &#x3D; class_getInstanceMethod(objc_getClass(&quot;WCAccountLoginControlLogic&quot;), @selector(onFirstViewRegister));</span><br><span class="line">    </span><br><span class="line">    Method newRegister &#x3D; class_getInstanceMethod([self class], @selector(new_register));</span><br><span class="line">    method_exchangeImplementations(oldRegister, newRegister);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)new_register &#123;</span><br><span class="line">    NSLog(@&quot;new register...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就把原来的注册方法给替换掉了，点击注册会输出者一串字符。</p><p>接下来我们要在点击登录时，拿到用户密码，并且不影响正常的登录流程。</p><h2 id="class-dump工具"><a href="#class-dump工具" class="headerlink" title="class-dump工具"></a>class-dump工具</h2><p>如果我们通过使用上面的方式，可以轻松的拿到用户名和密码，但是这是通过响应链一层层的去找的，所以也就有了这么个工具，可以直接输出OC中的类、方法、属性等内容。</p><p>把<code>WeChat</code>的可执行文件拷贝出来，和<code>class-dump</code>工具放在相同目录中(也可以是其他目录)，然后执行下述命令，可以输出所有的header文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;class-dump -H WeChat -o .&#x2F;headers&#x2F;</span><br></pre></td></tr></table></figure><p>然后我们通过<code>Debug View Hierarchy</code>找到对应的账号密码登录页面，查看页面的class和文本框的class，进一步在输出的头文件中找。</p><p><img src="hook_class_dump.jpg" alt=""></p><p>我们用同样的方式继续找<code>WCAccountTextFieldItem</code>。发现在<code>WCBaseTextFieldItem</code>有一个<code>WCUITextField</code>，继承自<code>UITextField</code>也就是我们要找的文本框。</p><p>在通过<code>Debug View Hierarchy</code>找到登录的点击事件。为<code>onNext</code>。能拿到这些信息，就可以操作了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+(void)load &#123;</span><br><span class="line">    &#x2F;&#x2F;原始的Method</span><br><span class="line">    Method onNext &#x3D; class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(onNext));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加新方法!</span><br><span class="line">    class_addMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(new_onNext), new_onNext, &quot;v@:&quot;);</span><br><span class="line">    &#x2F;&#x2F;交换</span><br><span class="line">    method_exchangeImplementations(onNext, class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(new_onNext)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新的IMP</span><br><span class="line">void new_onNext(id self,SEL _cmd)&#123;</span><br><span class="line">    UITextField * pwd &#x3D; (UITextField *)[[self valueForKey:@&quot;_textFieldUserPwdItem&quot;] valueForKey:@&quot;m_textField&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;密码是:%@&quot;,pwd.text);</span><br><span class="line">    &#x2F;&#x2F;调用回原来的逻辑!!</span><br><span class="line">    &#x2F;&#x2F;调用原来的方法!</span><br><span class="line">    [self performSelector:@selector(new_onNext)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里是在原来的<code>WCAccountMainLoginViewController</code>类中添加方法，而不是用注册时的那种方法，是因为会造成crash，因为使用的是<code>exchange</code>方法交换，在<code>WCAccountMainLoginViewController</code>类执行<code>new_onNext</code>方法时找不到对应的方法。</p><p>这种是使用<code>class_addMethod</code>在<code>WCAccountMainLoginViewController</code>中添加了一个方法。接下来我们使用setImp和getImp的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(void)load&#123;</span><br><span class="line">    &#x2F;&#x2F;原始的Method</span><br><span class="line">    old_onNext &#x3D; method_getImplementation(class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(onNext)));</span><br><span class="line">    method_setImplementation(class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(onNext)), new_onNext);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义原来的IMP</span><br><span class="line">IMP (*old_onNext)(id self,SEL _cmd);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义新的IMP</span><br><span class="line">void new_onNext(id self,SEL _cmd)&#123;</span><br><span class="line">    UITextField * pwd &#x3D; (UITextField *)[[self valueForKey:@&quot;_textFieldUserPwdItem&quot;] valueForKey:@&quot;m_textField&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;密码是:%@&quot;,pwd.text);</span><br><span class="line">    &#x2F;&#x2F;调用回原来的逻辑!!</span><br><span class="line">    &#x2F;&#x2F;调用原来的方法!</span><br><span class="line">    old_onNext(self,_cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式相对比较清晰，然后重新运行就好了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过Framework、Dylib注入</p><ul><li>Xcode自动打包Framework进入app包</li><li>macho中load commands里需要有 LC_LOAD_DYLIB字段</li><li>DYLD加载我们创建的Framework</li><li>MethodSwizzle - Runtime中也是重点<ul><li>exchange函数交换SEL和IMP的对应关系<ul><li>这种方案有可能会造成crash。因为没法调用原来的方法。</li></ul></li><li>解决方案：<ul><li>添加方法列表，然后exchange或者replace</li><li>getImp、setImp配合使用</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码注入&quot;&gt;&lt;a href=&quot;#代码注入&quot; class=&quot;headerlink&quot; title=&quot;代码注入&quot;&gt;&lt;/a&gt;代码注入&lt;/h1&gt;&lt;p&gt;我们按照上一章（应用重签名）的逻辑，先把程序跑起来。&lt;/p&gt;
&lt;p&gt;然后再&lt;code&gt;.app&lt;/code&gt;中显示包内容，查
      
    
    </summary>
    
    
      <category term="逆向" scheme="http://liujiaboy.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="应用签名" scheme="http://liujiaboy.github.io/tags/%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
</feed>
