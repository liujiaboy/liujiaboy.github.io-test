<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/15/SoftWare/coderunner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/SoftWare/coderunner/" class="post-title-link" itemprop="url">coderunner使用问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-15 19:01:29 / 修改时间：19:14:44" itemprop="dateCreated datePublished" datetime="2021-09-15T19:01:29+08:00">2021-09-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CodeRunner本身是一个收费软件，功能强大，好处就不说了。在一些破解网站上可以找到破解版的，断网输入对应的激活码就能破解成功。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>每次重新打开，都需要重新破解。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>猜想的是每次打开CodeRunner时都会向其主站发送消息，查看是否激活，这里就是通过直接断开链接的方式来处理。</p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>Mac系统下打开<code>/private/etc/</code>文件，hosts是文本。</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>在hosts文件中，增加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CodeRunner App</span><br><span class="line">127.0.0.1 coderunnerapp.com</span><br></pre></td></tr></table></figure>

<p>这样就可以验证成功了，不需要每次都重新激活。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/" class="post-title-link" itemprop="url">nx-8-logos</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:27:26" itemprop="dateCreated datePublished" datetime="2021-09-13T16:27:26+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/" class="post-title-link" itemprop="url">nx-8-lldb</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:11:20" itemprop="dateCreated datePublished" datetime="2021-09-13T16:11:20+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/" class="post-title-link" itemprop="url">nx-7-hook</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 14:37:29" itemprop="dateCreated datePublished" datetime="2021-09-13T14:37:29+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">github-443解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-19 11:12:52" itemprop="dateCreated datePublished" datetime="2021-06-19T11:12:52+08:00">2021-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 14:06:47" itemprop="dateModified" datetime="2021-06-21T14:06:47+08:00">2021-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/github/" itemprop="url" rel="index"><span itemprop="name">github</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p>在使用github的时候，执行<code>git pull</code>或者<code>git push</code>时，经常会出现以下错误：</p>
<blockquote>
<p>【Failed to connect to github.com port 443: Operation timed out】</p>
</blockquote>
<p>这个时候就一通百度、google发现有解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意啊、这个是不行的</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>这个时候你可能觉得：OK终于解决了。</p>
<p>但是，可能再你下次使用的时候又会出现类似的问题，或者又有新的问题出现。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>打开网站：<a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></p>
<p><img src="step-1.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p>打开网站：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></p>
<p><img src="step-2.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><p>打开网站<a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></p>
<p><img src="step-3.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h2><p>打开系统host，进行编辑，我这里使用的是Mac，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<p><code>sudo</code>命令需要输入密码，之后，把我们上面打开的3个web对应的ip和host绑定，如下图：</p>
<p><img src="step-4.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ip            对应的host    </span><br><span class="line"># Github</span><br><span class="line">140.82.114.4    github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<p>ip以自己打开的那3个web显示的为准。Windows请自行百度如何操作host。</p>
<h2 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h2><p>如果设置了<code>http.proxy</code>和<code>https.proxy</code> http/https代理，需要取消代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h2><p>刷新DNS，如果机型不同，不起作用，请自行查看<a href="https://support.apple.com/zh-cn/HT202516" target="_blank" rel="noopener">还原OS X 中的DNS缓存</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;support.apple.com&#x2F;zh-cn&#x2F;HT202516</span><br></pre></td></tr></table></figure>

<p>到这里就可以正常使用了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">OC原理/oc-4-类的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-18 18:04:13" itemprop="dateCreated datePublished" datetime="2021-06-18T18:04:13+08:00">2021-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象、类对象、元类"><a href="#1-对象、类对象、元类" class="headerlink" title="1. 对象、类对象、元类"></a>1. 对象、类对象、元类</h1><h2 id="1-1-isa指向、superClass指向"><a href="#1-1-isa指向、superClass指向" class="headerlink" title="1.1 isa指向、superClass指向"></a>1.1 isa指向、superClass指向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#x2F;&#x2F;先把这里的协议注释掉，用到的时候再打开</span><br><span class="line">@protocol PersonProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *p_address;</span><br><span class="line"></span><br><span class="line">- (void)p_func1;</span><br><span class="line">+ (void)p_func1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_hobby;</span><br><span class="line">    CGFloat _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic) int age;</span><br><span class="line"></span><br><span class="line">- (void)func1;</span><br><span class="line">- (void)func2;</span><br><span class="line">+ (void)func3;</span><br><span class="line">+ (void)func4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后执行，直接打断点。</span><br><span class="line">Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">Teacher *t &#x3D; [[Teacher alloc] init];</span><br></pre></td></tr></table></figure>

<p>我们根据述代码进行分析，isa指针的指向。</p>
<blockquote>
<p>注意，这里是用的是模拟器</p>
</blockquote>
<h2 id="1-2-实例对象的isa"><a href="#1-2-实例对象的isa" class="headerlink" title="1.2 实例对象的isa"></a>1.2 实例对象的isa</h2><p>首先我们先看Person的实例p的isa指向情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先打印一下p的内存情况</span><br><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x1006460b0&gt;</span><br><span class="line">&#x2F;&#x2F; 输出p指针的情况</span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x1006460b0: 0x011d8001000083f9 0x0000000000000000</span><br><span class="line">0x1006460c0: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) p p 0x011d8001000083f9</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br></pre></td></tr></table></figure>

<p>这里拿到p指针指向的内存情况，我们知道第一块内存区域存放的是isa指针，直接打印的话，发现就是一串数字，啥也看不出来。还记得上一章中object_getClass反向验证isa指向最后的”&amp;”运算吗？<code>0x011d8001000083f9</code>这个值就是isa-&gt;bits，我们用它与<code>ISA_MASK</code>进行&amp;运算。因为这里是用的真机，所以<code>ISA_MASK = 0x00007ffffffffff8</code>，如果是用Mac或者模拟器，根据芯片类型判断是否是ARM64架构还是x86，然后使用对应的值进行换算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; p&#x2F;x输出内存的16进制</span><br><span class="line">(lldb) p&#x2F;x 0x011d8001000083f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $2 &#x3D; 0x00000001000083f8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里po就是Person类</span><br><span class="line">(lldb) po 0x00000001000083f8</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>打印出来是Person。所以isa指向的就是Person类。那我们做一下验证，直接通过<code>object_getClass</code>方法来找一下Person这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x object_getClass(p)</span><br><span class="line">(Class) $12 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>

<p>是不是发现，Person类的内存地址是一样的。如果再实例化一个p1，看p1-&gt;isa指向的和p-&gt;isa指向的是否是同一个Person类的内存地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接使用object_getClass获取类对象。</span><br><span class="line">lldb) p&#x2F;x object_getClass([Person alloc])</span><br><span class="line">(Class) $26 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>
<p>答案是肯定的，Person类在内存中只有一份，也就是说所有的类对象在内存中都只有一份。</p>
<h2 id="1-3-类对象的isa"><a href="#1-3-类对象的isa" class="headerlink" title="1.3 类对象的isa"></a>1.3 类对象的isa</h2><p>接下来，我们继续寻找Person类对象的isa指向情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083f8</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x0000000100645d60 0x0001803000000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 &#x3D; 0x00000001000083d0</span><br><span class="line">(lldb) po 0x00000001000083d0</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>发现Person类对象的isa指向的还是Person，但是这个Person所在的内存地址与Person类对象不一样。</p>
<p>这里就出现了元类的概念（Meta Class）。</p>
<h2 id="1-4-元类的isa"><a href="#1-4-元类的isa" class="headerlink" title="1.4 元类的isa"></a>1.4 元类的isa</h2><p>我们继续寻找元类的isa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0x00000001000083d0是Person元类所在的内存</span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083d0</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x0000000100714d10 0x0002e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $9 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到NSObject的地址继续x&#x2F;4gx</span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a0f0</span><br><span class="line">0x10036a0f0: 0x000000010036a0f0 0x000000010036a140</span><br><span class="line">0x10036a100: 0x00000001007877b0 0x0003e03100000007</span><br></pre></td></tr></table></figure>

<p>使用相同的方法找到元类的<code>isa</code>指向的是<code>NSObject</code>，这个<code>NSObject</code>是类对象吗？</p>
<p>对<code>NSObject</code>继续<code>x/4gx</code>发现<code>isa</code>锁指向的内存地址是一样的。</p>
<p>我们通过<code>object_getClass([[NSObject alloc] init])</code>来看看<code>NSObject</code>类对象的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取NSObject类的地址，与p&#x2F;x NSObject.class效果一致</span><br><span class="line">(lldb) p&#x2F;x object_getClass([NSObject alloc])</span><br><span class="line">(Class) $13 &#x3D; 0x000000010036a140 NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a140</span><br><span class="line">0x10036a140: 0x000000010036a0f0 0x0000000000000000</span><br><span class="line">0x10036a150: 0x0000000100786740 0x0002801000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从这里开始，就已经跟上面的内存地址重复了</span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $14 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>到这里，是不是看明白了点啥？<code>NSObject</code>类对象也有指向<code>NSObject</code>的元类，<code>Person</code>的元类的<code>isa</code>指向的是<code>NSObject</code>的元类。</p>
<h3 id="1-5-使用相同的办法查看Teacher的isa"><a href="#1-5-使用相同的办法查看Teacher的isa" class="headerlink" title="1.5 使用相同的办法查看Teacher的isa"></a>1.5 使用相同的办法查看Teacher的isa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里使用简单的方式，直接使用Teacher类</span><br><span class="line">(lldb) x&#x2F;4gx Teacher.class</span><br><span class="line">0x100008380: 0x00000001000083a8 0x00000001000083f8</span><br><span class="line">0x100008390: 0x0000000100362370 0x0000803000000000</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083a8 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $18 &#x3D; 0x00000001000083a8</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000001000083a8</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083a8</span><br><span class="line">0x1000083a8: 0x000000010036a0f0 0x00000001000083d0</span><br><span class="line">0x1000083b8: 0x0000000101138140 0x0001e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $20 &#x3D; 0x000000010036a0f0</span><br><span class="line">&#x2F;&#x2F; 这里又指向了NSObject</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>看到这里应该发现了点东西吧。实例对象的isa-&gt;类对象的isa-&gt;NSObject的isa，中间类对象与继承没有一丢丢关系。</p>
<h3 id="1-6-类的继承链"><a href="#1-6-类的继承链" class="headerlink" title="1.6 类的继承链"></a>1.6 类的继承链</h3><p>上面我们查看了isa的走向，接下来看一下继承链。首先看一下类的继承关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void testSuperClass(void)&#123;</span><br><span class="line">    Teacher *t &#x3D; [Teacher alloc];</span><br><span class="line">    Person  *p &#x3D; [Person alloc];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Teacher.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Person.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(NSObject.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里输出一下对应类的<code>superclass</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">NSObject</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>

<p>从打印出来的信息可以看到:</p>
<ul>
<li>Teacher   -&gt; superclass = Person</li>
<li>Person    -&gt; superClass = NSObject</li>
<li>NSObject  -&gt; superClass = null</li>
</ul>
<h3 id="1-7-元类的继承链"><a href="#1-7-元类的继承链" class="headerlink" title="1.7 元类的继承链"></a>1.7 元类的继承链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void testNSObject(void) &#123;</span><br><span class="line">    &#x2F;&#x2F; NSObject实例对象</span><br><span class="line">    NSObject *object1 &#x3D; [NSObject alloc];</span><br><span class="line">    &#x2F;&#x2F; NSObject类</span><br><span class="line">    Class cls &#x3D; object_getClass(object1);</span><br><span class="line">    &#x2F;&#x2F; NSObject元类</span><br><span class="line">    Class metaClass &#x3D; object_getClass(cls);</span><br><span class="line">    &#x2F;&#x2F; NSObject根元类</span><br><span class="line">    Class rootMetaClass &#x3D; object_getClass(metaClass);</span><br><span class="line">    &#x2F;&#x2F; NSObject根根元类</span><br><span class="line">    Class rootRootMetaClass &#x3D; object_getClass(rootMetaClass);</span><br><span class="line">    NSLog(@&quot;\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类&quot;,object1,cls,metaClass,rootMetaClass,rootRootMetaClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Person元类</span><br><span class="line">    Class pMetaClass &#x3D; object_getClass(Person.class);</span><br><span class="line">    Class psuperClass &#x3D; class_getSuperclass(pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,pMetaClass,pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,psuperClass,psuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Teacher -&gt; Person -&gt; NSObject</span><br><span class="line">    &#x2F;&#x2F; 元类也有一条继承链</span><br><span class="line">    Class tMetaClass &#x3D; object_getClass(Teacher.class);</span><br><span class="line">    Class tsuperClass &#x3D; class_getSuperclass(tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tMetaClass,tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tsuperClass,tsuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; NSObject 根类特殊情况</span><br><span class="line">    Class nsuperClass &#x3D; class_getSuperclass(NSObject.class);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,nsuperClass,nsuperClass);</span><br><span class="line">    &#x2F;&#x2F; 根元类 -&gt; NSObject</span><br><span class="line">    Class rnsuperClass &#x3D; class_getSuperclass(metaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,rnsuperClass,rnsuperClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下输出结果：</p>
<ol>
<li><p>首先输出的NSObject的isa走位。NSObject实例对象 -&gt; 类 -&gt; 元类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x10124ba40 实例对象</span><br><span class="line">0x10036a140 类</span><br><span class="line">0x10036a0f0 元类</span><br><span class="line">0x10036a0f0 根元类</span><br><span class="line">0x10036a0f0 根根元类</span><br></pre></td></tr></table></figure>

<p> 从这里的输出结果可以进一步判断出NSObject类对象的元类指向它自己。</p>
</li>
<li><p>Person类对象的元类 -&gt; super</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Person类对象的元类</span><br><span class="line">Person - 0x100008498</span><br><span class="line">&#x2F;&#x2F; Person类对象的元类 -&gt; super</span><br><span class="line">NSObject - 0x10036a0f0</span><br></pre></td></tr></table></figure>

<p> 从地址的打印信息可以看出来，person类的元类的super指向的是NSObject类的元类。</p>
</li>
<li><p>Teacher元类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Teacher类对象的元类</span><br><span class="line">Teacher - 0x100008470</span><br><span class="line">&#x2F;&#x2F; Teacher类对象的元类 -&gt; super</span><br><span class="line">Person - 0x100008498</span><br></pre></td></tr></table></figure>

<p> 从这里可以看出来，Teacher元类的super指向的Person的元类，地址信息都是相同的。</p>
</li>
</ol>
<p>从上面的流程可以看到，类的继承关系和对应元类的继承关系是相对应的。可以用一张图完美的诠释isa的走向和super的指向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="isa_metaclass.png" alt=""></p>
<ul>
<li>每个实例对象的isa指针指向与之对应的类对象(Class)。</li>
<li>每个类对象(Class)都有一个isa指针指向一个唯一的元类(Meta Class)。</li>
<li>每一个元类(Meta Class)的isa指针都指向最上层的元类(Meta Class)（图中的NSObject的Meta Class）。最上层的元类(Meta Class)的isa指针指向自己，形成一个回路。</li>
<li>每一个元类(Meta Class)的Super Class指向它原本Class的Super Class的Meta Class。最上层的Meta Class的Super Class指向NSObject Class本身。</li>
<li>最上层的NSObject Class的Super Class指向nil。</li>
<li>只有Class才有继承关系，实例对象与实例对象不存在继承关系。</li>
<li>每一个类对象(Class)在内存中都只有一份。</li>
</ul>
<h1 id="2-通过源码分析"><a href="#2-通过源码分析" class="headerlink" title="2. 通过源码分析"></a>2. 通过源码分析</h1><p>接下来我们从objc的源码上分析这些都是什么东西。</p>
<h2 id="2-1-实例对象-id（Instance）"><a href="#2-1-实例对象-id（Instance）" class="headerlink" title="2.1 实例对象 id（Instance）"></a>2.1 实例对象 id（Instance）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>id 这个struct的定义本身就带了 个 ＊, 所以我们在使用其他NSObject类型的实例时需要在前加上 ＊, 使 id 时却不用 。</p>
<p>什么是objc_object?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class. </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体, 在这个struct中有 个 isa 指针,指向它的类别 Class。 </p>
<h2 id="2-2-类对象-Class"><a href="#2-2-类对象-Class" class="headerlink" title="2.2 类对象 Class"></a>2.2 类对象 Class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>Class的本质就是一个<code>objc_class</code>的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意，这个源码是被简化之后的。</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    Class getSuperclass() const &#123;</span><br><span class="line">        return superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setSuperclass(Class newSuperclass) &#123;</span><br><span class="line">        superclass &#x3D; newSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 用这个是无法获取rw_t，只能通过内存偏移获取bits，然后再获取rw_t</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isRootClass() &#123;</span><br><span class="line">        return getSuperclass() &#x3D;&#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isRootMetaclass() &#123;</span><br><span class="line">        return ISA() &#x3D;&#x3D; (Class)this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体，大家可能会觉得不对，这个源码是错的，不是我们经常看到的，里头没有那些我们常说的变量，methodLists、ivars等等。<br>大家看仔细了哦，下面这个实现基本都是大家常看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;  </span><br><span class="line">    ...</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE</span><br></pre></td></tr></table></figure>
<p>里头确实有ivars、methodLists等，但是这个是<code>OBJC2_UNAVAILABLE</code>（我们目前使用的Objective-C的版本是2.0版本）。其内部确实有这些东西的，我们一步步去探究。</p>
<p>继续回到上面的结构体，发现ISA变量被注释掉了，其实也没有影响的，因为<code>objc_class</code> 继承自 <code>objc_object</code>（内部有isa变量）。那我们的属性、方法是存放在哪了呢？</p>
<p>通过查看源码，我们看到有这么一个属性<code>class_data_bits_t bits;</code>，这个东西里可能存放着我们需要的东西。稍后我们做验证。</p>
<h2 id="2-3-元类-Meta-Class"><a href="#2-3-元类-Meta-Class" class="headerlink" title="2.3 元类 Meta Class"></a>2.3 元类 Meta Class</h2><p>OC中一切皆为对象<br>Class在设计中本身也是一个对象,也有superclass。而这个Class对应的类我们叫“元类”（Meta Class）。也就是说Class中有一个isa指向的是Meta Class。</p>
<h1 id="3-验证属性、方法、协议存在的位置"><a href="#3-验证属性、方法、协议存在的位置" class="headerlink" title="3 验证属性、方法、协议存在的位置"></a>3 验证属性、方法、协议存在的位置</h1><h2 id="3-1-验证之前的准备-源码"><a href="#3-1-验证之前的准备-源码" class="headerlink" title="3.1 验证之前的准备 - 源码"></a>3.1 验证之前的准备 - 源码</h2><p>在2.2小结我们说了属性、方法、等可能存在于<code>class_data_bits_t</code>这个结构体内部，我们查看它的源码：</p>
<h3 id="3-1-1-class-data-bits-t"><a href="#3-1-1-class-data-bits-t" class="headerlink" title="3.1.1 class_data_bits_t"></a>3.1.1 class_data_bits_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">            return maybe_rw-&gt;ro();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">            return (class_ro_t *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在public的方法中有<code>class_rw_t* data()</code>这个方法，我们进一步探索：</p>
<h3 id="3-1-2-class-rw-t"><a href="#3-1-2-class-rw-t" class="headerlink" title="3.1.2 class_rw_t"></a>3.1.2 class_rw_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t witness;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint16_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实如我们所说的，这里确实存在着我们想要的东西：methods()、properties()、protocols()等。</p>
<p>那我们该怎么获取到这些数据，来证明这些就是我们想要的东西呢？</p>
<h3 id="3-1-3-内存偏移"><a href="#3-1-3-内存偏移" class="headerlink" title="3.1.3 内存偏移"></a>3.1.3 内存偏移</h3><p>我们知道在c语言中，一个数组，获取数组中的某个元素的值有多种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">printf(&quot;index 1 &#x3D; %d - %d&quot;, a[1], *(a+1));</span><br></pre></td></tr></table></figure>

<p>比如上面的代码，我们可以直接输出某个元素的下标，也可以通过内存地址来偏移进行读取，同样，我们也可以采取地址偏移来获取<code>objc_class-&gt;bits</code>的值。</p>
<p>需要偏移多少呢？</p>
<p>第一个变量是Class，这是一个结构体，内部有一个isa指针，所以这是8个字节。<br>第二个变量是cache_t，我们进源码看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">private:</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;    &#x2F;&#x2F; 8</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask;      &#x2F;&#x2F; 4</span><br><span class="line">#if __LP64__</span><br><span class="line">            uint16_t                   _flags;          &#x2F;&#x2F; 2</span><br><span class="line">#endif</span><br><span class="line">            uint16_t                   _occupied;       &#x2F;&#x2F; 2</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache; &#x2F;&#x2F; 8</span><br><span class="line">    &#125;;</span><br><span class="line">...   </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实这些就能算出来我们需要多少字节，我已经标好了。静态变量和方法是没有算在结构体内部的哈，而且cache_t内部有一个共用体，所以其所占用的空间一共是8，再加上<code>_bucketsAndMaybeMask</code>变量一共是16个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class ISA;              &#x2F;&#x2F; 8</span><br><span class="line">Class superclass;       &#x2F;&#x2F; 8</span><br><span class="line">cache_t cache;          &#x2F;&#x2F; 16</span><br><span class="line">class_data_bits_t bits;</span><br></pre></td></tr></table></figure>
<p>所以8+8+16 = 32个字节。</p>
<p>也就是我们获取到的<code>objc_class</code>的isa指针，然后偏移32个字节，也就是<code>0x20</code>。当然也可以直接通过lldb输出<code>sizeOf(cache_t)</code>来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $4 &#x3D; 16</span><br></pre></td></tr></table></figure>

<p>我们做一下验证，看看属性在哪。其实需要注意的一点是，我们要获取的是类对象，从类对象中查看我们的变量、方法和协议等，而不是从实例对象中获取，因为实例对象是已经在内存中了，比如属性已经有了具体的值了。</p>
<h3 id="3-1-4-method-array-t"><a href="#3-1-4-method-array-t" class="headerlink" title="3.1.4 method_array_t"></a>3.1.4 method_array_t</h3><p>我们继续跟踪源码，查看<code>method_array_t</code>是个啥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_array_t() : Super() &#123; &#125;</span><br><span class="line">    method_array_t(method_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *beginCategoryMethodLists() const &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *endCategoryMethodLists(Class cls) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们猜测我们想要的数据是在<code>method_list_t</code>中，而<code>method</code>就是我们的每一个的方法等结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    struct big &#123;</span><br><span class="line">        SEL name;</span><br><span class="line">        const char *types;</span><br><span class="line">        MethodListIMP imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">public:</span><br><span class="line">    big &amp;big() const &#123;</span><br><span class="line">        ASSERT(!isSmall());</span><br><span class="line">        return *(struct big *)this;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-1-5-property-array-t"><a href="#3-1-5-property-array-t" class="headerlink" title="3.1.5 property_array_t"></a>3.1.5 property_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class property_array_t : </span><br><span class="line">    public list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;property_t, property_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    property_array_t() : Super() &#123; &#125;</span><br><span class="line">    property_array_t(property_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同methods方法，我们看一下property_t</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-protocol-array-t"><a href="#3-1-6-protocol-array-t" class="headerlink" title="3.1.6 protocol_array_t"></a>3.1.6 protocol_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class protocol_array_t : </span><br><span class="line">    public list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    protocol_array_t() : Super() &#123; &#125;</span><br><span class="line">    protocol_array_t(protocol_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>这三个分别对应<code>methods()、properties()、protocols()</code>方法，里头也一个共同点就是<code>protocol_array_t</code>。那我们重点看一下list_array_tt的结构。</p>
<h3 id="3-1-7-list-array-tt"><a href="#3-1-7-list-array-tt" class="headerlink" title="3.1.7 list_array_tt"></a>3.1.7 list_array_tt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class list_array_tt &#123;</span><br><span class="line">    struct array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        Ptr&lt;List&gt; lists[0];</span><br><span class="line"></span><br><span class="line">        static size_t byteSize(uint32_t count) &#123;</span><br><span class="line">            return sizeof(array_t) + count*sizeof(lists[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t byteSize() &#123;</span><br><span class="line">            return byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">    &#x2F;&#x2F; 这是一个迭代器</span><br><span class="line">    class iterator &#123;</span><br><span class="line">        const Ptr&lt;List&gt; *lists;</span><br><span class="line">        const Ptr&lt;List&gt; *listsEnd;</span><br><span class="line">        typename List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 迭代器相关的方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    union &#123;</span><br><span class="line">        Ptr&lt;List&gt; list;</span><br><span class="line">        uintptr_t arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>list_array_tt</code>结构体大概的可以看出来，<code>list_array_tt</code>只是一个list的封装。以<code>property_array_t</code>为例：</p>
<p><code>list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</code>就是一个存放了<code>property_t</code>类型的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    Ptr&lt;List&gt; list;</span><br><span class="line">    uintptr_t arrayAndFlag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>union</code>共用体才是一个list_array_tt对外暴露的真是结构，一会我们通过lldb进行验证。</p>
<h1 id="4-lldb-验证属性存放的位置"><a href="#4-lldb-验证属性存放的位置" class="headerlink" title="4 lldb 验证属性存放的位置"></a>4 lldb 验证属性存放的位置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line">0x100008418: 0x00000001012042e4 0x00000001000b9970</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过指针偏移0x20，也就是0x1000083f8+0x20，加上强制转换</span><br><span class="line">(lldb) p (class_data_bits_t *)0x100008418</span><br><span class="line">(class_data_bits_t *) $1 &#x3D; 0x0000000100008418</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到变量bits之后，通过class_data_bits_t -&gt; data()函数获取rw_t</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 &#x3D; 0x00000001012042e0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 看一下class_rw_t都有哪些值</span><br><span class="line">(lldb) p *$2</span><br><span class="line">(class_rw_t) $4 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2156396544</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4295000480</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; Teacher</span><br><span class="line">  nextSiblingClass &#x3D; NSBinder</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果有Subclass，则会有firstSubclass&#x3D;Teacher，如果没有子类则是nil</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们在class_rw_t中已经查看过源码，可以通过properties()获取属性列表</span><br><span class="line">(lldb) p $2-&gt;properties()</span><br><span class="line">(const property_array_t) $5 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008320</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000864</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合我们上面分析的结果，<code>property_array_t</code>输出的数据与上方<code>list_array_tt</code>内部的<code>union</code>共用体的结构是一直的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取属性列表</span><br><span class="line">(lldb) p $5.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $6 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008320</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">(lldb) p $6.ptr</span><br><span class="line">(property_list_t *const) $7 &#x3D; 0x0000000100008320</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; $8也就是我们的ptr内存储的列表</span><br></pre></td></tr></table></figure>

<p>但是<code>entsize_list_tt</code>又是什么类型？我们又该通过那种方式来获取我们最后想要的property呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt;&#x3D; count);</span><br><span class="line">        return *PointerModifier::modify(*this, (Element *)((uint8_t *)this + sizeof(*this) + i*entsize()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 注意。这里有一个 【&amp;】符号，调用getOrEnd，返回的是一个指针，进行转换</span><br><span class="line">    Element&amp; get(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt; count);</span><br><span class="line">        return getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>entsize_list_tt</code>内部有get方法，来获取其中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $8.get(0)</span><br><span class="line">(property_t) $9 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $8.get(1)</span><br><span class="line">(property_t) $10 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) </span><br><span class="line">(lldb) p $8.get(2)</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br></pre></td></tr></table></figure>

<p>到这里，我们就输出了我们定义的2个属性，但是变量却没有在这里提现出来。我们继续看ivar存放在哪。</p>
<h1 id="5-lldb-成员变量"><a href="#5-lldb-成员变量" class="headerlink" title="5. lldb 成员变量"></a>5. lldb 成员变量</h1><p>从上面我们知道属性都存放在<code>class_rw_t</code>中，在查看<code>class_data_bits_t</code>源码的时候，也有看到<code>class_ro_t</code>。那ivar会不会就在这里呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class_data_bits_t 内部</span><br><span class="line"></span><br><span class="line">const class_ro_t *safe_ro() const &#123;</span><br><span class="line">    class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">    if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">        return maybe_rw-&gt;ro();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">        return (class_ro_t *)maybe_rw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    union &#123;</span><br><span class="line">        const uint8_t * ivarLayout;</span><br><span class="line">        Class nonMetaclass;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;const char *&gt; name;</span><br><span class="line">    &#x2F;&#x2F; With ptrauth, this is signed if it points to a small list, but</span><br><span class="line">    &#x2F;&#x2F; may be unsigned if it points to a big list.</span><br><span class="line">    void *baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    &#x2F;&#x2F; 这里存放的是ivars</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了获取property的经验，这里就方便多了，我们按照相同的方式来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $1 (class_data_bits_t *) </span><br><span class="line">(lldb) p $1-&gt;safe_ro()</span><br><span class="line">(const class_ro_t *) $11 &#x3D; 0x00000001000081a0</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(const class_ro_t) $12 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 0</span><br><span class="line">  instanceStart &#x3D; 8</span><br><span class="line">  instanceSize &#x3D; 40</span><br><span class="line">  reserved &#x3D; 0</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    ivarLayout &#x3D; 0x0000000000000000</span><br><span class="line">    nonMetaclass &#x3D; nil</span><br><span class="line">  &#125;</span><br><span class="line">  name &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;const char *&gt; &#x3D; &quot;Person&quot; &#123;</span><br><span class="line">      Value &#x3D; 0x0000000100003edc &quot;Person&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList &#x3D; 0x00000001000081e8</span><br><span class="line">  baseProtocols &#x3D; 0x0000000000000000</span><br><span class="line">  ivars &#x3D; 0x0000000100008298</span><br><span class="line">  weakIvarLayout &#x3D; 0x0000000000000000</span><br><span class="line">  baseProperties &#x3D; 0x0000000100008320</span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE &#x3D; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从打印中的内容可以大致的猜测ivar应该存放在ivars。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $11.ivars</span><br><span class="line">(const ivar_list_t *const) $13 &#x3D; 0x0000000100008298</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $11-&gt;ivars</span><br><span class="line">(lldb) p $11-&gt;ivars</span><br><span class="line">(const ivar_list_t *const) $14 &#x3D; 0x0000000100008298</span><br><span class="line">(lldb) p *$14</span><br><span class="line">(const ivar_list_t) $15 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;ivar_t, ivar_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 32, count &#x3D; 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与property list是相同的结构</span><br><span class="line">(lldb) p $15.get(0)</span><br><span class="line">(ivar_t) $16 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008360</span><br><span class="line">  name &#x3D; 0x0000000100003f06 &quot;_hobby&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(1)</span><br><span class="line">(ivar_t) $17 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008368</span><br><span class="line">  name &#x3D; 0x0000000100003f0d &quot;_height&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f6f &quot;d&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(2)</span><br><span class="line">(ivar_t) $18 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008370</span><br><span class="line">  name &#x3D; 0x0000000100003f15 &quot;_age&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f71 &quot;i&quot;</span><br><span class="line">  alignment_raw &#x3D; 2</span><br><span class="line">  size &#x3D; 4</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(3)</span><br><span class="line">(ivar_t) $19 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008378</span><br><span class="line">  name &#x3D; 0x0000000100003f1a &quot;_name&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>到这里，我们也获取到了变量的位置，也说明了定义的属性会默认生成带下划线的同名变量。</p>
<p>接下来就是方法了。</p>
<h1 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $20 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x00000001000081e8</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与属性一致</span><br><span class="line">(lldb) p $20.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $21 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x00000001000081e8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $21.ptr</span><br><span class="line">(method_list_t *const) $22 &#x3D; 0x00000001000081e8</span><br><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $23.get(0)</span><br><span class="line">(method_t) $24 &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照属性的方式继续输出，结果<code>$23.get(0)</code>输出的确实空内容。</p>
<p>在说method_t时，结构体内部有<code>big()</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $23.get(0).big()</span><br><span class="line">(method_t::big) $26 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func1&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c90 (AL-Objc&#96;-[Person func1])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(1).big()</span><br><span class="line">(method_t::big) $27 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func2&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cc0 (AL-Objc&#96;-[Person func2])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(2).big()</span><br><span class="line">(method_t::big) $28 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;name&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f53 &quot;@16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cf0 (AL-Objc&#96;-[Person name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(3).big()</span><br><span class="line">(method_t::big) $29 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setName:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f73 &quot;v24@0:8@16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d20 (AL-Objc&#96;-[Person setName:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(4).big()</span><br><span class="line">(method_t::big) $30 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;age&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f7e &quot;i16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d50 (AL-Objc&#96;-[Person age])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(5).big()</span><br><span class="line">(method_t::big) $31 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setAge:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f86 &quot;v20@0:8i16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d70 (AL-Objc&#96;-[Person setAge:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(6).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>我们在类中声明的方法都在<code>method_list_t</code>中，这里有我们自己声明的方法，还有属性自动生成的set和get方法。</p>
<p>发现这里并没有我们的类方法。因为类方法在元类里。</p>
<h1 id="7-类方法"><a href="#7-类方法" class="headerlink" title="7. 类方法"></a>7. 类方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取元类</span><br><span class="line">(lldb) p 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $33 &#x3D; 4295001040</span><br><span class="line">(lldb) po $33</span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;6gx $33</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x00000001006959d0 0x0002e03100000003</span><br><span class="line">0x1000083f0: 0x0000000101204304 0x00000001000083d0</span><br><span class="line">&#x2F;&#x2F; 获取元类的bits</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000083f0</span><br><span class="line">(class_data_bits_t *) $34 &#x3D; 0x00000001000083f0</span><br><span class="line">(lldb) p $34-&gt;data()</span><br><span class="line">(class_rw_t *) $35 &#x3D; 0x0000000101204300</span><br><span class="line">(lldb) p *$35</span><br><span class="line">(class_rw_t) $36 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2684878849</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4302330705</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; 0x00000001000083a8</span><br><span class="line">  nextSiblingClass &#x3D; 0x00007fff883ac410</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $35-&gt;methods()</span><br><span class="line">(const method_array_t) $37 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008168</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000424</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $37.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $38 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008168</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $38.ptr</span><br><span class="line">(method_list_t *const) $39 &#x3D; 0x0000000100008168</span><br><span class="line">(lldb) p *$39</span><br><span class="line">(method_list_t) $40 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; count &#x3D; 2告诉我们有2个</span><br><span class="line"></span><br><span class="line">(lldb) p $40.get(0).big()</span><br><span class="line">(method_t::big) $41 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func3&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c00 (AL-Objc&#96;+[Person func3])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(1).big()</span><br><span class="line">(method_t::big) $42 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func4&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c30 (AL-Objc&#96;+[Person func4])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(2).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>这里是获取类方法所在的位置。</p>
<h1 id="8-协议"><a href="#8-协议" class="headerlink" title="8 协议"></a>8 协议</h1><p>属性、变量、方法都已经有所了解，接下来看一下协议。把我们一开始注释的协议打开，重新运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000088d0: 0x00000001000088a8 0x000000010036a140</span><br><span class="line">0x1000088e0: 0x0000000100362370 0x0000803400000000</span><br><span class="line">0x1000088f0: 0x0000000100604204 0x00000001000b9970</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000088f0</span><br><span class="line">(class_data_bits_t *) $4 &#x3D; 0x00000001000088f0</span><br><span class="line">(lldb) p $4-&gt;data()</span><br><span class="line">(class_rw_t *) $5 &#x3D; 0x0000000100604200</span><br><span class="line">(lldb) p $5-&gt;protocols()</span><br><span class="line">(const protocol_array_t) $6 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008560</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001440</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $6.list</span><br><span class="line">(const RawPtr&lt;protocol_list_t&gt;) $7 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008560</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $7.ptr</span><br><span class="line">(protocol_list_t *const) $8 &#x3D; 0x0000000100008560</span><br><span class="line">(lldb) p *$8</span><br><span class="line">(protocol_list_t) $9 &#x3D; (count &#x3D; 1, list &#x3D; protocol_ref_t [] @ 0x00007ff5f7e1e9f8)</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>到此时，就不知道怎么处理，我们看一下<code>protocol_list_t</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    &#x2F;&#x2F; count is pointer-sized by accident.</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0]; &#x2F;&#x2F; variable-size</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是其内部的主要结构。我们用<code>list[0]</code>打印一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $9.list[0]</span><br><span class="line">(protocol_ref_t) $11 &#x3D; 4295002464</span><br></pre></td></tr></table></figure>

<p>上面我们已经说过<code>protocol_ref_t</code>只是一个定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>接下来强转一下，看是否可以转成<code>protocol_t *</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (protocol_t *)$11</span><br><span class="line">(protocol_t *) $12 &#x3D; 0x0000000100008960</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们查看protocol_t内部的结构有demangledName()方法.</span><br><span class="line">(lldb) p $12-&gt;demangledName()</span><br><span class="line">(const char *) $13 &#x3D; 0x0000000100003b51 &quot;PersonProtocol&quot;</span><br></pre></td></tr></table></figure>

<p>到这里呢，协议存放的位置也找到了。</p>
<h1 id="9-补充添加协议之后"><a href="#9-补充添加协议之后" class="headerlink" title="9. 补充添加协议之后"></a>9. 补充添加协议之后</h1><h2 id="9-1-多了4个属性"><a href="#9-1-多了4个属性" class="headerlink" title="9.1 多了4个属性"></a>9.1 多了4个属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $5-&gt;properties()</span><br><span class="line">(const property_array_t) $15 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008710</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001872</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $16 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008710</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $16.ptr</span><br><span class="line">(property_list_t *const) $17 &#x3D; 0x0000000100008710</span><br><span class="line">(lldb) p *$17</span><br><span class="line">(property_list_t) $18 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加协议之后，又返回去重新打印了一下属性列表，发现这里变成了7个。明明之前只有2个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前打印的数据</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上协议中定义的一个，加起来也才3个，为什么会变成7个？这7个又是哪个属性？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $18.get(0)</span><br><span class="line">(property_t) $19 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $18.get(1)</span><br><span class="line">(property_t) $20 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) p $18.get(2)</span><br><span class="line">(property_t) $21 &#x3D; (name &#x3D; &quot;p_address&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N&quot;)</span><br><span class="line">(lldb) p $18.get(3)</span><br><span class="line">(property_t) $22 &#x3D; (name &#x3D; &quot;hash&quot;, attributes &#x3D; &quot;TQ,R&quot;)</span><br><span class="line">(lldb) p $18.get(4)</span><br><span class="line">(property_t) $23 &#x3D; (name &#x3D; &quot;superclass&quot;, attributes &#x3D; &quot;T#,R&quot;)</span><br><span class="line">(lldb) p $18.get(5)</span><br><span class="line">(property_t) $24 &#x3D; (name &#x3D; &quot;description&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br><span class="line">(lldb) p $18.get(6)</span><br><span class="line">(property_t) $25 &#x3D; (name &#x3D; &quot;debugDescription&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br></pre></td></tr></table></figure>

<p>发现，添加了协议之后，会增加<code>hash、superclass、description、debugDescription</code>4个属性。是因为我们定义的协议都遵循<code>&lt;NSObject&gt;</code>协议，在<code>&lt;NSObject&gt;</code>协议内部有这4个属性的声明。</p>
<h2 id="9-2-方法找不到了"><a href="#9-2-方法找不到了" class="headerlink" title="9.2 方法找不到了"></a>9.2 方法找不到了</h2><p>我们按照上面获取方法等顺序，结果在最后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $3 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100722d01</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4302449921</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $4 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100722d01</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $4.ptr</span><br><span class="line">(method_list_t *const) $5 &#x3D; 0x0000000100722d01</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 0, count &#x3D; 2281701376)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在第6节的时候，输出过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共有7个，但是这里怎么变成了这么大的一个值？？？<br>有知道的大佬，欢迎指导，谢谢。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>添加协议之后<ul>
<li>多了4个属性</li>
<li>方法找不到了，待补充</li>
</ul>
</li>
</ul>
<p>这里我们以name的get方法为例子，说明一下这都是什么意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;</span><br></pre></td></tr></table></figure>

<p><img src="function_table.png" alt=""></p>
<blockquote>
<p>@16@0:8</p>
</blockquote>
<ul>
<li>‘@’：第一个@表示返回值，对象</li>
<li>‘16’：16个字节</li>
<li>‘@’：第二个@表示对象类型(id)</li>
<li>‘0’：我们知道@表示对象，0表示从0开始，占8个字节</li>
<li>‘:’：SEL，方法明</li>
<li>‘8’：表示从8开始，占8个字节，满足一共16个字节</li>
</ul>
<p>sel 和 imp<br>sel：方法名<br>imp：方法实现。函数指针地址</p>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>sel、imp的区别</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/" class="post-title-link" itemprop="url">nx-6-dyld</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 11:45:14" itemprop="dateCreated datePublished" datetime="2021-06-04T11:45:14+08:00">2021-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/" class="post-title-link" itemprop="url">MachO</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 11:11:58" itemprop="dateCreated datePublished" datetime="2021-06-02T11:11:58+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 11:44:46" itemprop="dateModified" datetime="2021-06-04T11:44:46+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h1><p>Mach-O其实是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式， 类似于windows上的PE格式 (Portable Executable )， linux上的elf格式 (Executable and Linking Format)。</p>
<p>Mach-O是一种用于可执行文件、目标代码、动态库的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性。</p>
<h1 id="MachO格式的常见文件"><a href="#MachO格式的常见文件" class="headerlink" title="MachO格式的常见文件"></a>MachO格式的常见文件</h1><ul>
<li>目标文件.o </li>
<li>库文件<ul>
<li>.a</li>
<li>.dylib</li>
<li>.Framework</li>
</ul>
</li>
<li>可执行文件<ul>
<li>dyld</li>
<li>.dsym</li>
</ul>
</li>
</ul>
<p>关于静态库、动态库，这里有一篇文章，写的很好。<br><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a></p>
<h2 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h2><p>可以通过clang命令把对应的文件编译成mach-o文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -c test.c</span><br></pre></td></tr></table></figure>

<p>就会出现一个test.o的文件，这个就是mach-o类型的文件。</p>
<p>可以通过file命令查看文件类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ file [文件路径]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比如：</span><br><span class="line">$ file test.o</span><br><span class="line">test.o: Mach-O 64-bit object x86_64</span><br></pre></td></tr></table></figure>

<p>说明test.o文件是Mach-O，64位的object，适用于x86架构，64位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译为可执行文件</span><br><span class="line">$ clang text.o</span><br></pre></td></tr></table></figure>

<p>这个命令会吧test.o文件转换为可执行文件，类型为.out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.out</span><br><span class="line">test.out: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure>

<p>text.out是一个可执行文件。</p>
<h2 id="clang编译多个文件"><a href="#clang编译多个文件" class="headerlink" title="clang编译多个文件"></a>clang编译多个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo test.c test1.c</span><br></pre></td></tr></table></figure>

<p>就是把<code>test.c</code>和<code>test1.c</code>两个文件合并为一个可执行文件demo</p>
<p>如果更改链接到顺序，则生成的可执行文件是不同的，md5值不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo1 test1.c test.c</span><br></pre></td></tr></table></figure>

<p>可以查看一下两个文件的md5值，是不同的，命令为<code>md5 [filename]</code>。</p>
<p>也可以通过<code>objdump</code>命令查看内容是否一样，这个命令类似于<code>MachOView</code>工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ objdump --macho -d [可执行文件file name]</span><br><span class="line">&#x2F;&#x2F; 查看demo可执行文件</span><br><span class="line">$ objdump --macho -d demo</span><br></pre></td></tr></table></figure>

<h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><p>dyld（the dynamic link editor）是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。</p>
<h2 id="dsym文件"><a href="#dsym文件" class="headerlink" title="dsym文件"></a>dsym文件</h2><p>当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。</p>
<p>在release下，编译之后查看dsym文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file file HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O dSYM companion file arm_v7] [arm64:Mach-O 64-bit dSYM companion file arm64]</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture armv7):	Mach-O dSYM companion file arm_v7</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture arm64):	Mach-O 64-bit dSYM companion file arm64</span><br></pre></td></tr></table></figure>

<p>这里出现了<code>universal binary</code>。这是个啥？就是通用二进制文件</p>
<h2 id="通用二进制文件"><a href="#通用二进制文件" class="headerlink" title="通用二进制文件"></a>通用二进制文件</h2><p>mac系统所支持的cpu及硬件平台发生了很大的变化，为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）,又称胖二进制（Fat Binary）。</p>
<ul>
<li>苹果公司提出的一种程序代码。能同时适用多种架构的二进制文件</li>
<li>同一个程序包中同时为多种架构提供最理想的性能。</li>
<li>因为需要储存多种代码，通用二进制应用程序通常比单一平台二进制的程序要大。但是由于两种架构有共通的非执行资源(代码以外的，图片等)，所以并不会达到单一版本的两倍之多。</li>
<li>而且由于执行中只调用一部分代码，运行起来也不需要额外的内存。</li>
</ul>
<p>在xcode中可以更改Mach-O Type：</p>
<p><img src="macho_xcode.jpg" alt=""></p>
<p>对于现在的Xcode来说，iOS11以上通过真机生成的可执行文件都是arm64架构，是单一架构。如果把最低版本修改为iOS10，重新真机编译，发现生成的可执行文件就是两种架构<code>armv7 + arm64</code>。</p>
<p>接下来，随便找个工程，release下编译，然后查看<code>HookDemo.app -&gt; HookDemo</code>可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file HookDemo</span><br><span class="line">HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O executable arm_v7] [arm64:Mach-O 64-bit executable arm64]</span><br><span class="line">HookDemo (for architecture armv7):	Mach-O executable arm_v7</span><br><span class="line">HookDemo (for architecture arm64):	Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>Targets -&gt; Build Setting - Architectures</code>修改架构，只不过目前来说都是arm64。可以添加armv7、armv7s。</p>
<p>armv7s是一种临时的支持iPhone5c上可用的架构。</p>
<p><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>
<p>原则上来说，架构都是向下兼容的。</p>
<h3 id="lipo命令拆分、合并通用二进制文件"><a href="#lipo命令拆分、合并通用二进制文件" class="headerlink" title="lipo命令拆分、合并通用二进制文件"></a>lipo命令拆分、合并通用二进制文件</h3><ul>
<li><p>查看Mach-O文件包含的架构信息</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info [MachO文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分某种架构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</span><br><span class="line">$ lipo HookDemo -thin armv7 -output HookDemo_armv7</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并多种架构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</span><br><span class="line">lipo -create HookDemo_armv7 HookDemo_arm64 -output HookDemo_v7_64</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以在通过file命令查看拆分、合并的文件。</p>
<h1 id="Macho文件结构"><a href="#Macho文件结构" class="headerlink" title="Macho文件结构"></a>Macho文件结构</h1><ul>
<li>Header ：包含该二进制文件的一般信息<ul>
<li>字节顺序、架构类型、加载指令的数量等。</li>
<li>使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么、文件类型是什么</li>
</ul>
</li>
<li>Load commands：包含加载所需要的指令（动态库、静态库等）<ul>
<li>内容包括区域的位置、符号表、动态符号表等</li>
</ul>
</li>
<li>Data ：内容包括区域的位置、符号表、动态符号表等<ul>
<li>包含Segement的具体数据</li>
</ul>
</li>
</ul>
<p><img src="macho_1.jpg" alt=""></p>
<p>接下来使用MachOView工具来分析可执行文件，有两种类型：</p>
<ol>
<li>通用二进制文件，则显示的是Fat Binary</li>
<li>单一架构的文件，直接显示对应的Executable</li>
</ol>
<p><img src="MachOView_Fat.jpg" alt=""></p>
<h2 id="Fat-Binary"><a href="#Fat-Binary" class="headerlink" title="Fat Binary"></a>Fat Binary</h2><p>在上图中可以看到，首先是一个Fat Header的结构。在header中，可以猜到两个架构之间必定存在某些关联。</p>
<p>armv7：offset=16384，size=79872<br>arm64：offset=98304，size=80672</p>
<p>arm64是从98304开始的，比armv7多了 98304-(16384+79872)=2048，这个值只是一个差值，而从偏移的差值来看98304-16384=81920 = 5 * 16 * 1024</p>
<p>正好是5页数据，iOS中1页是16k，所以armv7是5页数据，最后的2038只是第5页数据没有排满而已。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>接下来看看arm64架构下的内容：</p>
<p><img src="MachOView.png" alt=""></p>
<p>在Xcode中，我们可以在<code>loader.h</code>文件中找到Header的相关信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;      &#x2F;* 魔数，快速定位属于64还是32位 *&#x2F;</span><br><span class="line">    cpu_type_t  cputype;    &#x2F;* CPU类型 *&#x2F;</span><br><span class="line">    cpu_subtype_t   cpusubtype; &#x2F;* CPU的具体类型 *&#x2F;</span><br><span class="line">    uint32_t    filetype;   &#x2F;* 文件类型，比如可执行文件 *&#x2F;</span><br><span class="line">    uint32_t    ncmds;      &#x2F;* Load Commands的条数 *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds; &#x2F;* Load Commands的大小 *&#x2F;</span><br><span class="line">    uint32_t    flags;      &#x2F;* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 *&#x2F;</span><br><span class="line">    uint32_t    reserved;   &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只放了arm64下的内容，当然也有32位的，内容基本一致。<br>这里需要注意的是filettype类型，是一组宏定义，也能找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define	MH_OBJECT	0x1		&#x2F;* relocatable object file *&#x2F; object文件</span><br><span class="line">#define	MH_EXECUTE	0x2		&#x2F;* demand paged executable file *&#x2F; 可执行文件</span><br><span class="line">#define	MH_FVMLIB	0x3		&#x2F;* fixed VM shared library file *&#x2F;</span><br><span class="line">#define	MH_CORE		0x4		&#x2F;* core file *&#x2F;</span><br><span class="line">#define	MH_PRELOAD	0x5		&#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#define	MH_DYLIB	0x6		&#x2F;* dynamically bound shared library *&#x2F; dylib文件</span><br><span class="line">#define	MH_DYLINKER	0x7		&#x2F;* dynamic link editor *&#x2F;</span><br><span class="line">#define	MH_BUNDLE	0x8		&#x2F;* dynamically bound bundle file *&#x2F;</span><br><span class="line">#define	MH_DYLIB_STUB	0x9		&#x2F;* shared library stub for static</span><br><span class="line">					   linking only, no section contents *&#x2F;</span><br><span class="line">#define	MH_DSYM		0xa		&#x2F;* companion file with only debug</span><br><span class="line">					   sections *&#x2F; dsym文件</span><br><span class="line">#define	MH_KEXT_BUNDLE	0xb		&#x2F;* x86_64 kexts *&#x2F;</span><br><span class="line">#define MH_FILESET	0xc		&#x2F;* a file composed of other Mach-Os to</span><br><span class="line">					   be run in the same userspace sharing</span><br><span class="line">					   a single linkedit. *&#x2F;</span><br></pre></td></tr></table></figure>

<p>所以当看到0x2时，标识的就是可执行文件。在MachOView中，在Header中，可以看到对应的数据信息。</p>
<h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><table>
<thead>
<tr>
<th align="left">LoadCommands</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LC_SEGMENT_64</td>
<td align="left">将文件中（32位或64位）的段映射到进程地址空间中，<br>主要分为<strong>TEXT、</strong>DATA、LINKEDIT几大块</td>
</tr>
<tr>
<td align="left">LC_DYLD_INFO_ONLY</td>
<td align="left">动态链接相关信息</td>
</tr>
<tr>
<td align="left">LC_SYMTAB</td>
<td align="left">符号地址</td>
</tr>
<tr>
<td align="left">LC_DYSYMTAB</td>
<td align="left">动态符号表地址</td>
</tr>
<tr>
<td align="left">LC_LOAD_DYLINKER</td>
<td align="left">使用谁加载，我们使用dyld</td>
</tr>
<tr>
<td align="left">LC_UUID</td>
<td align="left">Mach-O文件的唯一识别标识 UUID</td>
</tr>
<tr>
<td align="left">LC_VERSION_MIN_MACOSX</td>
<td align="left">支持最低的操作系统版本</td>
</tr>
<tr>
<td align="left">LC_SOURCE_VERSION</td>
<td align="left">源代码版本</td>
</tr>
<tr>
<td align="left">LC_MAIN</td>
<td align="left">设置程序主线程的入口地址和栈大小<br>当别人的app做了防护时，运行就是闪退，这个时候就需要从这里找切入点</td>
</tr>
<tr>
<td align="left">LC_ENCRYPTION_INFO_64</td>
<td align="left">加密信息</td>
</tr>
<tr>
<td align="left">LC_LOAD_DYLIB</td>
<td align="left">依赖库的路径，包含三方库</td>
</tr>
<tr>
<td align="left">LC_FUNCTION_STARTS</td>
<td align="left">函数起始地址表</td>
</tr>
<tr>
<td align="left">LC_CODE_SIGNATURE</td>
<td align="left">代码签名</td>
</tr>
</tbody></table>
<h3 id="LC-SEGMENT-64"><a href="#LC-SEGMENT-64" class="headerlink" title="LC_SEGMENT_64"></a>LC_SEGMENT_64</h3><p>这里面包含了一些基本信息：</p>
<ul>
<li><code>VM Address</code>：虚拟内存地址</li>
<li><code>VM Size</code>：(虚拟内存)大小为4G</li>
<li><code>File Offset</code>：数据在文件中的偏移地址</li>
<li><code>File Size</code>：数据在文件中的大小</li>
</ul>
<h3 id="LC-DYLD-INFO-ONLY"><a href="#LC-DYLD-INFO-ONLY" class="headerlink" title="LC_DYLD_INFO_ONLY"></a>LC_DYLD_INFO_ONLY</h3><p>这里主要说一下<code>Rebase Info Offset</code>，这个是重定向的偏移地址。</p>
<p>系统为了安全，在运行时，把Mach-O放在虚拟内存中，会随机生成一个<code>ASLR</code>，在运行时会进行重定向，比如查找字符串、方法等，都需要重定向，而重定向的方式是<code>ASLR</code>+<code>Rebase Info Offset</code>的值。</p>
<h2 id="Section64"><a href="#Section64" class="headerlink" title="Section64"></a>Section64</h2><p>主要氛围两大部分：</p>
<p>###__TEXT</p>
<p>主要存放：代码、字符常量、类、方法等。</p>
<table>
<thead>
<tr>
<th align="left">Section</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__TEXT, __text</td>
<td align="left">主程序代码段</td>
</tr>
<tr>
<td align="left">__TEXT, __stubs</td>
<td align="left">Stub可以理解为一段占位空间，placeholder，用于符号的lazy binding。</td>
</tr>
<tr>
<td align="left">__TEXT, __stubs_helper</td>
<td align="left">辅助绑定</td>
</tr>
<tr>
<td align="left">__TEXT, __cstring</td>
<td align="left">C语言字符串</td>
</tr>
<tr>
<td align="left">__TEXT, __entitlements</td>
<td align="left">__entitlements</td>
</tr>
<tr>
<td align="left">__TEXT, __unwind_info</td>
<td align="left">C语言字符串</td>
</tr>
<tr>
<td align="left">__TEXT, __const</td>
<td align="left">常量段（const修饰）</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_classname</td>
<td align="left">OC的类名</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_methname</td>
<td align="left">OC方法名称</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_methtype</td>
<td align="left">OC方法类型，即方法签名</td>
</tr>
</tbody></table>
<h3 id="DATA"><a href="#DATA" class="headerlink" title="__DATA:"></a>__DATA:</h3><table>
<thead>
<tr>
<th align="left">Section</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__DATA_CONST, __got</td>
<td align="left">__got</td>
</tr>
<tr>
<td align="left">__DATA, __got</td>
<td align="left">__got</td>
</tr>
<tr>
<td align="left"><strong>DATA</strong>data</td>
<td align="left">已初始化的全局变量。static int a = 1;</td>
</tr>
<tr>
<td align="left">__DATA, __bss</td>
<td align="left">未初始化的静态变量。static int a;</td>
</tr>
<tr>
<td align="left">__DATA, __const</td>
<td align="left">常量。 char * const p = “foo”;</td>
</tr>
<tr>
<td align="left">__DATA, __cfstring</td>
<td align="left">字符串（CFStringRefs）</td>
</tr>
<tr>
<td align="left">__DATA, __common</td>
<td align="left">未初始化的外部全局变量。 int a;</td>
</tr>
<tr>
<td align="left">__DATA, __la_symbol_ptr</td>
<td align="left">懒绑定的符号指针表。</td>
</tr>
<tr>
<td align="left">__DATA, __nl_symbol_ptr</td>
<td align="left">非懒绑定的符号指针表。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_classlist</td>
<td align="left">OC的类列表，存储一个个指向objc_class结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_nlclslist</td>
<td align="left">OC的类列表，+load相关？</td>
</tr>
<tr>
<td align="left">__DATA, __objc_catlist</td>
<td align="left">OC的category列表，存储一个个指向__objc_category结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_protolist</td>
<td align="left">OC的协议列表，存储一个个指向protocol_t结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_imginfo</td>
<td align="left">OC的image信息</td>
</tr>
<tr>
<td align="left">__DATA, __objc_selrefs</td>
<td align="left">哪些SEL对应的字符串被引用了</td>
</tr>
<tr>
<td align="left">__DATA, __objc_classrefs</td>
<td align="left">类的引用，即msg_objSend相关</td>
</tr>
<tr>
<td align="left">__DATA, __objc_superrefs</td>
<td align="left">super引用，记录了super方法调用的类。<br>如ViewController中的viewDidLoad中调用了<code>[super viewDidLoad]</code>，<br>则ViewController class即被记录。<br>也可以理解为objc_msgSendSuper相关。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_protorefs</td>
<td align="left">协议引用</td>
</tr>
<tr>
<td align="left">__DATA, __objc_ivar</td>
<td align="left">成员变量</td>
</tr>
<tr>
<td align="left">__DATA, __objc_const</td>
<td align="left">这里的const与<code>__TEXT-&gt;const</code>完全不同。<br><code>__objc_const</code>指的是OC内存布局中的不可变部分，即class_ro_t类型。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_data</td>
<td align="left">保存类所需的数据？</td>
</tr>
</tbody></table>
<p>篇幅原因，动态加载以及符号表下一篇再介绍。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Mach-O简介</li>
<li>clang命令<ul>
<li>编译成点O文件：$ clang -c test.c</li>
<li>把点O文件编译为可执行文件：$ clang text.o</li>
<li>查看文件类型：$ file text.out</li>
</ul>
</li>
<li>lipo命令<ul>
<li>查看二进制文件 $ lipo -info [MachO文件]</li>
<li>拆分为某一种架构：$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</li>
<li>合并多种架构：$ lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</li>
</ul>
</li>
<li>MachO就结构<ul>
<li>Header<ul>
<li>用于快速群定该文件的CPU类型、文件类型</li>
</ul>
</li>
<li>Load Commands<ul>
<li>指示加载器如何设置并且加载二进制数据</li>
</ul>
</li>
<li>Section64<ul>
<li>存放数据：代码、数据、字符串常量、类、方法等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a><br><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/" class="post-title-link" itemprop="url">runloop</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 13:34:10" itemprop="dateCreated datePublished" datetime="2021-05-30T13:34:10+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:58" itemprop="dateModified" datetime="2021-05-31T10:29:58+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RunLoop是事件接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个RunLoop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。</p>
<p>RunLoop本质是一个 do-while循环，没事做就休息，来活了就干活。与普通的while循环是有区别的，普通的while循环会导致CPU进入忙等待状态，即一直消耗cpu，而RunLoop则不会，RunLoop是一种闲等待，即RunLoop具备休眠功能。</p>
<h2 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h2><ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（触摸、定时器、performSelector）</li>
<li>节省cpu资源，提供程序的性能，该做事就做事，该休息就休息</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>
<h2 id="runloop与线程"><a href="#runloop与线程" class="headerlink" title="runloop与线程"></a>runloop与线程</h2><p>通常情况下获取runloop的两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主运行循环</span><br><span class="line">CFRunLoopRef mainRunloop &#x3D; CFRunLoopGetMain();</span><br><span class="line">&#x2F;&#x2F; 当前运行循环</span><br><span class="line">CFRunLoopRef currentRunloop &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>

<p>接下来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    &#x2F;&#x2F; 这是一个静态变量</span><br><span class="line">    static CFRunLoopRef __main &#x3D; NULL; &#x2F;&#x2F; no retain needed</span><br><span class="line">    &#x2F;&#x2F; 没有获取到，则通过_CFRunLoopGet0函数去获取，参数是主线程</span><br><span class="line">    if (!__main) __main &#x3D; _CFRunLoopGet0(pthread_main_thread_np()); &#x2F;&#x2F; no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下<code>_CFRunLoopGet0</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如参数t不存在，则默认为主线程</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t &#x3D; pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建一个字典</span><br><span class="line">        CFMutableDictionaryRef dict &#x3D; CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        &#x2F;&#x2F; 创建mainLoop</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; dict : key value</span><br><span class="line">        &#x2F;&#x2F; 把main_thread和mainloop通过key-value的形式绑定</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从字典中通过线程获取run loop</span><br><span class="line">    CFRunLoopRef loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有则创建</span><br><span class="line">        CFRunLoopRef newLoop &#x3D; __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有loop也要存，存的是新创建的。</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop &#x3D; newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 &#x3D;&#x3D; _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出，runloo只有两种类型，一种主线程的mainloop，还有就是其它runloop。</p>
<h2 id="runloop的创建"><a href="#runloop的创建" class="headerlink" title="runloop的创建"></a>runloop的创建</h2><p>接下来看runloop是怎么创建的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    CFRunLoopRef loop &#x3D; NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size &#x3D; sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop &#x3D; (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</span><br><span class="line">    &#x2F;&#x2F; 如果loop为空，则直接返回NULL</span><br><span class="line">    if (NULL &#x3D;&#x3D; loop) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; runloop属性赋值</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort &#x3D; __CFPortAllocate();</span><br><span class="line">    if (CFPORT_NULL &#x3D;&#x3D; loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems &#x3D; NULL;</span><br><span class="line">    loop-&gt;_currentMode &#x3D; NULL;</span><br><span class="line">    loop-&gt;_modes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head &#x3D; NULL;</span><br><span class="line">    loop-&gt;_blocks_tail &#x3D; NULL;</span><br><span class="line">    loop-&gt;_counterpart &#x3D; NULL;</span><br><span class="line">    loop-&gt;_pthread &#x3D; t;</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    loop-&gt;_winthread &#x3D; GetCurrentThreadId();</span><br><span class="line">#else</span><br><span class="line">    loop-&gt;_winthread &#x3D; 0;</span><br><span class="line">#endif</span><br><span class="line">    rlm &#x3D; __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL !&#x3D; rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面又有了一个CFRunLoopRef,盲猜应该是结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            &#x2F;* locked for accessing mode list *&#x2F;</span><br><span class="line">    __CFPort _wakeUpPort;            &#x2F;&#x2F; used for CFRunLoopWakeUp</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              &#x2F;&#x2F; reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从定义中可以得出，一个RunLoop有多个Mode，意味着一个RunLoop需要处理多个事务，即一个Mode对应多个Item，而一个item中，包含了timer、source、observer，如图：</p>
<p><img src="runloop_1.jpg" alt=""></p>
<h3 id="mode类型"><a href="#mode类型" class="headerlink" title="mode类型"></a>mode类型</h3><p>其中mode在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code>和<code>NSRunLoopCommonModes</code>。</p>
<p><code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p>
<ul>
<li>NSDefaultRunLoopMode：默认的mode，正常情况下都是在这个mode</li>
<li>NSConnectionReplyMode</li>
<li>NSModalPanelRunLoopMode</li>
<li>NSEventTrackingRunLoopMode：使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</li>
<li>NSRunLoopCommonModes：伪模式，灵活性更好</li>
</ul>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><ul>
<li>Source0 表示 非系统事件，即用户自定义的事件</li>
<li>Source1 表示系统事件，主要负责底层的通讯，具备唤醒能力</li>
</ul>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入RunLoop</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),</span><br><span class="line">    &#x2F;&#x2F;即将处理Timers</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),</span><br><span class="line">    &#x2F;&#x2F;即将处理Source</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),</span><br><span class="line">    &#x2F;&#x2F;即将进入休眠</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),</span><br><span class="line">    &#x2F;&#x2F;被唤醒</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),</span><br><span class="line">    &#x2F;&#x2F;退出RunLoop</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mode对应的items"><a href="#mode对应的items" class="headerlink" title="mode对应的items"></a>mode对应的items</h3><ul>
<li>block：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></li>
<li>timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></li>
<li>source0： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></li>
<li>source1： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></li>
<li>主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></li>
<li>observer： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></li>
</ul>
<h3 id="以Timer为例"><a href="#以Timer为例" class="headerlink" title="以Timer为例"></a>以Timer为例</h3><p>在子线程创建的timer是没有办法一直执行的，而想让它继续执行，则需要添加到runloop中，并且run才行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">self.isStopping &#x3D; NO;</span><br><span class="line">NSThread *thread &#x3D; [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; thread.name &#x3D; nil 因为这个变量只是捕捉</span><br><span class="line">    &#x2F;&#x2F; LGThread *thread &#x3D; nil</span><br><span class="line">    &#x2F;&#x2F; thread &#x3D; 初始化 捕捉一个nil进来</span><br><span class="line">    NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">    NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;~~hello word&quot;);            &#x2F;&#x2F; 退出线程--结果runloop也停止了</span><br><span class="line">        if (self.isStopping) &#123;</span><br><span class="line">            [NSThread exit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">thread.name &#x3D; @&quot;lgcode.com&quot;;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<p>我们看一下addTimer是怎么操作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">oid CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</span><br><span class="line">    if (!__CFIsValid(rlt) || (NULL !&#x3D; rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop !&#x3D; rl)) return;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点 : kCFRunLoopCommonModes</span><br><span class="line">    if (modeName &#x3D;&#x3D; kCFRunLoopCommonModes) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是kCFRunLoopCommonModes 类型</span><br><span class="line">        CFSetRef set &#x3D; rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        </span><br><span class="line">        if (NULL &#x3D;&#x3D; rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            &#x2F;&#x2F; modeItems是空，则创建一个defalut</span><br><span class="line">            rl-&gt;_commonModeItems &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;runloop与mode 是一对多的， mode与item也是一对多的</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        if (NULL !&#x3D; set) &#123;</span><br><span class="line">            CFTypeRef context[2] &#x3D; &#123;rl, rlt&#125;;</span><br><span class="line">            &#x2F;* add new item to all common-modes *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;执行</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是非commonMode类型</span><br><span class="line">        &#x2F;&#x2F;查找runloop的模型</span><br><span class="line">        CFRunLoopModeRef rlm &#x3D; __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb &#x3D; kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal &#x3D; NULL;</span><br><span class="line">                rlm-&gt;_timers &#x3D; CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断mode是否匹配</span><br><span class="line">        if (NULL !&#x3D; rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop &#x3D; rl;</span><br><span class="line">            &#125; else if (rl !&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Normally we don&#39;t do this on behalf of clients, but for</span><br><span class="line">                &#x2F;&#x2F; backwards compatibility due to the change in timer handling...</span><br><span class="line">                if (rl !&#x3D; CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要目的就是把timer添加到对应的mode中。mode 和 item是一对多的关系，timer是item的一种。</p>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><p>接下来上源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    do &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是timer</span><br><span class="line">        else if (modeQueuePort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                &#x2F;&#x2F; Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是source1</span><br><span class="line">        CFRunLoopSourceRef rls &#x3D; __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            mach_msg_header_t *reply &#x3D; NULL;</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            if (NULL !&#x3D; reply) &#123;</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__CFRunLoopDoTimers源码，主要是通过for循环，对单个timer进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;循环遍历，做下层单个timer的执行</span><br><span class="line">    for (CFIndex idx &#x3D; 0, cnt &#x3D; timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt &#x3D; (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        Boolean did &#x3D; __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled &#x3D; timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mode and rl are locked on entry and exit</span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    Boolean timerHandled &#x3D; false;</span><br><span class="line">    uint64_t oldFireTSR &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* Fire a timer *&#x2F;</span><br><span class="line">    CFRetain(rlt);</span><br><span class="line">    __CFRunLoopTimerLock(rlt);</span><br><span class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;&#x3D; mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop &#x3D;&#x3D; rl) &#123;</span><br><span class="line">    __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">        __CFRunLoopTimerFireTSRLock();</span><br><span class="line">        oldFireTSR &#x3D; rlt-&gt;_fireTSR;</span><br><span class="line">        __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">        </span><br><span class="line">        __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        if (doInvalidate) &#123;</span><br><span class="line">            CFRunLoopTimerInvalidate(rlt);      &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        if (context_release) &#123;</span><br><span class="line">            context_release(context_info);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        __CFRunLoopTimerLock(rlt);</span><br><span class="line">        timerHandled &#x3D; true;</span><br><span class="line">        __CFRunLoopTimerUnsetFiring(rlt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在timer执行的位置打上断点，使用lldb -&gt; bt命令查看调用栈：</p>
<p><img src="runloop_2.jpg" alt=""></p>
<h3 id="timer的调用顺序"><a href="#timer的调用顺序" class="headerlink" title="timer的调用顺序"></a>timer的调用顺序</h3><ol>
<li>自定义的timer，设置Mode，并将其加入RunLoop中</li>
<li>在RunLoop的run方法执行时，会调用__CFRunLoopDoTimers执行所有timer</li>
<li>在__CFRunLoopDoTimers方法中，会通过for循环执行单个timer的操作</li>
<li>在__CFRunLoopDoTimer方法中，timer执行完毕后，会执行对应的timer回调函数</li>
</ol>
<p>是针对timer的执行分析，对于observer、block、source0、source1，其执行原理与timer是类似的</p>
<p><img src="runloop_3.jpg" alt=""></p>
<h1 id="runloop底层原理"><a href="#runloop底层原理" class="headerlink" title="runloop底层原理"></a>runloop底层原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.0e10 : 科学计数 1*10^10，很大的值</span><br><span class="line">        result &#x3D; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped !&#x3D; result &amp;&amp; kCFRunLoopRunFinished !&#x3D; result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runloop就是一个do-while循环。当stop或者执行完成之后，则退出循环。</p>
<p>看一下<code>CFRunLoopRunSpecific</code>的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内部函数，进入loop，seconds是一个很大的值</span><br><span class="line">    result &#x3D; __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来又回到<code>__CFRunLoopRun</code>的代码，上面提到的逻辑只是针对timer的，这里详细的说明一下，使用伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;核心函数</span><br><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;通过GCD开启一个定时器，然后开始跑圈</span><br><span class="line">    dispatch_source_t timeout_timer &#x3D; NULL;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    int32_t retVal &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;处理事务,即处理items</span><br><span class="line">    do &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理timer事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理Source事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 判断有无端口消息(Source1)</span><br><span class="line">        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理消息</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 等待被唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 被唤醒，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;else if (被GCD唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 处理gcd</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;else if (被source1唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 被Source1唤醒，处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunHandledSource;&#x2F;&#x2F;处理源</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunTimedOut;&#x2F;&#x2F;超时</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunFinished;&#x2F;&#x2F;结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整理一下runloop的整体流程如下：</p>
<p><img src="runloop_4.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/" class="post-title-link" itemprop="url">内存管理-自动释放池</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 10:05:30" itemprop="dateCreated datePublished" datetime="2021-05-30T10:05:30+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h1><p>新建一个工程，在main.m中就有一个autoreleasepool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过clang编译一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc main.m -o main.cpp</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">$ xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc main.m -o main-arm64.cpp</span><br></pre></td></tr></table></figure>

<p>我们打开对应的cpp文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    __AtAutoreleasePool() &#123;</span><br><span class="line">        atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 析构函数</span><br><span class="line">    ~__AtAutoreleasePool() &#123;</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        &#x2F;&#x2F; 是一个结构体</span><br><span class="line">         __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">&#123;__AtAutoreleasePool __autoreleasepool; &#125;</span><br></pre></td></tr></table></figure>

<p>__AtAutoreleasePool是一个结构体，有<code>构造函数</code> 和 <code>析构函数</code>，在结构体定义的对象在作用域结束后，会自动调用析构函数。</p>
<p>在源码中有这么一段话：</p>
<blockquote>
<p>  Autorelease pool implementation</p>
</blockquote>
<blockquote>
<p>  A thread’s autorelease pool is a stack of pointers.<br>  Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.<br>  A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.<br> The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary.<br> Thread-local storage points to the hot page, where newly autoreleased objects are stored. </p>
</blockquote>
<p>通过上述描述，可以大概的知道以下几点：</p>
<p>通过描述，有以下几点说明</p>
<ol>
<li>自动释放池 是一个 关于指针的栈结构</li>
<li>其中的指针是指要释放的对象或者 pool_boundary 哨兵（现在经常被称为 边界）</li>
<li>自动释放池是一个页的结构（虚拟内存中提及过） ，而且这个页是一个双向链表（表示有父节点 和 子节点，在类中有提及，即类的继承链）</li>
<li>自动释放池和线程有关系</li>
</ol>
<p>接下来看一下源码中的实现：</p>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都有一个<code>AutoreleasePoolPage</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#96;class AutoreleasePoolPage : private AutoreleasePoolPageData&#96;</span><br><span class="line"></span><br><span class="line">struct AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;用来校验AutoreleasePoolPage的结构是否完整</span><br><span class="line">    magic_t const magic;    &#x2F;&#x2F;16个字节，以结构体中的变量对齐后的值为准，m[4] &#x3D; 4*4 &#x3D;16字节</span><br><span class="line">    &#x2F;&#x2F;指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()</span><br><span class="line">    __unsafe_unretained id *next;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向当前线程</span><br><span class="line">    pthread_t const thread;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向父节点，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage * const parent;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向子节点，最后一个结点的child值为nil</span><br><span class="line">    AutoreleasePoolPage *child;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;表示深度，从0开始，往后递增1</span><br><span class="line">    uint32_t const depth;&#x2F;&#x2F;4字节</span><br><span class="line">    &#x2F;&#x2F;表示high water mark 最大入栈数量标记</span><br><span class="line">    uint32_t hiwat;&#x2F;&#x2F;4字节</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们在回过头看看<code>objc_autoreleasePoolPush</code></p>
<h2 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    &#x2F;&#x2F;判断是否有pool</span><br><span class="line">    if (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Each autorelease pool starts on a new pool page</span><br><span class="line">        &#x2F;&#x2F; 自动释放池从新池页面开始</span><br><span class="line">        &#x2F;&#x2F;如果没有，则创建</span><br><span class="line">        dest &#x3D; autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;压栈一个POOL_BOUNDARY，即压栈哨兵</span><br><span class="line">        dest &#x3D; autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER || *dest &#x3D;&#x3D; POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autoreleaseNewPage"><a href="#autoreleaseNewPage" class="headerlink" title="autoreleaseNewPage"></a>autoreleaseNewPage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建新页</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNewPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    &#x2F;&#x2F;如果存在，则压栈对象</span><br><span class="line">    if (page) return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#x2F;&#x2F;如果不存在，则创建页</span><br><span class="line">    else return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** hotPage方法 ********</span><br><span class="line">&#x2F;&#x2F;获取当前操作页</span><br><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前页</span><br><span class="line">    AutoreleasePoolPage *result &#x3D; (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    &#x2F;&#x2F;如果是一个空池，则返回nil，否则，返回当前线程的自动释放池</span><br><span class="line">    if ((id *)result &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** autoreleaseNoPage方法 ********</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; &quot;No page&quot; could mean no pool has been pushed</span><br><span class="line">    &#x2F;&#x2F; or an empty placeholder pool has been pushed and has no contents yet</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing a second pool over the empty placeholder pool</span><br><span class="line">        &#x2F;&#x2F; or pushing the first object into the empty placeholder pool.</span><br><span class="line">        &#x2F;&#x2F; Before doing that, push a pool boundary on behalf of the pool </span><br><span class="line">        &#x2F;&#x2F; that is currently represented by the empty placeholder.</span><br><span class="line">        pushExtraBoundary &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果对象不是哨兵对象，且没有Pool，则报错</span><br><span class="line">    else if (obj !&#x3D; POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place, </span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                     objc_thread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span><br><span class="line">    else if (obj &#x3D;&#x3D; POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;&#x2F;&#x2F;如果传入参数为哨兵</span><br><span class="line">        &#x2F;&#x2F; We are pushing a pool with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and alloc-per-pool debugging was not requested.</span><br><span class="line">        &#x2F;&#x2F; Install and return the empty pool placeholder.</span><br><span class="line">        return setEmptyPoolPlaceholder();&#x2F;&#x2F;设置空的占位符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We are pushing an object or a non-placeholder&#39;d pool.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    &#x2F;&#x2F;初始化第一页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    &#x2F;&#x2F;设置page为当前聚焦页</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push a boundary on behalf of the previously-placeholder&#39;d pool.</span><br><span class="line">    &#x2F;&#x2F;压栈哨兵的标识符为YES，则压栈哨兵对象</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        &#x2F;&#x2F;压栈哨兵</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object or pool.</span><br><span class="line">    &#x2F;&#x2F;压栈对象</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中autoreleaseNoPage方法中发现当前线程的自动释放池是通过AutoreleasePoolPage创建的，其定义中有构造方法，而构造方法的实现是通过父类AutoreleasePoolPageData的初始化方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;**********AutoreleasePoolPage构造方法**********</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),&#x2F;&#x2F;开始存储的位置</span><br><span class="line">                                objc_thread_self(),&#x2F;&#x2F;传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,&#x2F;&#x2F;如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">&#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        ASSERT(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        &#x2F;&#x2F;this 表示 新建页面，将当前页面的子节点 赋值为新建页面</span><br><span class="line">        parent-&gt;child &#x3D; this;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;**********AutoreleasePoolPageData初始化方法**********</span><br><span class="line">AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下几个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AutoreleasePoolPageData(begin(),&#x2F;&#x2F;开始存储的位置</span><br><span class="line">                                objc_thread_self(),&#x2F;&#x2F;传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,&#x2F;&#x2F;如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br></pre></td></tr></table></figure>


<ul>
<li><p><code>begin()</code>:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;页的开始位置</span><br><span class="line">id * begin() &#123;</span><br><span class="line">    &#x2F;&#x2F;等于 首地址+56（AutoreleasePoolPage类所占内存大小）</span><br><span class="line">    return (id *) ((uint8_t *)this+sizeof(*this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>objc_thread_self()</code>： 表示的是当前线程，而当前线程时通过tls获取</p>
</li>
<li><p><code>newParent</code>： 父节点</p>
</li>
<li><p>后面两个参数是通过父节点的深度、最大入栈个数计算depth以及hiwat</p>
</li>
</ul>
<h3 id="自动释放池内存结构"><a href="#自动释放池内存结构" class="headerlink" title="自动释放池内存结构"></a>自动释放池内存结构</h3><p>由于在ARC模式下，是无法手动调用autorelease，所以将Demo切换至MRC模式。<br><code>Build Settings</code> -&gt; <code>Objectice-C Automatic Reference Counting</code>设置为<code>NO</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动释放池打印</span><br><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;************运行代码************</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F;循环创建对象，并加入自动释放池</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">             NSObject *objc &#x3D; [[NSObject alloc] sutorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用</span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="autorelease_1.png" alt=""></p>
<p>查看自动释放池的内存结构，发现page的开始与第一个对象的地址差是0x38，转换成十进制刚好是56，也就是 AutoreleasePoolPage自己本身的内存大小。</p>
<p>但是打印的是5个对象，但是这里有6个。第一个<code>pool</code>是啥？</p>
<p>哨兵对象。只在第一页有，防止释放时越界。</p>
<p>接着我们修改i的最大值为505。发现第二页开始有1个数据了。<br>接着在继续修改最大值为504+506，发现第三页也开始有1个数据了。</p>
<p>所以第一页有哨兵对象，可以存504个对象。第二页之后可以存505个对象。</p>
<p>在源码中<code>AutoreleasePoolPage</code>-&gt;size可以看到一页的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">	static size_t const SIZE &#x3D; PAGE_MIN_SIZE;</span><br><span class="line"></span><br><span class="line">#define PAGE_MIN_SHIFT          12</span><br><span class="line">#define PAGE_MIN_SIZE           (1 &lt;&lt; PAGE_MIN_SHIFT)</span><br></pre></td></tr></table></figure>

<p>size = 1&lt;&lt;12 = 4096。</p>
<p>首地址是从0x38开始的，也就是56个字节，4096-46 = 4040 = 505 * 8<br>所以一页有506个对象。</p>
<p><img src="autorelease_2.jpg" alt=""></p>
<h3 id="autoreleaseFast压栈"><a href="#autoreleaseFast压栈" class="headerlink" title="autoreleaseFast压栈"></a>autoreleaseFast压栈</h3><p>push方法的第二步，第一步是创建，第二步是直接存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    &#x2F;&#x2F;判断页是否满了</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果未满，则压栈</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果满了，则安排新的页面</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;页不存在，则新建页</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前页没有满，则添加<code>add</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加释放对象</span><br><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    &#x2F;&#x2F;传入对象存储的位置</span><br><span class="line">    id *ret &#x3D; next;  &#x2F;&#x2F; faster than &#96;return next-1&#96; because of aliasing</span><br><span class="line">    &#x2F;&#x2F;将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置</span><br><span class="line">    *next++ &#x3D; obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果页满了则处理<code>autoreleaseFullPage</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full. </span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    ASSERT(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do-while遍历循环查找界面是否满了</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;如果子页面存在，则将页面替换为子页面</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        &#x2F;&#x2F;如果子页面不存在，则新建页面</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置为当前操作页面</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    &#x2F;&#x2F;对象压栈</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="压栈流程"><a href="#压栈流程" class="headerlink" title="压栈流程"></a>压栈流程</h4><ol>
<li>如果页存在，且未满，则通过add方法压栈对象</li>
<li>如果页存在，且满了，则通过autoreleaseFullPage方法安排新的页面</li>
<li>如果页不存在，则通过autoreleaseNoPage方法创建新页</li>
</ol>
<h2 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 析构函数</span><br><span class="line">~__AtAutoreleasePool() &#123;</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在析构函数中传了一个参数，就是<code>atautoreleasepoolobj</code>对象，这样就可以和创建的autoreleasepool关联上了。接下来看一下pop的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;出栈</span><br><span class="line">static inline void</span><br><span class="line">pop(void *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">   &#x2F;&#x2F;判断对象是否是空占位符</span><br><span class="line">    if (token &#x3D;&#x3D; (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当是空占位符</span><br><span class="line">        &#x2F;&#x2F; Popping the top-level placeholder pool.</span><br><span class="line">        &#x2F;&#x2F;获取当前页</span><br><span class="line">        page &#x3D; hotPage();</span><br><span class="line">        if (!page) &#123;</span><br><span class="line">            &#x2F;&#x2F; Pool was never used. Clear the placeholder.</span><br><span class="line">            &#x2F;&#x2F;如果当前页不存在，则清除空占位符</span><br><span class="line">            return setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Pool was used. Pop its contents normally.</span><br><span class="line">        &#x2F;&#x2F; Pool pages remain allocated for re-use as usual.</span><br><span class="line">        &#x2F;&#x2F;如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置</span><br><span class="line">        page &#x3D; coldPage();</span><br><span class="line">        token &#x3D; page-&gt;begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;获取token所在的页</span><br><span class="line">        page &#x3D; pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stop &#x3D; (id *)token;</span><br><span class="line">    &#x2F;&#x2F;判断最后一个位置，是否是哨兵</span><br><span class="line">    if (*stop !&#x3D; POOL_BOUNDARY) &#123;</span><br><span class="line">        &#x2F;&#x2F;最后一个位置不是哨兵，即最后一个位置是一个对象</span><br><span class="line">        if (stop &#x3D;&#x3D; page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是第一个位置，且没有父节点，什么也不做</span><br><span class="line">            &#x2F;&#x2F; Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            &#x2F;&#x2F; 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            &#x2F;&#x2F; 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是第一个位置，且有父节点，则出现了混乱</span><br><span class="line">            &#x2F;&#x2F; Error. For bincompat purposes this is not </span><br><span class="line">            &#x2F;&#x2F; fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        return popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;出栈页</span><br><span class="line">    return popPage&lt;false&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下popPage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;出栈页面</span><br><span class="line">template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    if (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line">    &#x2F;&#x2F; 出栈当前操作页面对象</span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; memory: delete empty children 删除空子项</span><br><span class="line">    if (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        &#x2F;&#x2F; special case: delete everything during page-per-pool debugging</span><br><span class="line">        &#x2F;&#x2F;调试期间删除每个特殊情况下的所有池</span><br><span class="line">        &#x2F;&#x2F;获取当前页面的父节点</span><br><span class="line">        AutoreleasePoolPage *parent &#x3D; page-&gt;parent;</span><br><span class="line">        &#x2F;&#x2F;将当前页面杀掉</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        &#x2F;&#x2F;设置操作页面为父节点页面</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        &#x2F;&#x2F; special case: delete everything for pop(top)</span><br><span class="line">        &#x2F;&#x2F; when debugging missing autorelease pools</span><br><span class="line">        &#x2F;&#x2F;特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        &#x2F;&#x2F; hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop就是自动释放池创建的位置。拿到stop的位置后，释放到stop位置之后的所有对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;释放到stop位置之前的所有对象</span><br><span class="line">void releaseUntil(id *stop) </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Not recursive: we don&#39;t want to blow out the stack  </span><br><span class="line">    &#x2F;&#x2F; 不是递归的：我们不想破坏堆栈</span><br><span class="line">    &#x2F;&#x2F; if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    &#x2F;&#x2F;判断下一个对象是否等于stop，如果不等于，则进入while循环</span><br><span class="line">    while (this-&gt;next !&#x3D; stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; Restart from hotPage() every time, in case -release </span><br><span class="line">        &#x2F;&#x2F; autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象</span><br><span class="line">        &#x2F;&#x2F;获取当前操作页面，即hot页面</span><br><span class="line">        AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fixme I think this &#96;while&#96; can be &#96;if&#96;, but I can&#39;t prove it</span><br><span class="line">        &#x2F;&#x2F;如果当前页是空的</span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;将page赋值为父节点页</span><br><span class="line">            page &#x3D; page-&gt;parent;</span><br><span class="line">            &#x2F;&#x2F;并设置当前页为父节点页</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        &#x2F;&#x2F;next进行--操作，即出栈</span><br><span class="line">        id obj &#x3D; *--page-&gt;next;</span><br><span class="line">        &#x2F;&#x2F;将页索引位置置为SCRIBBLE，表示已经被释放</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        if (obj !&#x3D; POOL_BOUNDARY) &#123;</span><br><span class="line">            &#x2F;&#x2F;释放</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置当前页</span><br><span class="line">    setHotPage(this);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; we expect any children to be completely empty</span><br><span class="line">    for (AutoreleasePoolPage *page &#x3D; child; page; page &#x3D; page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下<code>kill</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;销毁</span><br><span class="line">void kill() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Not recursive: we don&#39;t want to blow out the stack </span><br><span class="line">    &#x2F;&#x2F; if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F;获取最后一个页</span><br><span class="line">    while (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr &#x3D; page;</span><br><span class="line">        &#x2F;&#x2F;子节点 变成 父节点</span><br><span class="line">        page &#x3D; page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            &#x2F;&#x2F;子节点为nil</span><br><span class="line">            page-&gt;child &#x3D; nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr !&#x3D; this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autorelease-pop流程"><a href="#autorelease-pop流程" class="headerlink" title="autorelease pop流程"></a>autorelease pop流程</h3><ol>
<li>是否是空页，做容错处理</li>
<li>releaseUntil(stop)，按页倒序进行，循环释放所有对象，直到位置执行stop。先从child开始</li>
<li>页中的对象释放之后，page执行kill，循环删除child节点</li>
</ol>
<h2 id="autorelease底层"><a href="#autorelease底层" class="headerlink" title="autorelease底层"></a>autorelease底层</h2><p>看一下mrc下autorelease的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;如果不是对象，则直接返回</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    &#x2F;&#x2F;如果是小对象，也直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是小对象，则直接return，不处理。</li>
<li>如果是对象，执行<code>obj-&gt;autorelease()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    &#x2F;&#x2F; 自定义对象</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootAutorelease();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 系统</span><br><span class="line">    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义对象，执行<code>rootAutorelease</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否为小对象</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象执行<code>rootAutorelease2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行的还是<code>AutoreleasePoolPage</code>这个对象，调用<code>autorelease</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    static inline id autorelease(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(obj);</span><br><span class="line">        ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused &#x3D; autoreleaseFast(obj);</span><br><span class="line">        ASSERT(!dest  ||  dest &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER  ||  *dest &#x3D;&#x3D; obj);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的就是<code>autoreleaseFast</code>。就又回到了上面的压栈流程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>@autoreleasepool {} 等价于 {__AtAutoreleasePool __autoreleasepool; }，这是构造和析构函数</li>
<li>autorelease push压栈流程<ol>
<li>如果页存在，且未满，则通过add方法压栈对象</li>
<li>如果页存在，且满了，则通过autoreleaseFullPage方法安排新的页面</li>
<li>如果页不存在，则通过autoreleaseNoPage方法创建新页</li>
</ol>
</li>
<li>autorelease pop流程<ol>
<li>是否是空页，做容错处理</li>
<li>releaseUntil(stop)，按页倒序进行，循环释放所有对象，直到位置执行stop。先从child开始</li>
<li>页中的对象释放之后，page执行kill，循环删除child节点</li>
</ol>
</li>
<li>mrc下 autorelease原理<ol>
<li>判断是否为小对象，是直接return</li>
<li>执行<code>autoreleaseFast</code>，执行autorelease push压栈流程</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
