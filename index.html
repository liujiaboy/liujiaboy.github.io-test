<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">flutter-规范</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 10:04:25" itemprop="dateCreated datePublished" datetime="2021-12-27T10:04:25+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-28 16:53:48" itemprop="dateModified" datetime="2021-12-28T16:53:48+08:00">2021-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h2><p>代码应该简洁易懂，逻辑清晰；<br>代码应优先保证正确性、可用性；<br>在保证程序可用的情况下，代码应该具备可扩展性，易修改，而不是需求有一点改动代码就需要大动干戈；</p>
<h2 id="禁止使用print直接提交到发版分支，使用debugPrint替换。"><a href="#禁止使用print直接提交到发版分支，使用debugPrint替换。" class="headerlink" title="禁止使用print直接提交到发版分支，使用debugPrint替换。"></a>禁止使用print直接提交到发版分支，使用debugPrint替换。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void tryCatch(Function f) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    f?.call();</span><br><span class="line">  &#125; catch (e, stack) &#123;</span><br><span class="line">    debugPrint(&#39;$e&#39;);</span><br><span class="line">    debugPrint(&#39;$stack&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。"><a href="#两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。" class="headerlink" title="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。"></a>两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(</span><br><span class="line">    &#39;ERROR: Parts of the spaceship are on fire. Other &#39;</span><br><span class="line">    &#39;parts are overrun by martians. Unclear which are which.&#39;);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;ERROR: Parts of the spaceship are on fire. Other &#39; +</span><br><span class="line">    &#39;parts are overrun by martians. Unclear which are which.&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="优先使用插值来组合字符串和值。"><a href="#优先使用插值来组合字符串和值。" class="headerlink" title="优先使用插值来组合字符串和值。"></a>优先使用插值来组合字符串和值。</h3><p>如果您之前是用其他语言做开发的，那么您习惯使用+的长链来构建文字和其他值的字符串。 这在Dart中有效，但使用插值总是更清晰，更简短：</p>
<p>推荐写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hello, $name! You are $&#123;year - birth&#125; years old.&#39;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hello, &#39; + name + &#39;! You are &#39; + (year - birth).toString() + &#39; y...&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="不要在字符串中使用不必要的大括号"><a href="#不要在字符串中使用不必要的大括号" class="headerlink" title="不要在字符串中使用不必要的大括号"></a>不要在字符串中使用不必要的大括号</h3><p>当表达式的值可以为真、假或null，并且您需要将结果传递给不接受null的对象时，此规则适用。一个常见的情况是一个判断空值的方法调用被用作条件:</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hi, $name!&#39;</span><br><span class="line">&quot;Wear your wildest $decade&#39;s outfit.&quot;</span><br><span class="line">&#x2F;&#x2F;标识符后面有紧跟着的字母了 加上大括号用以区分</span><br><span class="line">&#39;Wear your wildest $&#123;decade&#125;s outfit.&#39;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hi, $&#123;name&#125;!&#39;</span><br><span class="line">&quot;Wear your wildest $&#123;decade&#125;&#39;s outfit.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="使用-将空值转换为布尔值。"><a href="#使用-将空值转换为布尔值。" class="headerlink" title="使用? ?将空值转换为布尔值。"></a>使用? ?将空值转换为布尔值。</h3><p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (optionalThing?.isEnabled) &#123;</span><br><span class="line">  print(&quot;Have enabled thing.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果optionalThing为空，此代码将抛出异常。（if只支持判断bool值，不支持null）要解决这个问题，您需要将null值“转换”为true或false。虽然您可以使用==来完成此操作，但我们建议使用?? :</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled ?? false;</span><br><span class="line">&#x2F;&#x2F;如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled ?? true;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled &#x3D;&#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled !&#x3D; false;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="尽可能的使用集合字面量。"><a href="#尽可能的使用集合字面量。" class="headerlink" title="尽可能的使用集合字面量。"></a>尽可能的使用集合字面量。</h3><p>两种方式来构造一个空的可变 list ： [] 和 List() 。 同样，有三种方式来构造一个空的Map map：{}， Map()， 和 LinkedHashMap() 。 如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。 否则，使用字面量语法更加优雅。 核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; [];</span><br><span class="line">var addresses &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; List();</span><br><span class="line">var addresses &#x3D; Map();</span><br></pre></td></tr></table></figure>

<h3 id="如果需要的话，你可以提供一个泛型"><a href="#如果需要的话，你可以提供一个泛型" class="headerlink" title="如果需要的话，你可以提供一个泛型"></a>如果需要的话，你可以提供一个泛型</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; &lt;Point&gt;[];</span><br><span class="line">var addresses &#x3D; &lt;String, Address&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points &#x3D; List&lt;Point&gt;();</span><br><span class="line">var addresses &#x3D; Map&lt;String, Address&gt;();</span><br></pre></td></tr></table></figure>

<p>注意，对于集合类的 命名 构造函数则不适用上面的规则。 List.from()、 Map.fromIterable() 都有其使用场景。 如果需要一个固定长度的结合，使用 List() 来创建一个固定长度的 list 也是合理的。</p>
<h3 id="不要使用-length-来判断一个集合是否为空。"><a href="#不要使用-length-来判断一个集合是否为空。" class="headerlink" title="不要使用 .length 来判断一个集合是否为空。"></a>不要使用 .length 来判断一个集合是否为空。</h3><p>通过调用 .length 来判断集合是否包含内容是非常低效的。相反，Dart 提供了更加高效率和易用的 getter 函数：.isEmpty 和.isNotEmpty。 使用这些函数并不需要对结果再次取非(list.length ! =0)</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.isEmpty) return &#39;so hungry...&#39;;</span><br><span class="line">if (words.isNotEmpty) return words.join(&#39; &#39;);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.length &#x3D;&#x3D; 0) return &#39;so hungry...&#39;;</span><br><span class="line">if (!words.isEmpty) return words.join(&#39; &#39;);</span><br></pre></td></tr></table></figure>

<h3 id="不要使用-List-from-除非想修改结果的类型。"><a href="#不要使用-List-from-除非想修改结果的类型。" class="headerlink" title="不要使用 List.from() 除非想修改结果的类型。"></a>不要使用 List.from() 除非想修改结果的类型。</h3><p>给定一个可迭代的对象，有两种常见方式来生成一个包含相同元素的 list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var copy1 &#x3D; iterable.toList();</span><br><span class="line">var copy2 &#x3D; List.from(iterable);</span><br></pre></td></tr></table></figure>
<p>推荐的写法<br>明显的区别是前一个更短。 更重要的区别在于第一个保留了原始对象的类型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable &#x3D; [1, 2, 3];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 输出 &quot;List&lt;int&gt;&quot;:</span><br><span class="line">print(iterable.toList().runtimeType);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出 &quot;List&lt;dynamic&gt;&quot;:</span><br><span class="line">print(List.from(iterable).runtimeType);</span><br></pre></td></tr></table></figure>

<h3 id="如果你想要改变原始对象的类型参数，那么可以调用-List-from-："><a href="#如果你想要改变原始对象的类型参数，那么可以调用-List-from-：" class="headerlink" title="如果你想要改变原始对象的类型参数，那么可以调用 List.from() ："></a>如果你想要改变原始对象的类型参数，那么可以调用 List.from() ：</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers &#x3D; [1, 2.3, 4]; &#x2F;&#x2F; List&lt;num&gt;.</span><br><span class="line">numbers.removeAt(1); &#x2F;&#x2F; 现在集合里只包含int型</span><br><span class="line">var ints &#x3D; List&lt;int&gt;.from(numbers);</span><br></pre></td></tr></table></figure>
<p>但是如果你的目的只是复制可迭代对象并且保留元素原始类型， 或者并不在乎类型，那么请使用 toList() 。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="使用-来分隔参数名和参数默认值。"><a href="#使用-来分隔参数名和参数默认值。" class="headerlink" title="使用 = 来分隔参数名和参数默认值。"></a>使用 = 来分隔参数名和参数默认值。</h3><p>由于遗留原因，Dart 同时支持 : 和 = 作为参数名和默认值的分隔符。 为了与可选的位置参数保持一致，请使用 = 。</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at &#x3D; 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at: 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="不要-为字段创建不必要的-getter-和-setter-方法"><a href="#不要-为字段创建不必要的-getter-和-setter-方法" class="headerlink" title="不要 为字段创建不必要的 getter 和 setter 方法"></a>不要 为字段创建不必要的 getter 和 setter 方法</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var _contents;</span><br><span class="line">  get contents &#x3D;&gt; _contents;</span><br><span class="line">  set contents(value) &#123;</span><br><span class="line">    _contents &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要使用this-在重定向命名函数和避免冲突的情况下除外"><a href="#不要使用this-在重定向命名函数和避免冲突的情况下除外" class="headerlink" title="不要使用this. 在重定向命名函数和避免冲突的情况下除外"></a>不要使用this. 在重定向命名函数和避免冲突的情况下除外</h3><p>只有当局部变量和成员变量名字一样的时候，你才需要使用 this. 来访问成员变量。 只有两种情况需要使用 this. 。其中一种情况是要访问的局部变量和成员变量命名一样的时候：</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    this.update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要尽可能的在定义变量的时候初始化变量值。"><a href="#要尽可能的在定义变量的时候初始化变量值。" class="headerlink" title="要尽可能的在定义变量的时候初始化变量值。"></a>要尽可能的在定义变量的时候初始化变量值。</h3><p>如果一个字段不依赖于构造函数中的参数， 则应该在定义的时候就初始化字段值。 这样可以减少需要的代码并可以确保在有多个构造函数的时候你不会忘记初始化该字段。</p>
<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents;</span><br><span class="line"> </span><br><span class="line">  Folder(this.name) : contents &#x3D; [];</span><br><span class="line">  Folder.temp() : name &#x3D; &#39;temporary&#39;; &#x2F;&#x2F; Oops! Forgot contents.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents &#x3D; [];</span><br><span class="line"> </span><br><span class="line">  Folder(this.name);</span><br><span class="line">  Folder.temp() : name &#x3D; &#39;temporary&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于变量取值依赖构造函数参数的情况以及不同的构造函数取值也不一样的情况， 则不适合本条规则。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="不要-使用-new"><a href="#不要-使用-new" class="headerlink" title="不要 使用 new"></a>不要 使用 new</h3><p>创建对象不要使用new</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Row(</span><br><span class="line">    children: [</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(&#39;Increment&#39;),</span><br><span class="line">      ),</span><br><span class="line">      Text(&#39;Click!&#39;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return new Row(</span><br><span class="line">    children: [</span><br><span class="line">      new RaisedButton(</span><br><span class="line">        child: new Text(&#39;Increment&#39;),</span><br><span class="line">      ),</span><br><span class="line">      new Text(&#39;Click!&#39;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要用-来替代空的构造函数体-。"><a href="#要用-来替代空的构造函数体-。" class="headerlink" title="要用 ; 来替代空的构造函数体 {}。"></a>要用 ; 来替代空的构造函数体 {}。</h3><p>在 Dart 中，没有具体函数体的构造函数可以使用分号结尾。 （事实上，这是不可变构造函数的要求。）</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要尽可能的使用初始化形式。"><a href="#要尽可能的使用初始化形式。" class="headerlink" title="要尽可能的使用初始化形式。"></a>要尽可能的使用初始化形式。</h3><p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Point(num x, num y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y,z;</span><br><span class="line">  Point(this.x, this.y,&#123;this.z&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的位于构造函数参数之前的 this. 语法被称之为初始化形式（initializing formal）。 有些情况下这无法使用这种形式。特别是，这种形式下在初始化列表中无法看到变量。 但是如果能使用该方式，就应该尽量使用。（如果使用命名参数）</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"><a href="#dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。" class="headerlink" title="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"></a>dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。</h3><p>不推荐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>推荐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="推荐-使用-async-await-而不是直接使用底层的特性。"><a href="#推荐-使用-async-await-而不是直接使用底层的特性。" class="headerlink" title="推荐 使用 async/await 而不是直接使用底层的特性。"></a>推荐 使用 async/await 而不是直接使用底层的特性。</h3><p>显式的异步代码是非常难以阅读和调试的， 即使使用很好的抽象（比如 future）也是如此。 这就是为何 Dart 提供了 async/await。 这样可以显著的提高代码的可读性并且让你可以在异步代码中使用语言提供的所有流程控制语句。</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) async &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var team &#x3D; await downloadTeam(teamName);</span><br><span class="line">    if (team &#x3D;&#x3D; null) return 0;</span><br><span class="line"></span><br><span class="line">    var players &#x3D; await team.roster;</span><br><span class="line">    return players.where((player) &#x3D;&gt; player.isActive).length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) &#123;</span><br><span class="line">  return downloadTeam(teamName).then((team) &#123;</span><br><span class="line">    if (team &#x3D;&#x3D; null) return Future.value(0);</span><br><span class="line"></span><br><span class="line">    return team.roster.then((players) &#123;</span><br><span class="line">      return players.where((player) &#x3D;&gt; player.isActive).length;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).catchError((e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 Dart 中标识符有三种类型。 • UpperCamelCase 每个单词的首字母都大写，包含第一个单词。 • lowerCamelCase 每个单词的首字母都大写，除了第一个单词， 第一个单词首字母小写，即使是缩略词。 • lowercase_with_underscores 只是用小写字母单词，即使是缩略词， 并且单词之间使用 _ 连接。</p>
<h3 id="使用-UpperCamelCase-风格命名类型。"><a href="#使用-UpperCamelCase-风格命名类型。" class="headerlink" title="使用 UpperCamelCase 风格命名类型。"></a>使用 UpperCamelCase 风格命名类型。</h3><p>Classes（类名）、 enums（枚举类型）、 typedefs（类型定义）、 以及 type parameters（类型参数）应该把每个单词的首字母都大写（包含第一个单词）， 不使用分隔符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SliderMenu &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">class HttpRequest &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">typedef Predicate &#x3D; bool Function&lt;T&gt;(T value);</span><br></pre></td></tr></table></figure>

<h3 id="要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。"><a href="#要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。" class="headerlink" title="要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。"></a>要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library peg_parser.source_scanner;</span><br><span class="line"></span><br><span class="line">import &#39;file_system.dart&#39;;</span><br><span class="line">import &#39;slider_menu.dart&#39;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library pegparser.SourceScanner;</span><br><span class="line">import &#39;file-system.dart&#39;;</span><br><span class="line">import &#39;SliderMenu.dart&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="要使用-lowercase-with-underscores-风格命名导入的前缀"><a href="#要使用-lowercase-with-underscores-风格命名导入的前缀" class="headerlink" title="要使用 lowercase_with_underscores 风格命名导入的前缀"></a>要使用 lowercase_with_underscores 风格命名导入的前缀</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39; as math;</span><br><span class="line">import &#39;package:angular_components&#x2F;angular_components&#39;</span><br><span class="line">    as angular_components;</span><br><span class="line">import &#39;package:js&#x2F;js.dart&#39; as js;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39; as Math;</span><br><span class="line">import &#39;package:angular_components&#x2F;angular_components&#39;</span><br><span class="line">    as angularComponents;</span><br><span class="line">import &#39;package:js&#x2F;js.dart&#39; as JS;</span><br></pre></td></tr></table></figure>

<h3 id="要-使用-lowerCamelCase-风格来命名其他的标识符。"><a href="#要-使用-lowerCamelCase-风格来命名其他的标识符。" class="headerlink" title="要 使用 lowerCamelCase 风格来命名其他的标识符。"></a>要 使用 lowerCamelCase 风格来命名其他的标识符。</h3><p>类成员、顶级定义、变量、参数以及命名参数等 除了第一个单词，每个单词首字母都应大写，并且不使用分隔符。</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var item;</span><br><span class="line"></span><br><span class="line">HttpRequest httpRequest;</span><br><span class="line"></span><br><span class="line">void align(bool clearItems) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"><a href="#要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。" class="headerlink" title="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"></a>要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。</h3><p>首字母大写缩略词比较难阅读， 特别是多个缩略词连载一起的时候会引起歧义。 例如，一个以 HTTPSFTP 开头的名字， 没有办法判断它是指 HTTPS FTP 还是 HTTP SFTP 。 为了避免上面的情况，缩略词和缩写词要像普通单词一样首字母大写， 两个字母的单词除外。 （像 ID 和 Mr. 这样的双字母缩写词仍然像一般单词一样首字母大写。）</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpConnectionInfo</span><br><span class="line">uiHandler</span><br><span class="line">IOStream</span><br><span class="line">HttpRequest</span><br><span class="line">Id</span><br><span class="line">DB</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPConnection</span><br><span class="line">UiHandler</span><br><span class="line">IoStream</span><br><span class="line">HTTPRequest</span><br><span class="line">ID</span><br><span class="line">Db</span><br></pre></td></tr></table></figure>

<p>• acronyms ：首字母缩略词，指取若干单词首字母组成一个新单词，如：HTTP = HyperText Transfer Protocol • abbreviations : 缩写词，指取某一单词的部分字母（或其他缩短单词的方式）代表整个单词，如：ID = identification</p>
<h3 id="不要-使用前缀字母"><a href="#不要-使用前缀字母" class="headerlink" title="不要 使用前缀字母"></a>不要 使用前缀字母</h3><p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTimeout</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kDefaultTimeout</span><br></pre></td></tr></table></figure>

<h3 id="要-使用-googlestyle-格式化你的代码"><a href="#要-使用-googlestyle-格式化你的代码" class="headerlink" title="要 使用 googlestyle 格式化你的代码"></a>要 使用 googlestyle 格式化你的代码</h3><p>格式化是一项繁琐的工作，尤其在重构过程中特别耗时。 庆幸的是，你不必担心。 使用Android studio默认的googlestyle。</p>
<h3 id="要对所有流控制结构使用花括号。"><a href="#要对所有流控制结构使用花括号。" class="headerlink" title="要对所有流控制结构使用花括号。"></a>要对所有流控制结构使用花括号。</h3><p>这样可以避免 dangling else （else悬挂）的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isWeekDay) &#123;</span><br><span class="line">  print(&#39;Bike to work!&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&#39;Go dancing or read a book!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个例外：一个没有 else 的 if 语句， 并且这个 if 语句以及它的执行体适合在一行中实现。 在这种情况下，如果您愿意，可以不用括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (arg &#x3D;&#x3D; null) return defaultValue;</span><br></pre></td></tr></table></figure>

<p>但是，如果执行体包含下一行，请使用大括号：</p>
<p>推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars !&#x3D; other.overflowChars) &#123;</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars !&#x3D; other.overflowChars)</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/15/SoftWare/coderunner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/SoftWare/coderunner/" class="post-title-link" itemprop="url">coderunner使用问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-15 19:01:29 / 修改时间：19:14:44" itemprop="dateCreated datePublished" datetime="2021-09-15T19:01:29+08:00">2021-09-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CodeRunner本身是一个收费软件，功能强大，好处就不说了。在一些破解网站上可以找到破解版的，断网输入对应的激活码就能破解成功。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>每次重新打开，都需要重新破解。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>猜想的是每次打开CodeRunner时都会向其主站发送消息，查看是否激活，这里就是通过直接断开链接的方式来处理。</p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>Mac系统下打开<code>/private/etc/</code>文件，hosts是文本。</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>在hosts文件中，增加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CodeRunner App</span><br><span class="line">127.0.0.1 coderunnerapp.com</span><br></pre></td></tr></table></figure>

<p>这样就可以验证成功了，不需要每次都重新激活。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/" class="post-title-link" itemprop="url">nx-8-logos</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:27:26" itemprop="dateCreated datePublished" datetime="2021-09-13T16:27:26+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/" class="post-title-link" itemprop="url">nx-8-lldb</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:11:20" itemprop="dateCreated datePublished" datetime="2021-09-13T16:11:20+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/" class="post-title-link" itemprop="url">nx-7-hook</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 14:37:29" itemprop="dateCreated datePublished" datetime="2021-09-13T14:37:29+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">github-443解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-19 11:12:52" itemprop="dateCreated datePublished" datetime="2021-06-19T11:12:52+08:00">2021-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 14:06:47" itemprop="dateModified" datetime="2021-06-21T14:06:47+08:00">2021-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/github/" itemprop="url" rel="index"><span itemprop="name">github</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p>在使用github的时候，执行<code>git pull</code>或者<code>git push</code>时，经常会出现以下错误：</p>
<blockquote>
<p>【Failed to connect to github.com port 443: Operation timed out】</p>
</blockquote>
<p>这个时候就一通百度、google发现有解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意啊、这个是不行的</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>这个时候你可能觉得：OK终于解决了。</p>
<p>但是，可能再你下次使用的时候又会出现类似的问题，或者又有新的问题出现。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>打开网站：<a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></p>
<p><img src="step-1.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p>打开网站：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></p>
<p><img src="step-2.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><p>打开网站<a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></p>
<p><img src="step-3.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h2><p>打开系统host，进行编辑，我这里使用的是Mac，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<p><code>sudo</code>命令需要输入密码，之后，把我们上面打开的3个web对应的ip和host绑定，如下图：</p>
<p><img src="step-4.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ip            对应的host    </span><br><span class="line"># Github</span><br><span class="line">140.82.114.4    github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<p>ip以自己打开的那3个web显示的为准。Windows请自行百度如何操作host。</p>
<h2 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h2><p>如果设置了<code>http.proxy</code>和<code>https.proxy</code> http/https代理，需要取消代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h2><p>刷新DNS，如果机型不同，不起作用，请自行查看<a href="https://support.apple.com/zh-cn/HT202516" target="_blank" rel="noopener">还原OS X 中的DNS缓存</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;support.apple.com&#x2F;zh-cn&#x2F;HT202516</span><br></pre></td></tr></table></figure>

<p>到这里就可以正常使用了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">OC原理/oc-4-类的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-18 18:04:13" itemprop="dateCreated datePublished" datetime="2021-06-18T18:04:13+08:00">2021-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象、类对象、元类"><a href="#1-对象、类对象、元类" class="headerlink" title="1. 对象、类对象、元类"></a>1. 对象、类对象、元类</h1><h2 id="1-1-isa指向、superClass指向"><a href="#1-1-isa指向、superClass指向" class="headerlink" title="1.1 isa指向、superClass指向"></a>1.1 isa指向、superClass指向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#x2F;&#x2F;先把这里的协议注释掉，用到的时候再打开</span><br><span class="line">@protocol PersonProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *p_address;</span><br><span class="line"></span><br><span class="line">- (void)p_func1;</span><br><span class="line">+ (void)p_func1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_hobby;</span><br><span class="line">    CGFloat _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic) int age;</span><br><span class="line"></span><br><span class="line">- (void)func1;</span><br><span class="line">- (void)func2;</span><br><span class="line">+ (void)func3;</span><br><span class="line">+ (void)func4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后执行，直接打断点。</span><br><span class="line">Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">Teacher *t &#x3D; [[Teacher alloc] init];</span><br></pre></td></tr></table></figure>

<p>我们根据述代码进行分析，isa指针的指向。</p>
<blockquote>
<p>注意，这里是用的是模拟器</p>
</blockquote>
<h2 id="1-2-实例对象的isa"><a href="#1-2-实例对象的isa" class="headerlink" title="1.2 实例对象的isa"></a>1.2 实例对象的isa</h2><p>首先我们先看Person的实例p的isa指向情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先打印一下p的内存情况</span><br><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x1006460b0&gt;</span><br><span class="line">&#x2F;&#x2F; 输出p指针的情况</span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x1006460b0: 0x011d8001000083f9 0x0000000000000000</span><br><span class="line">0x1006460c0: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) p p 0x011d8001000083f9</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br></pre></td></tr></table></figure>

<p>这里拿到p指针指向的内存情况，我们知道第一块内存区域存放的是isa指针，直接打印的话，发现就是一串数字，啥也看不出来。还记得上一章中object_getClass反向验证isa指向最后的”&amp;”运算吗？<code>0x011d8001000083f9</code>这个值就是isa-&gt;bits，我们用它与<code>ISA_MASK</code>进行&amp;运算。因为这里是用的真机，所以<code>ISA_MASK = 0x00007ffffffffff8</code>，如果是用Mac或者模拟器，根据芯片类型判断是否是ARM64架构还是x86，然后使用对应的值进行换算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; p&#x2F;x输出内存的16进制</span><br><span class="line">(lldb) p&#x2F;x 0x011d8001000083f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $2 &#x3D; 0x00000001000083f8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里po就是Person类</span><br><span class="line">(lldb) po 0x00000001000083f8</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>打印出来是Person。所以isa指向的就是Person类。那我们做一下验证，直接通过<code>object_getClass</code>方法来找一下Person这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x object_getClass(p)</span><br><span class="line">(Class) $12 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>

<p>是不是发现，Person类的内存地址是一样的。如果再实例化一个p1，看p1-&gt;isa指向的和p-&gt;isa指向的是否是同一个Person类的内存地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接使用object_getClass获取类对象。</span><br><span class="line">lldb) p&#x2F;x object_getClass([Person alloc])</span><br><span class="line">(Class) $26 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>
<p>答案是肯定的，Person类在内存中只有一份，也就是说所有的类对象在内存中都只有一份。</p>
<h2 id="1-3-类对象的isa"><a href="#1-3-类对象的isa" class="headerlink" title="1.3 类对象的isa"></a>1.3 类对象的isa</h2><p>接下来，我们继续寻找Person类对象的isa指向情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083f8</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x0000000100645d60 0x0001803000000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 &#x3D; 0x00000001000083d0</span><br><span class="line">(lldb) po 0x00000001000083d0</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>发现Person类对象的isa指向的还是Person，但是这个Person所在的内存地址与Person类对象不一样。</p>
<p>这里就出现了元类的概念（Meta Class）。</p>
<h2 id="1-4-元类的isa"><a href="#1-4-元类的isa" class="headerlink" title="1.4 元类的isa"></a>1.4 元类的isa</h2><p>我们继续寻找元类的isa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0x00000001000083d0是Person元类所在的内存</span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083d0</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x0000000100714d10 0x0002e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $9 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到NSObject的地址继续x&#x2F;4gx</span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a0f0</span><br><span class="line">0x10036a0f0: 0x000000010036a0f0 0x000000010036a140</span><br><span class="line">0x10036a100: 0x00000001007877b0 0x0003e03100000007</span><br></pre></td></tr></table></figure>

<p>使用相同的方法找到元类的<code>isa</code>指向的是<code>NSObject</code>，这个<code>NSObject</code>是类对象吗？</p>
<p>对<code>NSObject</code>继续<code>x/4gx</code>发现<code>isa</code>锁指向的内存地址是一样的。</p>
<p>我们通过<code>object_getClass([[NSObject alloc] init])</code>来看看<code>NSObject</code>类对象的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取NSObject类的地址，与p&#x2F;x NSObject.class效果一致</span><br><span class="line">(lldb) p&#x2F;x object_getClass([NSObject alloc])</span><br><span class="line">(Class) $13 &#x3D; 0x000000010036a140 NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a140</span><br><span class="line">0x10036a140: 0x000000010036a0f0 0x0000000000000000</span><br><span class="line">0x10036a150: 0x0000000100786740 0x0002801000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从这里开始，就已经跟上面的内存地址重复了</span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $14 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>到这里，是不是看明白了点啥？<code>NSObject</code>类对象也有指向<code>NSObject</code>的元类，<code>Person</code>的元类的<code>isa</code>指向的是<code>NSObject</code>的元类。</p>
<h3 id="1-5-使用相同的办法查看Teacher的isa"><a href="#1-5-使用相同的办法查看Teacher的isa" class="headerlink" title="1.5 使用相同的办法查看Teacher的isa"></a>1.5 使用相同的办法查看Teacher的isa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里使用简单的方式，直接使用Teacher类</span><br><span class="line">(lldb) x&#x2F;4gx Teacher.class</span><br><span class="line">0x100008380: 0x00000001000083a8 0x00000001000083f8</span><br><span class="line">0x100008390: 0x0000000100362370 0x0000803000000000</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083a8 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $18 &#x3D; 0x00000001000083a8</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000001000083a8</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083a8</span><br><span class="line">0x1000083a8: 0x000000010036a0f0 0x00000001000083d0</span><br><span class="line">0x1000083b8: 0x0000000101138140 0x0001e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $20 &#x3D; 0x000000010036a0f0</span><br><span class="line">&#x2F;&#x2F; 这里又指向了NSObject</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>看到这里应该发现了点东西吧。实例对象的isa-&gt;类对象的isa-&gt;NSObject的isa，中间类对象与继承没有一丢丢关系。</p>
<h3 id="1-6-类的继承链"><a href="#1-6-类的继承链" class="headerlink" title="1.6 类的继承链"></a>1.6 类的继承链</h3><p>上面我们查看了isa的走向，接下来看一下继承链。首先看一下类的继承关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void testSuperClass(void)&#123;</span><br><span class="line">    Teacher *t &#x3D; [Teacher alloc];</span><br><span class="line">    Person  *p &#x3D; [Person alloc];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Teacher.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Person.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(NSObject.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里输出一下对应类的<code>superclass</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">NSObject</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>

<p>从打印出来的信息可以看到:</p>
<ul>
<li>Teacher   -&gt; superclass = Person</li>
<li>Person    -&gt; superClass = NSObject</li>
<li>NSObject  -&gt; superClass = null</li>
</ul>
<h3 id="1-7-元类的继承链"><a href="#1-7-元类的继承链" class="headerlink" title="1.7 元类的继承链"></a>1.7 元类的继承链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void testNSObject(void) &#123;</span><br><span class="line">    &#x2F;&#x2F; NSObject实例对象</span><br><span class="line">    NSObject *object1 &#x3D; [NSObject alloc];</span><br><span class="line">    &#x2F;&#x2F; NSObject类</span><br><span class="line">    Class cls &#x3D; object_getClass(object1);</span><br><span class="line">    &#x2F;&#x2F; NSObject元类</span><br><span class="line">    Class metaClass &#x3D; object_getClass(cls);</span><br><span class="line">    &#x2F;&#x2F; NSObject根元类</span><br><span class="line">    Class rootMetaClass &#x3D; object_getClass(metaClass);</span><br><span class="line">    &#x2F;&#x2F; NSObject根根元类</span><br><span class="line">    Class rootRootMetaClass &#x3D; object_getClass(rootMetaClass);</span><br><span class="line">    NSLog(@&quot;\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类&quot;,object1,cls,metaClass,rootMetaClass,rootRootMetaClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Person元类</span><br><span class="line">    Class pMetaClass &#x3D; object_getClass(Person.class);</span><br><span class="line">    Class psuperClass &#x3D; class_getSuperclass(pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,pMetaClass,pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,psuperClass,psuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Teacher -&gt; Person -&gt; NSObject</span><br><span class="line">    &#x2F;&#x2F; 元类也有一条继承链</span><br><span class="line">    Class tMetaClass &#x3D; object_getClass(Teacher.class);</span><br><span class="line">    Class tsuperClass &#x3D; class_getSuperclass(tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tMetaClass,tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tsuperClass,tsuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; NSObject 根类特殊情况</span><br><span class="line">    Class nsuperClass &#x3D; class_getSuperclass(NSObject.class);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,nsuperClass,nsuperClass);</span><br><span class="line">    &#x2F;&#x2F; 根元类 -&gt; NSObject</span><br><span class="line">    Class rnsuperClass &#x3D; class_getSuperclass(metaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,rnsuperClass,rnsuperClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下输出结果：</p>
<ol>
<li><p>首先输出的NSObject的isa走位。NSObject实例对象 -&gt; 类 -&gt; 元类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x10124ba40 实例对象</span><br><span class="line">0x10036a140 类</span><br><span class="line">0x10036a0f0 元类</span><br><span class="line">0x10036a0f0 根元类</span><br><span class="line">0x10036a0f0 根根元类</span><br></pre></td></tr></table></figure>

<p> 从这里的输出结果可以进一步判断出NSObject类对象的元类指向它自己。</p>
</li>
<li><p>Person类对象的元类 -&gt; super</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Person类对象的元类</span><br><span class="line">Person - 0x100008498</span><br><span class="line">&#x2F;&#x2F; Person类对象的元类 -&gt; super</span><br><span class="line">NSObject - 0x10036a0f0</span><br></pre></td></tr></table></figure>

<p> 从地址的打印信息可以看出来，person类的元类的super指向的是NSObject类的元类。</p>
</li>
<li><p>Teacher元类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Teacher类对象的元类</span><br><span class="line">Teacher - 0x100008470</span><br><span class="line">&#x2F;&#x2F; Teacher类对象的元类 -&gt; super</span><br><span class="line">Person - 0x100008498</span><br></pre></td></tr></table></figure>

<p> 从这里可以看出来，Teacher元类的super指向的Person的元类，地址信息都是相同的。</p>
</li>
</ol>
<p>从上面的流程可以看到，类的继承关系和对应元类的继承关系是相对应的。可以用一张图完美的诠释isa的走向和super的指向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="isa_metaclass.png" alt=""></p>
<ul>
<li>每个实例对象的isa指针指向与之对应的类对象(Class)。</li>
<li>每个类对象(Class)都有一个isa指针指向一个唯一的元类(Meta Class)。</li>
<li>每一个元类(Meta Class)的isa指针都指向最上层的元类(Meta Class)（图中的NSObject的Meta Class）。最上层的元类(Meta Class)的isa指针指向自己，形成一个回路。</li>
<li>每一个元类(Meta Class)的Super Class指向它原本Class的Super Class的Meta Class。最上层的Meta Class的Super Class指向NSObject Class本身。</li>
<li>最上层的NSObject Class的Super Class指向nil。</li>
<li>只有Class才有继承关系，实例对象与实例对象不存在继承关系。</li>
<li>每一个类对象(Class)在内存中都只有一份。</li>
</ul>
<h1 id="2-通过源码分析"><a href="#2-通过源码分析" class="headerlink" title="2. 通过源码分析"></a>2. 通过源码分析</h1><p>接下来我们从objc的源码上分析这些都是什么东西。</p>
<h2 id="2-1-实例对象-id（Instance）"><a href="#2-1-实例对象-id（Instance）" class="headerlink" title="2.1 实例对象 id（Instance）"></a>2.1 实例对象 id（Instance）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>id 这个struct的定义本身就带了 个 ＊, 所以我们在使用其他NSObject类型的实例时需要在前加上 ＊, 使 id 时却不用 。</p>
<p>什么是objc_object?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class. </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体, 在这个struct中有 个 isa 指针,指向它的类别 Class。 </p>
<h2 id="2-2-类对象-Class"><a href="#2-2-类对象-Class" class="headerlink" title="2.2 类对象 Class"></a>2.2 类对象 Class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>Class的本质就是一个<code>objc_class</code>的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意，这个源码是被简化之后的。</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    Class getSuperclass() const &#123;</span><br><span class="line">        return superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setSuperclass(Class newSuperclass) &#123;</span><br><span class="line">        superclass &#x3D; newSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 用这个是无法获取rw_t，只能通过内存偏移获取bits，然后再获取rw_t</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isRootClass() &#123;</span><br><span class="line">        return getSuperclass() &#x3D;&#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isRootMetaclass() &#123;</span><br><span class="line">        return ISA() &#x3D;&#x3D; (Class)this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体，大家可能会觉得不对，这个源码是错的，不是我们经常看到的，里头没有那些我们常说的变量，methodLists、ivars等等。<br>大家看仔细了哦，下面这个实现基本都是大家常看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;  </span><br><span class="line">    ...</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE</span><br></pre></td></tr></table></figure>
<p>里头确实有ivars、methodLists等，但是这个是<code>OBJC2_UNAVAILABLE</code>（我们目前使用的Objective-C的版本是2.0版本）。其内部确实有这些东西的，我们一步步去探究。</p>
<p>继续回到上面的结构体，发现ISA变量被注释掉了，其实也没有影响的，因为<code>objc_class</code> 继承自 <code>objc_object</code>（内部有isa变量）。那我们的属性、方法是存放在哪了呢？</p>
<p>通过查看源码，我们看到有这么一个属性<code>class_data_bits_t bits;</code>，这个东西里可能存放着我们需要的东西。稍后我们做验证。</p>
<h2 id="2-3-元类-Meta-Class"><a href="#2-3-元类-Meta-Class" class="headerlink" title="2.3 元类 Meta Class"></a>2.3 元类 Meta Class</h2><p>OC中一切皆为对象<br>Class在设计中本身也是一个对象,也有superclass。而这个Class对应的类我们叫“元类”（Meta Class）。也就是说Class中有一个isa指向的是Meta Class。</p>
<h1 id="3-验证属性、方法、协议存在的位置"><a href="#3-验证属性、方法、协议存在的位置" class="headerlink" title="3 验证属性、方法、协议存在的位置"></a>3 验证属性、方法、协议存在的位置</h1><h2 id="3-1-验证之前的准备-源码"><a href="#3-1-验证之前的准备-源码" class="headerlink" title="3.1 验证之前的准备 - 源码"></a>3.1 验证之前的准备 - 源码</h2><p>在2.2小结我们说了属性、方法、等可能存在于<code>class_data_bits_t</code>这个结构体内部，我们查看它的源码：</p>
<h3 id="3-1-1-class-data-bits-t"><a href="#3-1-1-class-data-bits-t" class="headerlink" title="3.1.1 class_data_bits_t"></a>3.1.1 class_data_bits_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">            return maybe_rw-&gt;ro();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">            return (class_ro_t *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在public的方法中有<code>class_rw_t* data()</code>这个方法，我们进一步探索：</p>
<h3 id="3-1-2-class-rw-t"><a href="#3-1-2-class-rw-t" class="headerlink" title="3.1.2 class_rw_t"></a>3.1.2 class_rw_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t witness;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint16_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实如我们所说的，这里确实存在着我们想要的东西：methods()、properties()、protocols()等。</p>
<p>那我们该怎么获取到这些数据，来证明这些就是我们想要的东西呢？</p>
<h3 id="3-1-3-内存偏移"><a href="#3-1-3-内存偏移" class="headerlink" title="3.1.3 内存偏移"></a>3.1.3 内存偏移</h3><p>我们知道在c语言中，一个数组，获取数组中的某个元素的值有多种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">printf(&quot;index 1 &#x3D; %d - %d&quot;, a[1], *(a+1));</span><br></pre></td></tr></table></figure>

<p>比如上面的代码，我们可以直接输出某个元素的下标，也可以通过内存地址来偏移进行读取，同样，我们也可以采取地址偏移来获取<code>objc_class-&gt;bits</code>的值。</p>
<p>需要偏移多少呢？</p>
<p>第一个变量是Class，这是一个结构体，内部有一个isa指针，所以这是8个字节。<br>第二个变量是cache_t，我们进源码看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">private:</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;    &#x2F;&#x2F; 8</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask;      &#x2F;&#x2F; 4</span><br><span class="line">#if __LP64__</span><br><span class="line">            uint16_t                   _flags;          &#x2F;&#x2F; 2</span><br><span class="line">#endif</span><br><span class="line">            uint16_t                   _occupied;       &#x2F;&#x2F; 2</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache; &#x2F;&#x2F; 8</span><br><span class="line">    &#125;;</span><br><span class="line">...   </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实这些就能算出来我们需要多少字节，我已经标好了。静态变量和方法是没有算在结构体内部的哈，而且cache_t内部有一个共用体，所以其所占用的空间一共是8，再加上<code>_bucketsAndMaybeMask</code>变量一共是16个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class ISA;              &#x2F;&#x2F; 8</span><br><span class="line">Class superclass;       &#x2F;&#x2F; 8</span><br><span class="line">cache_t cache;          &#x2F;&#x2F; 16</span><br><span class="line">class_data_bits_t bits;</span><br></pre></td></tr></table></figure>
<p>所以8+8+16 = 32个字节。</p>
<p>也就是我们获取到的<code>objc_class</code>的isa指针，然后偏移32个字节，也就是<code>0x20</code>。当然也可以直接通过lldb输出<code>sizeOf(cache_t)</code>来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $4 &#x3D; 16</span><br></pre></td></tr></table></figure>

<p>我们做一下验证，看看属性在哪。其实需要注意的一点是，我们要获取的是类对象，从类对象中查看我们的变量、方法和协议等，而不是从实例对象中获取，因为实例对象是已经在内存中了，比如属性已经有了具体的值了。</p>
<h3 id="3-1-4-method-array-t"><a href="#3-1-4-method-array-t" class="headerlink" title="3.1.4 method_array_t"></a>3.1.4 method_array_t</h3><p>我们继续跟踪源码，查看<code>method_array_t</code>是个啥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_array_t() : Super() &#123; &#125;</span><br><span class="line">    method_array_t(method_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *beginCategoryMethodLists() const &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *endCategoryMethodLists(Class cls) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们猜测我们想要的数据是在<code>method_list_t</code>中，而<code>method</code>就是我们的每一个的方法等结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    struct big &#123;</span><br><span class="line">        SEL name;</span><br><span class="line">        const char *types;</span><br><span class="line">        MethodListIMP imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">public:</span><br><span class="line">    big &amp;big() const &#123;</span><br><span class="line">        ASSERT(!isSmall());</span><br><span class="line">        return *(struct big *)this;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-1-5-property-array-t"><a href="#3-1-5-property-array-t" class="headerlink" title="3.1.5 property_array_t"></a>3.1.5 property_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class property_array_t : </span><br><span class="line">    public list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;property_t, property_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    property_array_t() : Super() &#123; &#125;</span><br><span class="line">    property_array_t(property_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同methods方法，我们看一下property_t</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-protocol-array-t"><a href="#3-1-6-protocol-array-t" class="headerlink" title="3.1.6 protocol_array_t"></a>3.1.6 protocol_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class protocol_array_t : </span><br><span class="line">    public list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    protocol_array_t() : Super() &#123; &#125;</span><br><span class="line">    protocol_array_t(protocol_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>这三个分别对应<code>methods()、properties()、protocols()</code>方法，里头也一个共同点就是<code>protocol_array_t</code>。那我们重点看一下list_array_tt的结构。</p>
<h3 id="3-1-7-list-array-tt"><a href="#3-1-7-list-array-tt" class="headerlink" title="3.1.7 list_array_tt"></a>3.1.7 list_array_tt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class list_array_tt &#123;</span><br><span class="line">    struct array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        Ptr&lt;List&gt; lists[0];</span><br><span class="line"></span><br><span class="line">        static size_t byteSize(uint32_t count) &#123;</span><br><span class="line">            return sizeof(array_t) + count*sizeof(lists[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t byteSize() &#123;</span><br><span class="line">            return byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">    &#x2F;&#x2F; 这是一个迭代器</span><br><span class="line">    class iterator &#123;</span><br><span class="line">        const Ptr&lt;List&gt; *lists;</span><br><span class="line">        const Ptr&lt;List&gt; *listsEnd;</span><br><span class="line">        typename List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 迭代器相关的方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    union &#123;</span><br><span class="line">        Ptr&lt;List&gt; list;</span><br><span class="line">        uintptr_t arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>list_array_tt</code>结构体大概的可以看出来，<code>list_array_tt</code>只是一个list的封装。以<code>property_array_t</code>为例：</p>
<p><code>list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</code>就是一个存放了<code>property_t</code>类型的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    Ptr&lt;List&gt; list;</span><br><span class="line">    uintptr_t arrayAndFlag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>union</code>共用体才是一个list_array_tt对外暴露的真是结构，一会我们通过lldb进行验证。</p>
<h1 id="4-lldb-验证属性存放的位置"><a href="#4-lldb-验证属性存放的位置" class="headerlink" title="4 lldb 验证属性存放的位置"></a>4 lldb 验证属性存放的位置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line">0x100008418: 0x00000001012042e4 0x00000001000b9970</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过指针偏移0x20，也就是0x1000083f8+0x20，加上强制转换</span><br><span class="line">(lldb) p (class_data_bits_t *)0x100008418</span><br><span class="line">(class_data_bits_t *) $1 &#x3D; 0x0000000100008418</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到变量bits之后，通过class_data_bits_t -&gt; data()函数获取rw_t</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 &#x3D; 0x00000001012042e0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 看一下class_rw_t都有哪些值</span><br><span class="line">(lldb) p *$2</span><br><span class="line">(class_rw_t) $4 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2156396544</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4295000480</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; Teacher</span><br><span class="line">  nextSiblingClass &#x3D; NSBinder</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果有Subclass，则会有firstSubclass&#x3D;Teacher，如果没有子类则是nil</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们在class_rw_t中已经查看过源码，可以通过properties()获取属性列表</span><br><span class="line">(lldb) p $2-&gt;properties()</span><br><span class="line">(const property_array_t) $5 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008320</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000864</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合我们上面分析的结果，<code>property_array_t</code>输出的数据与上方<code>list_array_tt</code>内部的<code>union</code>共用体的结构是一直的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取属性列表</span><br><span class="line">(lldb) p $5.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $6 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008320</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">(lldb) p $6.ptr</span><br><span class="line">(property_list_t *const) $7 &#x3D; 0x0000000100008320</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; $8也就是我们的ptr内存储的列表</span><br></pre></td></tr></table></figure>

<p>但是<code>entsize_list_tt</code>又是什么类型？我们又该通过那种方式来获取我们最后想要的property呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt;&#x3D; count);</span><br><span class="line">        return *PointerModifier::modify(*this, (Element *)((uint8_t *)this + sizeof(*this) + i*entsize()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 注意。这里有一个 【&amp;】符号，调用getOrEnd，返回的是一个指针，进行转换</span><br><span class="line">    Element&amp; get(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt; count);</span><br><span class="line">        return getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>entsize_list_tt</code>内部有get方法，来获取其中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $8.get(0)</span><br><span class="line">(property_t) $9 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $8.get(1)</span><br><span class="line">(property_t) $10 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) </span><br><span class="line">(lldb) p $8.get(2)</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br></pre></td></tr></table></figure>

<p>到这里，我们就输出了我们定义的2个属性，但是变量却没有在这里提现出来。我们继续看ivar存放在哪。</p>
<h1 id="5-lldb-成员变量"><a href="#5-lldb-成员变量" class="headerlink" title="5. lldb 成员变量"></a>5. lldb 成员变量</h1><p>从上面我们知道属性都存放在<code>class_rw_t</code>中，在查看<code>class_data_bits_t</code>源码的时候，也有看到<code>class_ro_t</code>。那ivar会不会就在这里呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class_data_bits_t 内部</span><br><span class="line"></span><br><span class="line">const class_ro_t *safe_ro() const &#123;</span><br><span class="line">    class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">    if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">        return maybe_rw-&gt;ro();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">        return (class_ro_t *)maybe_rw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    union &#123;</span><br><span class="line">        const uint8_t * ivarLayout;</span><br><span class="line">        Class nonMetaclass;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;const char *&gt; name;</span><br><span class="line">    &#x2F;&#x2F; With ptrauth, this is signed if it points to a small list, but</span><br><span class="line">    &#x2F;&#x2F; may be unsigned if it points to a big list.</span><br><span class="line">    void *baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    &#x2F;&#x2F; 这里存放的是ivars</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了获取property的经验，这里就方便多了，我们按照相同的方式来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $1 (class_data_bits_t *) </span><br><span class="line">(lldb) p $1-&gt;safe_ro()</span><br><span class="line">(const class_ro_t *) $11 &#x3D; 0x00000001000081a0</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(const class_ro_t) $12 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 0</span><br><span class="line">  instanceStart &#x3D; 8</span><br><span class="line">  instanceSize &#x3D; 40</span><br><span class="line">  reserved &#x3D; 0</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    ivarLayout &#x3D; 0x0000000000000000</span><br><span class="line">    nonMetaclass &#x3D; nil</span><br><span class="line">  &#125;</span><br><span class="line">  name &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;const char *&gt; &#x3D; &quot;Person&quot; &#123;</span><br><span class="line">      Value &#x3D; 0x0000000100003edc &quot;Person&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList &#x3D; 0x00000001000081e8</span><br><span class="line">  baseProtocols &#x3D; 0x0000000000000000</span><br><span class="line">  ivars &#x3D; 0x0000000100008298</span><br><span class="line">  weakIvarLayout &#x3D; 0x0000000000000000</span><br><span class="line">  baseProperties &#x3D; 0x0000000100008320</span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE &#x3D; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从打印中的内容可以大致的猜测ivar应该存放在ivars。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $11.ivars</span><br><span class="line">(const ivar_list_t *const) $13 &#x3D; 0x0000000100008298</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $11-&gt;ivars</span><br><span class="line">(lldb) p $11-&gt;ivars</span><br><span class="line">(const ivar_list_t *const) $14 &#x3D; 0x0000000100008298</span><br><span class="line">(lldb) p *$14</span><br><span class="line">(const ivar_list_t) $15 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;ivar_t, ivar_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 32, count &#x3D; 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与property list是相同的结构</span><br><span class="line">(lldb) p $15.get(0)</span><br><span class="line">(ivar_t) $16 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008360</span><br><span class="line">  name &#x3D; 0x0000000100003f06 &quot;_hobby&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(1)</span><br><span class="line">(ivar_t) $17 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008368</span><br><span class="line">  name &#x3D; 0x0000000100003f0d &quot;_height&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f6f &quot;d&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(2)</span><br><span class="line">(ivar_t) $18 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008370</span><br><span class="line">  name &#x3D; 0x0000000100003f15 &quot;_age&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f71 &quot;i&quot;</span><br><span class="line">  alignment_raw &#x3D; 2</span><br><span class="line">  size &#x3D; 4</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(3)</span><br><span class="line">(ivar_t) $19 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008378</span><br><span class="line">  name &#x3D; 0x0000000100003f1a &quot;_name&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>到这里，我们也获取到了变量的位置，也说明了定义的属性会默认生成带下划线的同名变量。</p>
<p>接下来就是方法了。</p>
<h1 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $20 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x00000001000081e8</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与属性一致</span><br><span class="line">(lldb) p $20.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $21 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x00000001000081e8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $21.ptr</span><br><span class="line">(method_list_t *const) $22 &#x3D; 0x00000001000081e8</span><br><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $23.get(0)</span><br><span class="line">(method_t) $24 &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照属性的方式继续输出，结果<code>$23.get(0)</code>输出的确实空内容。</p>
<p>在说method_t时，结构体内部有<code>big()</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $23.get(0).big()</span><br><span class="line">(method_t::big) $26 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func1&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c90 (AL-Objc&#96;-[Person func1])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(1).big()</span><br><span class="line">(method_t::big) $27 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func2&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cc0 (AL-Objc&#96;-[Person func2])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(2).big()</span><br><span class="line">(method_t::big) $28 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;name&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f53 &quot;@16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cf0 (AL-Objc&#96;-[Person name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(3).big()</span><br><span class="line">(method_t::big) $29 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setName:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f73 &quot;v24@0:8@16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d20 (AL-Objc&#96;-[Person setName:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(4).big()</span><br><span class="line">(method_t::big) $30 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;age&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f7e &quot;i16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d50 (AL-Objc&#96;-[Person age])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(5).big()</span><br><span class="line">(method_t::big) $31 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setAge:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f86 &quot;v20@0:8i16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d70 (AL-Objc&#96;-[Person setAge:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(6).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>我们在类中声明的方法都在<code>method_list_t</code>中，这里有我们自己声明的方法，还有属性自动生成的set和get方法。</p>
<p>发现这里并没有我们的类方法。因为类方法在元类里。</p>
<h1 id="7-类方法"><a href="#7-类方法" class="headerlink" title="7. 类方法"></a>7. 类方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取元类</span><br><span class="line">(lldb) p 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $33 &#x3D; 4295001040</span><br><span class="line">(lldb) po $33</span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;6gx $33</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x00000001006959d0 0x0002e03100000003</span><br><span class="line">0x1000083f0: 0x0000000101204304 0x00000001000083d0</span><br><span class="line">&#x2F;&#x2F; 获取元类的bits</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000083f0</span><br><span class="line">(class_data_bits_t *) $34 &#x3D; 0x00000001000083f0</span><br><span class="line">(lldb) p $34-&gt;data()</span><br><span class="line">(class_rw_t *) $35 &#x3D; 0x0000000101204300</span><br><span class="line">(lldb) p *$35</span><br><span class="line">(class_rw_t) $36 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2684878849</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4302330705</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; 0x00000001000083a8</span><br><span class="line">  nextSiblingClass &#x3D; 0x00007fff883ac410</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $35-&gt;methods()</span><br><span class="line">(const method_array_t) $37 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008168</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000424</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $37.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $38 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008168</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $38.ptr</span><br><span class="line">(method_list_t *const) $39 &#x3D; 0x0000000100008168</span><br><span class="line">(lldb) p *$39</span><br><span class="line">(method_list_t) $40 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; count &#x3D; 2告诉我们有2个</span><br><span class="line"></span><br><span class="line">(lldb) p $40.get(0).big()</span><br><span class="line">(method_t::big) $41 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func3&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c00 (AL-Objc&#96;+[Person func3])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(1).big()</span><br><span class="line">(method_t::big) $42 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func4&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c30 (AL-Objc&#96;+[Person func4])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(2).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>这里是获取类方法所在的位置。</p>
<h1 id="8-协议"><a href="#8-协议" class="headerlink" title="8 协议"></a>8 协议</h1><p>属性、变量、方法都已经有所了解，接下来看一下协议。把我们一开始注释的协议打开，重新运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000088d0: 0x00000001000088a8 0x000000010036a140</span><br><span class="line">0x1000088e0: 0x0000000100362370 0x0000803400000000</span><br><span class="line">0x1000088f0: 0x0000000100604204 0x00000001000b9970</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000088f0</span><br><span class="line">(class_data_bits_t *) $4 &#x3D; 0x00000001000088f0</span><br><span class="line">(lldb) p $4-&gt;data()</span><br><span class="line">(class_rw_t *) $5 &#x3D; 0x0000000100604200</span><br><span class="line">(lldb) p $5-&gt;protocols()</span><br><span class="line">(const protocol_array_t) $6 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008560</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001440</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $6.list</span><br><span class="line">(const RawPtr&lt;protocol_list_t&gt;) $7 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008560</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $7.ptr</span><br><span class="line">(protocol_list_t *const) $8 &#x3D; 0x0000000100008560</span><br><span class="line">(lldb) p *$8</span><br><span class="line">(protocol_list_t) $9 &#x3D; (count &#x3D; 1, list &#x3D; protocol_ref_t [] @ 0x00007ff5f7e1e9f8)</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>到此时，就不知道怎么处理，我们看一下<code>protocol_list_t</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    &#x2F;&#x2F; count is pointer-sized by accident.</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0]; &#x2F;&#x2F; variable-size</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是其内部的主要结构。我们用<code>list[0]</code>打印一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $9.list[0]</span><br><span class="line">(protocol_ref_t) $11 &#x3D; 4295002464</span><br></pre></td></tr></table></figure>

<p>上面我们已经说过<code>protocol_ref_t</code>只是一个定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>接下来强转一下，看是否可以转成<code>protocol_t *</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (protocol_t *)$11</span><br><span class="line">(protocol_t *) $12 &#x3D; 0x0000000100008960</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们查看protocol_t内部的结构有demangledName()方法.</span><br><span class="line">(lldb) p $12-&gt;demangledName()</span><br><span class="line">(const char *) $13 &#x3D; 0x0000000100003b51 &quot;PersonProtocol&quot;</span><br></pre></td></tr></table></figure>

<p>到这里呢，协议存放的位置也找到了。</p>
<h1 id="9-补充添加协议之后"><a href="#9-补充添加协议之后" class="headerlink" title="9. 补充添加协议之后"></a>9. 补充添加协议之后</h1><h2 id="9-1-多了4个属性"><a href="#9-1-多了4个属性" class="headerlink" title="9.1 多了4个属性"></a>9.1 多了4个属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $5-&gt;properties()</span><br><span class="line">(const property_array_t) $15 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008710</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001872</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $16 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008710</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $16.ptr</span><br><span class="line">(property_list_t *const) $17 &#x3D; 0x0000000100008710</span><br><span class="line">(lldb) p *$17</span><br><span class="line">(property_list_t) $18 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加协议之后，又返回去重新打印了一下属性列表，发现这里变成了7个。明明之前只有2个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前打印的数据</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上协议中定义的一个，加起来也才3个，为什么会变成7个？这7个又是哪个属性？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $18.get(0)</span><br><span class="line">(property_t) $19 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $18.get(1)</span><br><span class="line">(property_t) $20 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) p $18.get(2)</span><br><span class="line">(property_t) $21 &#x3D; (name &#x3D; &quot;p_address&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N&quot;)</span><br><span class="line">(lldb) p $18.get(3)</span><br><span class="line">(property_t) $22 &#x3D; (name &#x3D; &quot;hash&quot;, attributes &#x3D; &quot;TQ,R&quot;)</span><br><span class="line">(lldb) p $18.get(4)</span><br><span class="line">(property_t) $23 &#x3D; (name &#x3D; &quot;superclass&quot;, attributes &#x3D; &quot;T#,R&quot;)</span><br><span class="line">(lldb) p $18.get(5)</span><br><span class="line">(property_t) $24 &#x3D; (name &#x3D; &quot;description&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br><span class="line">(lldb) p $18.get(6)</span><br><span class="line">(property_t) $25 &#x3D; (name &#x3D; &quot;debugDescription&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br></pre></td></tr></table></figure>

<p>发现，添加了协议之后，会增加<code>hash、superclass、description、debugDescription</code>4个属性。是因为我们定义的协议都遵循<code>&lt;NSObject&gt;</code>协议，在<code>&lt;NSObject&gt;</code>协议内部有这4个属性的声明。</p>
<h2 id="9-2-方法找不到了"><a href="#9-2-方法找不到了" class="headerlink" title="9.2 方法找不到了"></a>9.2 方法找不到了</h2><p>我们按照上面获取方法等顺序，结果在最后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $3 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100722d01</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4302449921</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $4 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100722d01</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $4.ptr</span><br><span class="line">(method_list_t *const) $5 &#x3D; 0x0000000100722d01</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 0, count &#x3D; 2281701376)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在第6节的时候，输出过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共有7个，但是这里怎么变成了这么大的一个值？？？<br>有知道的大佬，欢迎指导，谢谢。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>添加协议之后<ul>
<li>多了4个属性</li>
<li>方法找不到了，待补充</li>
</ul>
</li>
</ul>
<p>这里我们以name的get方法为例子，说明一下这都是什么意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;</span><br></pre></td></tr></table></figure>

<p><img src="function_table.png" alt=""></p>
<blockquote>
<p>@16@0:8</p>
</blockquote>
<ul>
<li>‘@’：第一个@表示返回值，对象</li>
<li>‘16’：16个字节</li>
<li>‘@’：第二个@表示对象类型(id)</li>
<li>‘0’：我们知道@表示对象，0表示从0开始，占8个字节</li>
<li>‘:’：SEL，方法明</li>
<li>‘8’：表示从8开始，占8个字节，满足一共16个字节</li>
</ul>
<p>sel 和 imp<br>sel：方法名<br>imp：方法实现。函数指针地址</p>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>sel、imp的区别</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/" class="post-title-link" itemprop="url">nx-6-dyld</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 11:45:14" itemprop="dateCreated datePublished" datetime="2021-06-04T11:45:14+08:00">2021-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/" class="post-title-link" itemprop="url">MachO</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 11:11:58" itemprop="dateCreated datePublished" datetime="2021-06-02T11:11:58+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 11:44:46" itemprop="dateModified" datetime="2021-06-04T11:44:46+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h1><p>Mach-O其实是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式， 类似于windows上的PE格式 (Portable Executable )， linux上的elf格式 (Executable and Linking Format)。</p>
<p>Mach-O是一种用于可执行文件、目标代码、动态库的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性。</p>
<h1 id="MachO格式的常见文件"><a href="#MachO格式的常见文件" class="headerlink" title="MachO格式的常见文件"></a>MachO格式的常见文件</h1><ul>
<li>目标文件.o </li>
<li>库文件<ul>
<li>.a</li>
<li>.dylib</li>
<li>.Framework</li>
</ul>
</li>
<li>可执行文件<ul>
<li>dyld</li>
<li>.dsym</li>
</ul>
</li>
</ul>
<p>关于静态库、动态库，这里有一篇文章，写的很好。<br><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a></p>
<h2 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h2><p>可以通过clang命令把对应的文件编译成mach-o文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -c test.c</span><br></pre></td></tr></table></figure>

<p>就会出现一个test.o的文件，这个就是mach-o类型的文件。</p>
<p>可以通过file命令查看文件类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ file [文件路径]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比如：</span><br><span class="line">$ file test.o</span><br><span class="line">test.o: Mach-O 64-bit object x86_64</span><br></pre></td></tr></table></figure>

<p>说明test.o文件是Mach-O，64位的object，适用于x86架构，64位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译为可执行文件</span><br><span class="line">$ clang text.o</span><br></pre></td></tr></table></figure>

<p>这个命令会吧test.o文件转换为可执行文件，类型为.out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.out</span><br><span class="line">test.out: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure>

<p>text.out是一个可执行文件。</p>
<h2 id="clang编译多个文件"><a href="#clang编译多个文件" class="headerlink" title="clang编译多个文件"></a>clang编译多个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo test.c test1.c</span><br></pre></td></tr></table></figure>

<p>就是把<code>test.c</code>和<code>test1.c</code>两个文件合并为一个可执行文件demo</p>
<p>如果更改链接到顺序，则生成的可执行文件是不同的，md5值不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo1 test1.c test.c</span><br></pre></td></tr></table></figure>

<p>可以查看一下两个文件的md5值，是不同的，命令为<code>md5 [filename]</code>。</p>
<p>也可以通过<code>objdump</code>命令查看内容是否一样，这个命令类似于<code>MachOView</code>工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ objdump --macho -d [可执行文件file name]</span><br><span class="line">&#x2F;&#x2F; 查看demo可执行文件</span><br><span class="line">$ objdump --macho -d demo</span><br></pre></td></tr></table></figure>

<h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><p>dyld（the dynamic link editor）是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。</p>
<h2 id="dsym文件"><a href="#dsym文件" class="headerlink" title="dsym文件"></a>dsym文件</h2><p>当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。</p>
<p>在release下，编译之后查看dsym文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file file HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O dSYM companion file arm_v7] [arm64:Mach-O 64-bit dSYM companion file arm64]</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture armv7):	Mach-O dSYM companion file arm_v7</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture arm64):	Mach-O 64-bit dSYM companion file arm64</span><br></pre></td></tr></table></figure>

<p>这里出现了<code>universal binary</code>。这是个啥？就是通用二进制文件</p>
<h2 id="通用二进制文件"><a href="#通用二进制文件" class="headerlink" title="通用二进制文件"></a>通用二进制文件</h2><p>mac系统所支持的cpu及硬件平台发生了很大的变化，为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）,又称胖二进制（Fat Binary）。</p>
<ul>
<li>苹果公司提出的一种程序代码。能同时适用多种架构的二进制文件</li>
<li>同一个程序包中同时为多种架构提供最理想的性能。</li>
<li>因为需要储存多种代码，通用二进制应用程序通常比单一平台二进制的程序要大。但是由于两种架构有共通的非执行资源(代码以外的，图片等)，所以并不会达到单一版本的两倍之多。</li>
<li>而且由于执行中只调用一部分代码，运行起来也不需要额外的内存。</li>
</ul>
<p>在xcode中可以更改Mach-O Type：</p>
<p><img src="macho_xcode.jpg" alt=""></p>
<p>对于现在的Xcode来说，iOS11以上通过真机生成的可执行文件都是arm64架构，是单一架构。如果把最低版本修改为iOS10，重新真机编译，发现生成的可执行文件就是两种架构<code>armv7 + arm64</code>。</p>
<p>接下来，随便找个工程，release下编译，然后查看<code>HookDemo.app -&gt; HookDemo</code>可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file HookDemo</span><br><span class="line">HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O executable arm_v7] [arm64:Mach-O 64-bit executable arm64]</span><br><span class="line">HookDemo (for architecture armv7):	Mach-O executable arm_v7</span><br><span class="line">HookDemo (for architecture arm64):	Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>Targets -&gt; Build Setting - Architectures</code>修改架构，只不过目前来说都是arm64。可以添加armv7、armv7s。</p>
<p>armv7s是一种临时的支持iPhone5c上可用的架构。</p>
<p><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>
<p>原则上来说，架构都是向下兼容的。</p>
<h3 id="lipo命令拆分、合并通用二进制文件"><a href="#lipo命令拆分、合并通用二进制文件" class="headerlink" title="lipo命令拆分、合并通用二进制文件"></a>lipo命令拆分、合并通用二进制文件</h3><ul>
<li><p>查看Mach-O文件包含的架构信息</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info [MachO文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分某种架构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</span><br><span class="line">$ lipo HookDemo -thin armv7 -output HookDemo_armv7</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并多种架构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</span><br><span class="line">lipo -create HookDemo_armv7 HookDemo_arm64 -output HookDemo_v7_64</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以在通过file命令查看拆分、合并的文件。</p>
<h1 id="Macho文件结构"><a href="#Macho文件结构" class="headerlink" title="Macho文件结构"></a>Macho文件结构</h1><ul>
<li>Header ：包含该二进制文件的一般信息<ul>
<li>字节顺序、架构类型、加载指令的数量等。</li>
<li>使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么、文件类型是什么</li>
</ul>
</li>
<li>Load commands：包含加载所需要的指令（动态库、静态库等）<ul>
<li>内容包括区域的位置、符号表、动态符号表等</li>
</ul>
</li>
<li>Data ：内容包括区域的位置、符号表、动态符号表等<ul>
<li>包含Segement的具体数据</li>
</ul>
</li>
</ul>
<p><img src="macho_1.jpg" alt=""></p>
<p>接下来使用MachOView工具来分析可执行文件，有两种类型：</p>
<ol>
<li>通用二进制文件，则显示的是Fat Binary</li>
<li>单一架构的文件，直接显示对应的Executable</li>
</ol>
<p><img src="MachOView_Fat.jpg" alt=""></p>
<h2 id="Fat-Binary"><a href="#Fat-Binary" class="headerlink" title="Fat Binary"></a>Fat Binary</h2><p>在上图中可以看到，首先是一个Fat Header的结构。在header中，可以猜到两个架构之间必定存在某些关联。</p>
<p>armv7：offset=16384，size=79872<br>arm64：offset=98304，size=80672</p>
<p>arm64是从98304开始的，比armv7多了 98304-(16384+79872)=2048，这个值只是一个差值，而从偏移的差值来看98304-16384=81920 = 5 * 16 * 1024</p>
<p>正好是5页数据，iOS中1页是16k，所以armv7是5页数据，最后的2038只是第5页数据没有排满而已。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>接下来看看arm64架构下的内容：</p>
<p><img src="MachOView.png" alt=""></p>
<p>在Xcode中，我们可以在<code>loader.h</code>文件中找到Header的相关信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;      &#x2F;* 魔数，快速定位属于64还是32位 *&#x2F;</span><br><span class="line">    cpu_type_t  cputype;    &#x2F;* CPU类型 *&#x2F;</span><br><span class="line">    cpu_subtype_t   cpusubtype; &#x2F;* CPU的具体类型 *&#x2F;</span><br><span class="line">    uint32_t    filetype;   &#x2F;* 文件类型，比如可执行文件 *&#x2F;</span><br><span class="line">    uint32_t    ncmds;      &#x2F;* Load Commands的条数 *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds; &#x2F;* Load Commands的大小 *&#x2F;</span><br><span class="line">    uint32_t    flags;      &#x2F;* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 *&#x2F;</span><br><span class="line">    uint32_t    reserved;   &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只放了arm64下的内容，当然也有32位的，内容基本一致。<br>这里需要注意的是filettype类型，是一组宏定义，也能找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define	MH_OBJECT	0x1		&#x2F;* relocatable object file *&#x2F; object文件</span><br><span class="line">#define	MH_EXECUTE	0x2		&#x2F;* demand paged executable file *&#x2F; 可执行文件</span><br><span class="line">#define	MH_FVMLIB	0x3		&#x2F;* fixed VM shared library file *&#x2F;</span><br><span class="line">#define	MH_CORE		0x4		&#x2F;* core file *&#x2F;</span><br><span class="line">#define	MH_PRELOAD	0x5		&#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#define	MH_DYLIB	0x6		&#x2F;* dynamically bound shared library *&#x2F; dylib文件</span><br><span class="line">#define	MH_DYLINKER	0x7		&#x2F;* dynamic link editor *&#x2F;</span><br><span class="line">#define	MH_BUNDLE	0x8		&#x2F;* dynamically bound bundle file *&#x2F;</span><br><span class="line">#define	MH_DYLIB_STUB	0x9		&#x2F;* shared library stub for static</span><br><span class="line">					   linking only, no section contents *&#x2F;</span><br><span class="line">#define	MH_DSYM		0xa		&#x2F;* companion file with only debug</span><br><span class="line">					   sections *&#x2F; dsym文件</span><br><span class="line">#define	MH_KEXT_BUNDLE	0xb		&#x2F;* x86_64 kexts *&#x2F;</span><br><span class="line">#define MH_FILESET	0xc		&#x2F;* a file composed of other Mach-Os to</span><br><span class="line">					   be run in the same userspace sharing</span><br><span class="line">					   a single linkedit. *&#x2F;</span><br></pre></td></tr></table></figure>

<p>所以当看到0x2时，标识的就是可执行文件。在MachOView中，在Header中，可以看到对应的数据信息。</p>
<h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><table>
<thead>
<tr>
<th align="left">LoadCommands</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LC_SEGMENT_64</td>
<td align="left">将文件中（32位或64位）的段映射到进程地址空间中，<br>主要分为<strong>TEXT、</strong>DATA、LINKEDIT几大块</td>
</tr>
<tr>
<td align="left">LC_DYLD_INFO_ONLY</td>
<td align="left">动态链接相关信息</td>
</tr>
<tr>
<td align="left">LC_SYMTAB</td>
<td align="left">符号地址</td>
</tr>
<tr>
<td align="left">LC_DYSYMTAB</td>
<td align="left">动态符号表地址</td>
</tr>
<tr>
<td align="left">LC_LOAD_DYLINKER</td>
<td align="left">使用谁加载，我们使用dyld</td>
</tr>
<tr>
<td align="left">LC_UUID</td>
<td align="left">Mach-O文件的唯一识别标识 UUID</td>
</tr>
<tr>
<td align="left">LC_VERSION_MIN_MACOSX</td>
<td align="left">支持最低的操作系统版本</td>
</tr>
<tr>
<td align="left">LC_SOURCE_VERSION</td>
<td align="left">源代码版本</td>
</tr>
<tr>
<td align="left">LC_MAIN</td>
<td align="left">设置程序主线程的入口地址和栈大小<br>当别人的app做了防护时，运行就是闪退，这个时候就需要从这里找切入点</td>
</tr>
<tr>
<td align="left">LC_ENCRYPTION_INFO_64</td>
<td align="left">加密信息</td>
</tr>
<tr>
<td align="left">LC_LOAD_DYLIB</td>
<td align="left">依赖库的路径，包含三方库</td>
</tr>
<tr>
<td align="left">LC_FUNCTION_STARTS</td>
<td align="left">函数起始地址表</td>
</tr>
<tr>
<td align="left">LC_CODE_SIGNATURE</td>
<td align="left">代码签名</td>
</tr>
</tbody></table>
<h3 id="LC-SEGMENT-64"><a href="#LC-SEGMENT-64" class="headerlink" title="LC_SEGMENT_64"></a>LC_SEGMENT_64</h3><p>这里面包含了一些基本信息：</p>
<ul>
<li><code>VM Address</code>：虚拟内存地址</li>
<li><code>VM Size</code>：(虚拟内存)大小为4G</li>
<li><code>File Offset</code>：数据在文件中的偏移地址</li>
<li><code>File Size</code>：数据在文件中的大小</li>
</ul>
<h3 id="LC-DYLD-INFO-ONLY"><a href="#LC-DYLD-INFO-ONLY" class="headerlink" title="LC_DYLD_INFO_ONLY"></a>LC_DYLD_INFO_ONLY</h3><p>这里主要说一下<code>Rebase Info Offset</code>，这个是重定向的偏移地址。</p>
<p>系统为了安全，在运行时，把Mach-O放在虚拟内存中，会随机生成一个<code>ASLR</code>，在运行时会进行重定向，比如查找字符串、方法等，都需要重定向，而重定向的方式是<code>ASLR</code>+<code>Rebase Info Offset</code>的值。</p>
<h2 id="Section64"><a href="#Section64" class="headerlink" title="Section64"></a>Section64</h2><p>主要氛围两大部分：</p>
<p>###__TEXT</p>
<p>主要存放：代码、字符常量、类、方法等。</p>
<table>
<thead>
<tr>
<th align="left">Section</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__TEXT, __text</td>
<td align="left">主程序代码段</td>
</tr>
<tr>
<td align="left">__TEXT, __stubs</td>
<td align="left">Stub可以理解为一段占位空间，placeholder，用于符号的lazy binding。</td>
</tr>
<tr>
<td align="left">__TEXT, __stubs_helper</td>
<td align="left">辅助绑定</td>
</tr>
<tr>
<td align="left">__TEXT, __cstring</td>
<td align="left">C语言字符串</td>
</tr>
<tr>
<td align="left">__TEXT, __entitlements</td>
<td align="left">__entitlements</td>
</tr>
<tr>
<td align="left">__TEXT, __unwind_info</td>
<td align="left">C语言字符串</td>
</tr>
<tr>
<td align="left">__TEXT, __const</td>
<td align="left">常量段（const修饰）</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_classname</td>
<td align="left">OC的类名</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_methname</td>
<td align="left">OC方法名称</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_methtype</td>
<td align="left">OC方法类型，即方法签名</td>
</tr>
</tbody></table>
<h3 id="DATA"><a href="#DATA" class="headerlink" title="__DATA:"></a>__DATA:</h3><table>
<thead>
<tr>
<th align="left">Section</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__DATA_CONST, __got</td>
<td align="left">__got</td>
</tr>
<tr>
<td align="left">__DATA, __got</td>
<td align="left">__got</td>
</tr>
<tr>
<td align="left"><strong>DATA</strong>data</td>
<td align="left">已初始化的全局变量。static int a = 1;</td>
</tr>
<tr>
<td align="left">__DATA, __bss</td>
<td align="left">未初始化的静态变量。static int a;</td>
</tr>
<tr>
<td align="left">__DATA, __const</td>
<td align="left">常量。 char * const p = “foo”;</td>
</tr>
<tr>
<td align="left">__DATA, __cfstring</td>
<td align="left">字符串（CFStringRefs）</td>
</tr>
<tr>
<td align="left">__DATA, __common</td>
<td align="left">未初始化的外部全局变量。 int a;</td>
</tr>
<tr>
<td align="left">__DATA, __la_symbol_ptr</td>
<td align="left">懒绑定的符号指针表。</td>
</tr>
<tr>
<td align="left">__DATA, __nl_symbol_ptr</td>
<td align="left">非懒绑定的符号指针表。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_classlist</td>
<td align="left">OC的类列表，存储一个个指向objc_class结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_nlclslist</td>
<td align="left">OC的类列表，+load相关？</td>
</tr>
<tr>
<td align="left">__DATA, __objc_catlist</td>
<td align="left">OC的category列表，存储一个个指向__objc_category结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_protolist</td>
<td align="left">OC的协议列表，存储一个个指向protocol_t结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_imginfo</td>
<td align="left">OC的image信息</td>
</tr>
<tr>
<td align="left">__DATA, __objc_selrefs</td>
<td align="left">哪些SEL对应的字符串被引用了</td>
</tr>
<tr>
<td align="left">__DATA, __objc_classrefs</td>
<td align="left">类的引用，即msg_objSend相关</td>
</tr>
<tr>
<td align="left">__DATA, __objc_superrefs</td>
<td align="left">super引用，记录了super方法调用的类。<br>如ViewController中的viewDidLoad中调用了<code>[super viewDidLoad]</code>，<br>则ViewController class即被记录。<br>也可以理解为objc_msgSendSuper相关。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_protorefs</td>
<td align="left">协议引用</td>
</tr>
<tr>
<td align="left">__DATA, __objc_ivar</td>
<td align="left">成员变量</td>
</tr>
<tr>
<td align="left">__DATA, __objc_const</td>
<td align="left">这里的const与<code>__TEXT-&gt;const</code>完全不同。<br><code>__objc_const</code>指的是OC内存布局中的不可变部分，即class_ro_t类型。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_data</td>
<td align="left">保存类所需的数据？</td>
</tr>
</tbody></table>
<p>篇幅原因，动态加载以及符号表下一篇再介绍。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Mach-O简介</li>
<li>clang命令<ul>
<li>编译成点O文件：$ clang -c test.c</li>
<li>把点O文件编译为可执行文件：$ clang text.o</li>
<li>查看文件类型：$ file text.out</li>
</ul>
</li>
<li>lipo命令<ul>
<li>查看二进制文件 $ lipo -info [MachO文件]</li>
<li>拆分为某一种架构：$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</li>
<li>合并多种架构：$ lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</li>
</ul>
</li>
<li>MachO就结构<ul>
<li>Header<ul>
<li>用于快速群定该文件的CPU类型、文件类型</li>
</ul>
</li>
<li>Load Commands<ul>
<li>指示加载器如何设置并且加载二进制数据</li>
</ul>
</li>
<li>Section64<ul>
<li>存放数据：代码、数据、字符串常量、类、方法等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a><br><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/" class="post-title-link" itemprop="url">runloop</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 13:34:10" itemprop="dateCreated datePublished" datetime="2021-05-30T13:34:10+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:58" itemprop="dateModified" datetime="2021-05-31T10:29:58+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RunLoop是事件接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个RunLoop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。</p>
<p>RunLoop本质是一个 do-while循环，没事做就休息，来活了就干活。与普通的while循环是有区别的，普通的while循环会导致CPU进入忙等待状态，即一直消耗cpu，而RunLoop则不会，RunLoop是一种闲等待，即RunLoop具备休眠功能。</p>
<h2 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h2><ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（触摸、定时器、performSelector）</li>
<li>节省cpu资源，提供程序的性能，该做事就做事，该休息就休息</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>
<h2 id="runloop与线程"><a href="#runloop与线程" class="headerlink" title="runloop与线程"></a>runloop与线程</h2><p>通常情况下获取runloop的两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主运行循环</span><br><span class="line">CFRunLoopRef mainRunloop &#x3D; CFRunLoopGetMain();</span><br><span class="line">&#x2F;&#x2F; 当前运行循环</span><br><span class="line">CFRunLoopRef currentRunloop &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>

<p>接下来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    &#x2F;&#x2F; 这是一个静态变量</span><br><span class="line">    static CFRunLoopRef __main &#x3D; NULL; &#x2F;&#x2F; no retain needed</span><br><span class="line">    &#x2F;&#x2F; 没有获取到，则通过_CFRunLoopGet0函数去获取，参数是主线程</span><br><span class="line">    if (!__main) __main &#x3D; _CFRunLoopGet0(pthread_main_thread_np()); &#x2F;&#x2F; no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下<code>_CFRunLoopGet0</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如参数t不存在，则默认为主线程</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t &#x3D; pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建一个字典</span><br><span class="line">        CFMutableDictionaryRef dict &#x3D; CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        &#x2F;&#x2F; 创建mainLoop</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; dict : key value</span><br><span class="line">        &#x2F;&#x2F; 把main_thread和mainloop通过key-value的形式绑定</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从字典中通过线程获取run loop</span><br><span class="line">    CFRunLoopRef loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有则创建</span><br><span class="line">        CFRunLoopRef newLoop &#x3D; __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有loop也要存，存的是新创建的。</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop &#x3D; newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 &#x3D;&#x3D; _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出，runloo只有两种类型，一种主线程的mainloop，还有就是其它runloop。</p>
<h2 id="runloop的创建"><a href="#runloop的创建" class="headerlink" title="runloop的创建"></a>runloop的创建</h2><p>接下来看runloop是怎么创建的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    CFRunLoopRef loop &#x3D; NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size &#x3D; sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop &#x3D; (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</span><br><span class="line">    &#x2F;&#x2F; 如果loop为空，则直接返回NULL</span><br><span class="line">    if (NULL &#x3D;&#x3D; loop) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; runloop属性赋值</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort &#x3D; __CFPortAllocate();</span><br><span class="line">    if (CFPORT_NULL &#x3D;&#x3D; loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems &#x3D; NULL;</span><br><span class="line">    loop-&gt;_currentMode &#x3D; NULL;</span><br><span class="line">    loop-&gt;_modes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head &#x3D; NULL;</span><br><span class="line">    loop-&gt;_blocks_tail &#x3D; NULL;</span><br><span class="line">    loop-&gt;_counterpart &#x3D; NULL;</span><br><span class="line">    loop-&gt;_pthread &#x3D; t;</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    loop-&gt;_winthread &#x3D; GetCurrentThreadId();</span><br><span class="line">#else</span><br><span class="line">    loop-&gt;_winthread &#x3D; 0;</span><br><span class="line">#endif</span><br><span class="line">    rlm &#x3D; __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL !&#x3D; rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面又有了一个CFRunLoopRef,盲猜应该是结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            &#x2F;* locked for accessing mode list *&#x2F;</span><br><span class="line">    __CFPort _wakeUpPort;            &#x2F;&#x2F; used for CFRunLoopWakeUp</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              &#x2F;&#x2F; reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从定义中可以得出，一个RunLoop有多个Mode，意味着一个RunLoop需要处理多个事务，即一个Mode对应多个Item，而一个item中，包含了timer、source、observer，如图：</p>
<p><img src="runloop_1.jpg" alt=""></p>
<h3 id="mode类型"><a href="#mode类型" class="headerlink" title="mode类型"></a>mode类型</h3><p>其中mode在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code>和<code>NSRunLoopCommonModes</code>。</p>
<p><code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p>
<ul>
<li>NSDefaultRunLoopMode：默认的mode，正常情况下都是在这个mode</li>
<li>NSConnectionReplyMode</li>
<li>NSModalPanelRunLoopMode</li>
<li>NSEventTrackingRunLoopMode：使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</li>
<li>NSRunLoopCommonModes：伪模式，灵活性更好</li>
</ul>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><ul>
<li>Source0 表示 非系统事件，即用户自定义的事件</li>
<li>Source1 表示系统事件，主要负责底层的通讯，具备唤醒能力</li>
</ul>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入RunLoop</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),</span><br><span class="line">    &#x2F;&#x2F;即将处理Timers</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),</span><br><span class="line">    &#x2F;&#x2F;即将处理Source</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),</span><br><span class="line">    &#x2F;&#x2F;即将进入休眠</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),</span><br><span class="line">    &#x2F;&#x2F;被唤醒</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),</span><br><span class="line">    &#x2F;&#x2F;退出RunLoop</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mode对应的items"><a href="#mode对应的items" class="headerlink" title="mode对应的items"></a>mode对应的items</h3><ul>
<li>block：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></li>
<li>timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></li>
<li>source0： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></li>
<li>source1： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></li>
<li>主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></li>
<li>observer： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></li>
</ul>
<h3 id="以Timer为例"><a href="#以Timer为例" class="headerlink" title="以Timer为例"></a>以Timer为例</h3><p>在子线程创建的timer是没有办法一直执行的，而想让它继续执行，则需要添加到runloop中，并且run才行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">self.isStopping &#x3D; NO;</span><br><span class="line">NSThread *thread &#x3D; [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; thread.name &#x3D; nil 因为这个变量只是捕捉</span><br><span class="line">    &#x2F;&#x2F; LGThread *thread &#x3D; nil</span><br><span class="line">    &#x2F;&#x2F; thread &#x3D; 初始化 捕捉一个nil进来</span><br><span class="line">    NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">    NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;~~hello word&quot;);            &#x2F;&#x2F; 退出线程--结果runloop也停止了</span><br><span class="line">        if (self.isStopping) &#123;</span><br><span class="line">            [NSThread exit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">thread.name &#x3D; @&quot;lgcode.com&quot;;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<p>我们看一下addTimer是怎么操作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">oid CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</span><br><span class="line">    if (!__CFIsValid(rlt) || (NULL !&#x3D; rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop !&#x3D; rl)) return;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点 : kCFRunLoopCommonModes</span><br><span class="line">    if (modeName &#x3D;&#x3D; kCFRunLoopCommonModes) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是kCFRunLoopCommonModes 类型</span><br><span class="line">        CFSetRef set &#x3D; rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        </span><br><span class="line">        if (NULL &#x3D;&#x3D; rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            &#x2F;&#x2F; modeItems是空，则创建一个defalut</span><br><span class="line">            rl-&gt;_commonModeItems &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;runloop与mode 是一对多的， mode与item也是一对多的</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        if (NULL !&#x3D; set) &#123;</span><br><span class="line">            CFTypeRef context[2] &#x3D; &#123;rl, rlt&#125;;</span><br><span class="line">            &#x2F;* add new item to all common-modes *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;执行</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是非commonMode类型</span><br><span class="line">        &#x2F;&#x2F;查找runloop的模型</span><br><span class="line">        CFRunLoopModeRef rlm &#x3D; __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb &#x3D; kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal &#x3D; NULL;</span><br><span class="line">                rlm-&gt;_timers &#x3D; CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断mode是否匹配</span><br><span class="line">        if (NULL !&#x3D; rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop &#x3D; rl;</span><br><span class="line">            &#125; else if (rl !&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Normally we don&#39;t do this on behalf of clients, but for</span><br><span class="line">                &#x2F;&#x2F; backwards compatibility due to the change in timer handling...</span><br><span class="line">                if (rl !&#x3D; CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要目的就是把timer添加到对应的mode中。mode 和 item是一对多的关系，timer是item的一种。</p>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><p>接下来上源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    do &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是timer</span><br><span class="line">        else if (modeQueuePort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                &#x2F;&#x2F; Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是source1</span><br><span class="line">        CFRunLoopSourceRef rls &#x3D; __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            mach_msg_header_t *reply &#x3D; NULL;</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            if (NULL !&#x3D; reply) &#123;</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__CFRunLoopDoTimers源码，主要是通过for循环，对单个timer进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;循环遍历，做下层单个timer的执行</span><br><span class="line">    for (CFIndex idx &#x3D; 0, cnt &#x3D; timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt &#x3D; (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        Boolean did &#x3D; __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled &#x3D; timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mode and rl are locked on entry and exit</span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    Boolean timerHandled &#x3D; false;</span><br><span class="line">    uint64_t oldFireTSR &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* Fire a timer *&#x2F;</span><br><span class="line">    CFRetain(rlt);</span><br><span class="line">    __CFRunLoopTimerLock(rlt);</span><br><span class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;&#x3D; mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop &#x3D;&#x3D; rl) &#123;</span><br><span class="line">    __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">        __CFRunLoopTimerFireTSRLock();</span><br><span class="line">        oldFireTSR &#x3D; rlt-&gt;_fireTSR;</span><br><span class="line">        __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">        </span><br><span class="line">        __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        if (doInvalidate) &#123;</span><br><span class="line">            CFRunLoopTimerInvalidate(rlt);      &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        if (context_release) &#123;</span><br><span class="line">            context_release(context_info);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        __CFRunLoopTimerLock(rlt);</span><br><span class="line">        timerHandled &#x3D; true;</span><br><span class="line">        __CFRunLoopTimerUnsetFiring(rlt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在timer执行的位置打上断点，使用lldb -&gt; bt命令查看调用栈：</p>
<p><img src="runloop_2.jpg" alt=""></p>
<h3 id="timer的调用顺序"><a href="#timer的调用顺序" class="headerlink" title="timer的调用顺序"></a>timer的调用顺序</h3><ol>
<li>自定义的timer，设置Mode，并将其加入RunLoop中</li>
<li>在RunLoop的run方法执行时，会调用__CFRunLoopDoTimers执行所有timer</li>
<li>在__CFRunLoopDoTimers方法中，会通过for循环执行单个timer的操作</li>
<li>在__CFRunLoopDoTimer方法中，timer执行完毕后，会执行对应的timer回调函数</li>
</ol>
<p>是针对timer的执行分析，对于observer、block、source0、source1，其执行原理与timer是类似的</p>
<p><img src="runloop_3.jpg" alt=""></p>
<h1 id="runloop底层原理"><a href="#runloop底层原理" class="headerlink" title="runloop底层原理"></a>runloop底层原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.0e10 : 科学计数 1*10^10，很大的值</span><br><span class="line">        result &#x3D; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped !&#x3D; result &amp;&amp; kCFRunLoopRunFinished !&#x3D; result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runloop就是一个do-while循环。当stop或者执行完成之后，则退出循环。</p>
<p>看一下<code>CFRunLoopRunSpecific</code>的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内部函数，进入loop，seconds是一个很大的值</span><br><span class="line">    result &#x3D; __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来又回到<code>__CFRunLoopRun</code>的代码，上面提到的逻辑只是针对timer的，这里详细的说明一下，使用伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;核心函数</span><br><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;通过GCD开启一个定时器，然后开始跑圈</span><br><span class="line">    dispatch_source_t timeout_timer &#x3D; NULL;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    int32_t retVal &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;处理事务,即处理items</span><br><span class="line">    do &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理timer事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理Source事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 判断有无端口消息(Source1)</span><br><span class="line">        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理消息</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 等待被唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 被唤醒，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;else if (被GCD唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 处理gcd</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;else if (被source1唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 被Source1唤醒，处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunHandledSource;&#x2F;&#x2F;处理源</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunTimedOut;&#x2F;&#x2F;超时</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunFinished;&#x2F;&#x2F;结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整理一下runloop的整体流程如下：</p>
<p><img src="runloop_4.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
