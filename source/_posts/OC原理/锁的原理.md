---
title: 锁的原理
date: 2021-05-16 23:45:44
tags:
    - Objective-C,
    - iOS
categories:
    - OC原理
---

# 锁的分类

## 自旋锁

线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种`忙等待`。一旦获取了自旋锁，线程会`一直保持该锁`，直至显式释放自旋锁。

自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。在iOS中，声明属性，默认修饰符atomic，原子性操作自带一把自旋锁。

* OSSpinLock
* atomic


## 互斥锁

是一种用于`多线程`编程中，防止两条线程同时对`同一`公共资源(比如全局变量)进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成

这里属于互斥锁的有:

* NSLock
* @synchronized
* pthread_mutex 


## 条件锁

就是`条件变量`，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。
* NSCondition* NSConditionLock

## 递归锁

就是同一个线程可以加锁N次而`不会引发死锁`。递归锁是特殊的互斥锁，一种带有`递归性质的互斥锁`。* NSRecursiveLock* pthread_mutex(recursive)

## 信号量(semaphore)

是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。* dispatch_semaphore

## 总结：

基本的锁包括两大类：自旋锁和互斥锁，其它锁都是在这两种的封装。

# @synchronized 底层原理

我们把如下代码放在`main.m`文件中执行。

```
@synchronized (appDelegateClassName) {
    // 进行读写操作
}
```

我们通过xcrun的命令生成main.cpp文件之后，才看文件可以到@synchronized的内部逻辑。

```
id _sync_obj = (id)appDelegateClassName;
objc_sync_enter(_sync_obj);
try {
    struct _SYNC_EXIT { _SYNC_EXIT(id arg) : sync_exit(arg) {}
        ~_SYNC_EXIT() {
            objc_sync_exit(sync_exit);
        }
        id sync_exit;
    }
    _sync_exit(_sync_obj);

} catch (id e) {
    _rethrow = e;
}
```

这里有两个操作，看着像是我们要找的重点内容`objc_sync_enter`和`objc_sync_exit`。

为了以防万一，我们再汇编模式下debug一下代码。
在汇编模式下，同样发现了这两处代码。

```
libobjc.A.dylib`objc_sync_enter:

libobjc.A.dylib`objc_sync_exit:
```

并且这两处代码在libobjc.A.dylib中，这是个啥，感觉跟runtime的源码有点关系。是的，就是在runtime的源码中。接下来分析一下源码：

```

// Begin synchronizing on 'obj'. 
// Allocates recursive mutex associated with 'obj' if needed.
// Returns OBJC_SYNC_SUCCESS once lock is acquired.  
int objc_sync_enter(id obj)
{
    int result = OBJC_SYNC_SUCCESS;
    // 1. obj有值
    if (obj) {
        // 2. 生成SyncData类型的data，这是重点，注意参数ACQUIRE
        SyncData* data = id2data(obj, ACQUIRE);
        ASSERT(data);
        // 3. 加互斥锁
        data->mutex.lock();
    } else {
        // 4.
        // @synchronized(nil) does nothing
        if (DebugNilSync) {
            _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
        }
        objc_sync_nil();
    }

    return result;
}
```

我们一步步分析源码：

1. obj就是`@synchronized (self)`传进来的参数。有值的情况下会执行 2. 没有值则执行 4.
2. `SyncData`是一个结构体
3. 加锁
4. 执行`objc_sync_nil();`直接返回


我们先看一下`objc_sync_exit`的内部结构。

```
// End synchronizing on 'obj'. 
// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR
int objc_sync_exit(id obj)
{
    int result = OBJC_SYNC_SUCCESS;
    // 1. 判断是否有obj
    if (obj) {
        // 获取data，注意传的值的参数是RELEASE
        SyncData* data = id2data(obj, RELEASE); 
        if (!data) {
            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
        } else {
            // 有值的情况下，就进行解锁
            bool okay = data->mutex.tryUnlock();
            if (!okay) {
                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
            }
        }
    } else {
        // @synchronized(nil) does nothing
    }
    return result;
}
```

我们发现`objc_sync_exit`和`objc_sync_enter`的内部大同小异。主要的内容都是在`id2data`函数内部。

接下来，我们重点看一下这个函数：

![](id2data.jpg)

这个函数太大了，先把一些代码逻辑隐藏掉了，接着一步一步分析：


## SyncData 链表

```
typedef struct alignas(CacheLineSize) SyncData {
    struct SyncData* nextData;  // 指向下一个值，
    DisguisedPtr<objc_object> object;
    int32_t threadCount;  // number of THREADS using this block
    recursive_mutex_t mutex;
} SyncData;
```
    
1. `nextData`指向下一个值，类似与链表结构。
2. object：hash map的关联对象，就是`@synchronized (self)`中self这个参数。
3. threadCount：有多少个线程执行了这个block
4. mutex：这是一个递归锁，递归锁是互斥锁的一种

## SyncList

```
spinlock_t *lockp = &LOCK_FOR_OBJ(object);
SyncData **listp = &LIST_FOR_OBJ(object);
```

首先出现的就是spinlock_t类型的锁，通过`LOCK_FOR_OBJ(object)`来获取的。

```
struct SyncList {
    SyncData *data;
    spinlock_t lock;

    constexpr SyncList() : data(nil), lock(fork_unsafe_lock) { }
};

// Use multiple parallel lists to decrease contention among unrelated objects.
#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock
#define LIST_FOR_OBJ(obj) sDataLists[obj].data
static StripedMap<SyncList> sDataLists;
```

`SyncList`是一个结构体类型，内部有一个链表，`spinlock_t`是一个自旋锁。它存放的是一个总表。


`tls`：是一个线程缓存的表，通过set和get方法获取对应key的值。
* SYNC_DATA_DIRECT_KEY： 数据data对应的key
* SYNC_COUNT_DIRECT_KEY：锁的个数对应的key

```
typedef struct SyncCache {
    unsigned int allocated;
    unsigned int used;
    SyncCacheItem list[0];
} SyncCache;

typedef struct {
    SyncData *data;
    unsigned int lockCount;  // number of times THIS THREAD locked this block
} SyncCacheItem;
```

`SyncCache`也是一个结构体，主要作用是存储线程，内部有一个list数组，存储不同的线程。`list[0]`存放的是当前线程的SyncData链表。



# 引用

[objc源码](https://opensource.apple.com/tarballs/objc4/)