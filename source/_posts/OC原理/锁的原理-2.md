---
title: 锁的原理-2
date: 2021-05-19 22:01:16
tags:
    - Objective-C,
    - iOS
categories:
    - OC原理
---

# NSLock

老规矩，直接上代码：

```
NSLock *lock = [[NSLock alloc] init];
[lock lock];
```

之所以这么写，就是为了找到NSLock所在的底层库，我们在`[lock lock]`这一行打个断点，然后使用符号断点`symbolic breakpoint`添加一个`lock`的符号，全靠盲猜。因为使用符合断点是最有效的方法，有时候汇编也不一定能进去。

![](foundation_lock.jpg)

很容易就找到了，这是在foundation框架中的，但是这个框架是没有开源的，怎么搞呢？

还有swift源码哈~莫慌

在`NSLock.swift`文件中可以找到`NSLock`的类，下方代码对其做了删减。

```
open class NSLock: NSObject, NSLocking {
    internal var mutex = _MutexPointer.allocate(capacity: 1)
#if os(macOS) || os(iOS) || os(Windows)
    private var timeoutCond = _ConditionVariablePointer.allocate(capacity: 1)
    private var timeoutMutex = _MutexPointer.allocate(capacity: 1)
#endif
    // init 初始化，内部是pthread_mutex_init，是个互斥锁
    public override init() {
        pthread_mutex_init(mutex, nil)
#if os(macOS) || os(iOS)
        pthread_cond_init(timeoutCond, nil)
        pthread_mutex_init(timeoutMutex, nil)
#endif
    }
    // dealloc，析构方法
    deinit {
        pthread_mutex_destroy(mutex)
        mutex.deinitialize(count: 1)
        mutex.deallocate()
#if os(macOS) || os(iOS) || os(Windows)
        deallocateTimedLockData(cond: timeoutCond, mutex: timeoutMutex)
#endif
    }
    // 加锁
    open func lock() {
        pthread_mutex_lock(mutex)
    }
    // 解锁
    open func unlock() {
        pthread_mutex_unlock(mutex)
#if os(macOS) || os(iOS)
        // Wakeup any threads waiting in lock(before:)
        pthread_mutex_lock(timeoutMutex)
        pthread_cond_broadcast(timeoutCond)
        pthread_mutex_unlock(timeoutMutex)
#endif
    }
    // tryLock
    open func `try`() -> Bool {
        return pthread_mutex_trylock(mutex) == 0
    }
    //  lockBeforeDate
    open func lock(before limit: Date) -> Bool {
        if pthread_mutex_trylock(mutex) == 0 {
            return true
        }

#if os(macOS) || os(iOS) || os(Windows)
        return timedLock(mutex: mutex, endTime: limit, using: timeoutCond, with: timeoutMutex)
#endif
    }

    open var name: String?
}
```


这些方法在iOS中都可以找到，我们通过源码可以看到内部的实现逻辑。

```
@interface NSLock : NSObject <NSLocking> {
@private
    void *_priv;
}

- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;

@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));
```

NSLock内部调用的就是`pthread`的互斥锁。


首先我们运行一下下面对的代码：

```
NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *recursiveLock = [[NSRecursiveLock alloc] init];
for (int i = 0; i < 100; i ++) {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        // 1. lock位置 1
        //[lock lock];
        //[recursiveLock lock];
        // 这里定义了一个block
        static void(^testMethod)(int value);
        testMethod = ^(int value) {
            // 2. lock位置 2
            //[lock lock];
            //[recursiveLock lock];
            if (value > 0) {
                NSLog(@"i = %d, current value = %d", i, value);
                // block内部调用block，形成了嵌套-递归
                testMethod(value - 1);
            }
            //[lock unlock];
            //[recursiveLock unlock];
        };
        testMethod(10);
    });
}
```

我虽然把锁都写出来了。但是一开始的情况下，我们不加锁运行一下，看是怎么打印的。

![](lock-1.jpg)

打印出来的就是一堆无序的数字。

然后我们使用NSLock，把1处的lock打开，底部unlock也需要打开，再执行一下。

诶~~ 怎么还发生崩溃了呢？就是因为内部发生了递归调用，这个锁已经玩不了了。
那我们该用递归锁试一下，我们使用`NSRecursiveLock`再运行一下，把1处对应的lock打开。

![](lock-2.jpg)

这次没问题了哈~ 为啥呢？

# NSRecursiveLock

我们看一下NSRecursiveLock的源码是啥？

```
open class NSRecursiveLock: NSObject, NSLocking {
    internal var mutex = _RecursiveMutexPointer.allocate(capacity: 1)
#if os(macOS) || os(iOS) || os(Windows)
    private var timeoutCond = _ConditionVariablePointer.allocate(capacity: 1)
    private var timeoutMutex = _MutexPointer.allocate(capacity: 1)
#endif

    public override init() {
        super.init()
        var attrib = pthread_mutexattr_t()

        withUnsafeMutablePointer(to: &attrib) { attrs in
            pthread_mutexattr_init(attrs)
            pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE))
            pthread_mutex_init(mutex, attrs)
        }
#if os(macOS) || os(iOS)
        pthread_cond_init(timeoutCond, nil)
        pthread_mutex_init(timeoutMutex, nil)
#endif
    }
    
    deinit {
        pthread_mutex_destroy(mutex)
        
        mutex.deinitialize(count: 1)
        mutex.deallocate()
#if os(macOS) || os(iOS) || os(Windows)
        deallocateTimedLockData(cond: timeoutCond, mutex: timeoutMutex)
#endif
    }
    
    open func lock() {
        pthread_mutex_lock(mutex)
    }
    
    open func unlock() {
        pthread_mutex_unlock(mutex)
#if os(macOS) || os(iOS)
        // Wakeup any threads waiting in lock(before:)
        pthread_mutex_lock(timeoutMutex)
        pthread_cond_broadcast(timeoutCond)
        pthread_mutex_unlock(timeoutMutex)
#endif
    }
    
    open func `try`() -> Bool {
        return pthread_mutex_trylock(mutex) == 0
    }
    
    open func lock(before limit: Date) -> Bool {
        if pthread_mutex_trylock(mutex) == 0 {
            return true
        }

#if os(macOS) || os(iOS) || os(Windows)
        return timedLock(mutex: mutex, endTime: limit, using: timeoutCond, with: timeoutMutex)
#else
        guard var endTime = timeSpecFrom(date: limit) else {
            return false
        }
        return pthread_mutex_timedlock(mutex, &endTime) == 0
#endif
    }

    open var name: String?
}
```

嗯哼？？？怎么跟NSLock中的源码没有什么区别？在`init()`中有略微的不同

```
public override init() {
    super.init()
    var attrib = pthread_mutexattr_t()

    withUnsafeMutablePointer(to: &attrib) { attrs in
        pthread_mutexattr_init(attrs)
        // 设置互斥锁的类型 RECURSIVE（递归）
        pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE))
        pthread_mutex_init(mutex, attrs)
    }
#if os(macOS) || os(iOS)
    pthread_cond_init(timeoutCond, nil)
    pthread_mutex_init(timeoutMutex, nil)
#endif
}
```

这下就清晰了，NSRecursiveLock在内部是一个互斥锁设置了递归的类型，只有这一点点的区别，就导致上方的代码运行出现那么大的区别。

### lock的位置

我们继续看上方的代码，把lock的位置放在2.的位置。分别打开NSLock和NSRecursiveLock看看有什么不同：

1. 打开NSLock
    
    ```
    2021-05-20 00:05:11.816871+0800 LockDemo[10150:520495] i = 0, current value = 10
    ```
    
    只有一条输出？
    
    因为`NSLock`只是一个互斥锁，执行了`lock`操作之后，就必须等待`unlock`才能继续执行，否则就一直等待。
    
1. 打开NSRecursiveLock
    
    ![](lock-3.jpg)

    竟然发生了crash，但是current value的值是有序的，i的值却是无序的，这是个啥情况？
    
    也就是说，递归锁我用了，但是递归执行中，跑偏了~造成了锁内部发生了错乱，导致了crash。
    
所以啊，别总乱加锁。那么有人可能会说，我直接在调用的时候加锁不就可以了吗，还很省事，不用担心发生crash。

```
[lock lock];
testMethod(10);
[lock unlock];
```

肯定不行啊，这样只是控制了，递归调用不会出现问题，但是i的值呢？

![](lock-4.jpg)

不管你这这里使用NSLock或NSRecursiveLock都是一样的效果。所以，这种情况，我们经常会使用`@synchronized (self)`，不用管什么时候加锁和什么时候解锁，也不用担心会发生等待、崩溃。而且性能上，并没有差多少。

```
testMethod = ^(int value) {
    @synchronized (self) {
        if (value > 0) {
            NSLog(@"i = %d, current value = %d", i, value);
            testMethod(value - 1);
        }
    }
}
```