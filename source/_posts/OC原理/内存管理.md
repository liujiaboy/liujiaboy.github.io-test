---
title: å†…å­˜ç®¡ç†
date: 2021-05-29 19:35:15
tags:
    - Objective-C,
    - iOS
categories:
    - OCåŸç†
---


# å†…å­˜ç®¡ç†æ–¹æ¡ˆ
1. ARC/MRC
2. TarggedPointer: ä¸“é—¨ç”¨æ¥å¤„ç†å°å¯¹è±¡ï¼Œæ¯”å¦‚NSNumberã€NSDateã€ï¼ˆNSStringä¸­æœ‰ä¸€ç§æ˜¯targeed pointerï¼‰
3. Nonpointer_isaï¼šéæŒ‡é’ˆç±»å‹çš„isaã€‚ä¸»è¦ç”¨æ¥ä¼˜åŒ–64ä½åœ°å€ã€‚
4. SideTablesï¼šæ•£åˆ—è¡¨ã€‚ä¸»è¦æœ‰ä¸¤ç§ç±»å‹çš„è¡¨ï¼Œå¼•ç”¨è®¡æ•°è¡¨ï¼Œå¼±å¼•ç”¨è¡¨ã€‚

```
// viewDidLoadæ·»åŠ 
- (void)taggedPointerDemo {
  self.queue = dispatch_queue_create("com.cjl.cn", DISPATCH_QUEUE_CONCURRENT);
    
    for (int i = 0; i<10000; i++) {
        dispatch_async(self.queue, ^{
            // allocå †ä¸Šï¼ŒiOSä¼˜åŒ–ä¹‹åå˜æˆ taggedpointer
            // nameStræ˜¯NSTaggedPointerString
            self.nameStr = [NSString stringWithFormat:@"aaa"];  
             NSLog(@"%@",self.nameStr);
        });
    }
}

// ç‚¹å‡»
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    NSLog(@"æ¥äº†");
    for (int i = 0; i<10000; i++) {
        dispatch_async(self.queue, ^{
            // nameStræ˜¯NSCFString
            self.nameStr = [NSString stringWithFormat:@"aa-åŠ æ²¹"];
            NSLog(@"%@",self.nameStr);
        });
    }
}
```

è¿è¡Œä¸Šé¢çš„ä»£ç å•Šï¼Œå‘ç°åœ¨`taggedPointerDemo`æ–¹æ³•ä¸­æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯ç‚¹å‡»å±å¹•ï¼Œæ‰§è¡Œäº†touchesBeganå°±å‘ç”Ÿäº†å´©æºƒã€‚è™½ç„¶åœ¨å¤šçº¿ç¨‹æ—¶æœ‰è¿‡ç±»ä¼¼çš„ä¾‹å­ï¼Œæ˜¯ç”±äºå¤šæ¬¡é‡Šæ”¾é€ æˆçš„ã€‚ä½†æ˜¯è¿™é‡Œçš„æ ¹æœ¬åŸå› æ˜¯`nameStr`åœ¨åº•å±‚çš„ç±»å‹ä¸ä¸€è‡´å¯¼è‡´çš„ï¼Œåˆ†åˆ«åœ¨ä¸¤ä¸ªèµ‹å€¼çš„æ–¹æ³•å¤„æ‰“ä¸Šæ–­ç‚¹ï¼Œçœ‹çœ‹æ˜¯ä»€ä¹ˆç±»å‹ã€‚

* taggedPointerDemoæ–¹æ³•ä¸­çš„nameStrç±»å‹æ˜¯ NSTaggedPointerStringï¼Œå­˜å‚¨åœ¨å¸¸é‡åŒºã€‚å› ä¸ºnameStråœ¨allocåˆ†é…æ—¶åœ¨å †åŒºï¼Œç”±äºè¾ƒå°ï¼Œæ‰€ä»¥ç»è¿‡xcodeä¸­iOSçš„ä¼˜åŒ–ï¼Œæˆäº†NSTaggedPointerStringç±»å‹ï¼Œå­˜å‚¨åœ¨å¸¸é‡åŒºã€‚
* touchesBeganæ–¹æ³•ä¸­çš„nameStrç±»å‹æ˜¯ NSCFStringç±»å‹ï¼Œå­˜å‚¨åœ¨å †ä¸Š

## NSStringçš„ç±»å‹

1. NSCFConstantStringï¼šå­—ç¬¦ä¸²å¸¸é‡ï¼Œæ˜¯ä¸€ç§ç¼–è¯‘æ—¶å¸¸é‡ï¼ŒretainCountå€¼å¾ˆå¤§ï¼Œå¯¹å…¶æ“ä½œï¼Œä¸ä¼šå¼•èµ·å¼•ç”¨è®¡æ•°å˜åŒ–ï¼Œå­˜å‚¨åœ¨å­—ç¬¦ä¸²å¸¸é‡åŒºã€‚
2. NSCFStringï¼šæ˜¯åœ¨è¿è¡Œæ—¶åˆ›å»ºçš„NSStringå­ç±»ï¼Œåˆ›å»ºåå¼•ç”¨è®¡æ•°ä¼šåŠ 1ï¼Œå­˜å‚¨åœ¨å †ä¸Šã€‚
3. NSTaggedPointerStringï¼šæ ‡ç­¾æŒ‡é’ˆï¼Œæ˜¯è‹¹æœåœ¨64ä½ç¯å¢ƒä¸‹å¯¹NSStringã€NSNumberç­‰å¯¹è±¡åšçš„ä¼˜åŒ–ã€‚å¯¹äºNSStringå¯¹è±¡æ¥è¯´ï¼Œå½“å­—ç¬¦ä¸²æ˜¯ç”±æ•°å­—ã€è‹±æ–‡å­—æ¯ç»„åˆä¸”é•¿åº¦å°äºç­‰äº9æ—¶ï¼Œä¼šè‡ªåŠ¨æˆä¸ºNSTaggedPointerStringç±»å‹ï¼Œå­˜å‚¨åœ¨å¸¸é‡åŒºã€‚
4. å½“æœ‰ä¸­æ–‡æˆ–è€…å…¶ä»–ç‰¹æ®Šç¬¦å·æ—¶ï¼Œä¼šç›´æ¥æˆä¸º__NSCFStringç±»å‹ï¼Œå­˜å‚¨åœ¨å †åŒºã€‚


## Tagged Pointerå°å¯¹è±¡

æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹tagged pointerå¯¹è±¡çš„å¼•ç”¨è®¡æ•°ç›¸å…³é€»è¾‘ã€‚ç›´æ¥ä¸Šæºç ï¼š

`void objc_setProperty` -> `reallySetProperty`ã€‚

```
static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    id oldValue;
    id *slot = (id*) ((char*)self + offset);

    // copyå’ŒmutableCopyå¤„ç†
    if (copy) {
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        if (*slot == newValue) return;
        // retainæ“ä½œ
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
        spinlock_t& slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }
    // releaseæ“ä½œ
    objc_release(oldValue);
}
```

æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹retainå’Œreleaseå†…éƒ¨åšäº†ä»€ä¹ˆ

```
__attribute__((aligned(16), flatten, noinline))
id 
objc_retain(id obj)
{
    if (!obj) return obj;
    //åˆ¤æ–­æ˜¯å¦æ˜¯å°å¯¹è±¡ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ç›´æ¥è¿”å›å¯¹è±¡
    if (obj->isTaggedPointer()) return obj;
    //å¦‚æœä¸æ˜¯å°å¯¹è±¡ï¼Œåˆ™retain
    return obj->retain();
}

//****************objc_release****************
__attribute__((aligned(16), flatten, noinline))
void 
objc_release(id obj)
{
    if (!obj) return;
    //å¦‚æœæ˜¯å°å¯¹è±¡ï¼Œåˆ™ç›´æ¥è¿”å›
    if (obj->isTaggedPointer()) return;
    //å¦‚æœä¸æ˜¯å°å¯¹è±¡ï¼Œåˆ™release
    return obj->release();
}
```

å¦‚æœæ˜¯Tagged Pointerå°å¯¹è±¡ï¼Œä¸ä¼šå¯¹å¼•ç”¨è®¡æ•°åšå¤„ç†ã€‚

### å°å¯¹è±¡åœ°å€åˆ†æ

```
NSString *str1 = [NSString stringWithFormat:@"a"];
NSString *str2 = [NSString stringWithFormat:@"å•Š"];
NSLog(@"%p-%@",str1,str1);
NSLog(@"%p-%@",str2,str2);
```

çœ‹ä¸€ä¸‹è¾“å‡ºç»“æœï¼š

```
0xd3c9816ac08c01c6-a
0x6000033631e0-å•Š
```

åœ¨ç±»çš„åŠ è½½æ—¶ï¼Œå…¶ä¸­çš„_read_imagesæºç æœ‰ä¸€ä¸ªæ–¹æ³•å¯¹å°å¯¹è±¡è¿›è¡Œäº†å¤„ç†ï¼Œå³initializeTaggedPointerObfuscatoræ–¹æ³•ã€‚

æŸ¥çœ‹ä¸€ä¸‹æºç ï¼š`_read_images` -> `initializeTaggedPointerObfuscator`ã€‚

```
static void
initializeTaggedPointerObfuscator(void)
{
    if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) ||
        // Set the obfuscator to zero for apps linked against older SDKs,
        // in case they're relying on the tagged pointer representation.
        DisableTaggedPointerObfuscation) {
        objc_debug_taggedpointer_obfuscator = 0;
    } else {
        // Pull random data into the variable, then shift away all non-payload bits.
        arc4random_buf(&objc_debug_taggedpointer_obfuscator,
                       sizeof(objc_debug_taggedpointer_obfuscator));
        // _OBJC_TAG_MASK è¿›è¡Œæ··æ·†
        objc_debug_taggedpointer_obfuscator &= ~_OBJC_TAG_MASK;
    }
}
```

å…¨å±€æœç´¢`objc_debug_taggedpointer_obfuscator`ï¼Œæ‰¾åˆ°äº†encodeå’Œdecodeæ–¹æ³•ã€‚åˆ†åˆ«æ˜¯å¯¹tagged pointerçš„ç¼–ç å’Œè§£ç ã€‚

```
static inline void * _Nonnull
_objc_encodeTaggedPointer(uintptr_t ptr)
{
    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);
}

static inline uintptr_t
_objc_decodeTaggedPointer(const void * _Nullable ptr)
{
    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;
}
```

encodeæ—¶è¿›è¡Œäº†ä¸€æ¬¡`^`æ“ä½œï¼Œdecodeæ—¶ä¹Ÿè¿›è¡Œäº†ä¸€æ¬¡`^`æ“ä½œã€‚å¯ä»¥å¯¹å€¼è¿›è¡Œè¿˜åŸã€‚

é‚£æˆ‘ä»¬åˆ†åˆ«æ‰“å°ä¸€ä¸‹decodeåçš„å€¼ï¼š

```
NSString *str1 = [NSString stringWithFormat:@"a"];
NSLog(@"%p-%@",str1,str1);
NSLog(@"0x%lx",_objc_decodeTaggedPointer_(str1));

NSNumber *number1 = @1;
NSLog(@"%@-%p-%@",object_getClass(number1),number1,number1);
NSLog(@"0x%lx",_objc_decodeTaggedPointer_(number3));
```

è¾“å‡ºç»“æœï¼š

```
0xe4742f5bd16235e6-a
0xa000000000000611

__NSCFNumber-0xf4742f5bd16233e5-1
0xb000000000000012
```

åœ¨æºç ä¸­æœ‰ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶ï¼Œæ˜¯å¦ä¸ºTaggedPointerï¼š

```
static inline bool 
_objc_isTaggedPointer(const void * _Nullable ptr)
{
    //ç­‰ä»·äº ptr & 1å·¦ç§»63ï¼Œå³2^63ï¼Œç›¸å½“äºé™¤äº†64ä½ï¼Œå…¶ä»–ä½éƒ½ä¸º0ï¼Œå³åªæ˜¯ä¿ç•™äº†æœ€é«˜ä½çš„å€¼
    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}
```

æ‰€ä»¥0xaã€0xbä¸»è¦æ˜¯ç”¨äºåˆ¤æ–­æ˜¯å¦æ˜¯å°å¯¹è±¡taggedpointerï¼Œå³åˆ¤æ–­æ¡ä»¶ï¼Œåˆ¤æ–­ç¬¬64ä½ä¸Šæ˜¯å¦ä¸º1ï¼ˆtaggedpointeræŒ‡é’ˆåœ°å€å³è¡¨ç¤ºæŒ‡é’ˆåœ°å€ï¼Œä¹Ÿè¡¨ç¤ºå€¼ï¼‰

0xa è½¬æ¢æˆäºŒè¿›åˆ¶ä¸º 1 010ï¼ˆ64ä¸ºä¸º1ï¼Œ63~61åä¸‰ä½è¡¨ç¤º tagTypeç±»å‹ - 2ï¼‰ï¼Œè¡¨ç¤ºNSStringç±»å‹

0xb è½¬æ¢ä¸ºäºŒè¿›åˆ¶ä¸º 1 011ï¼ˆ64ä¸ºä¸º1ï¼Œ63~61åä¸‰ä½è¡¨ç¤º tagTypeç±»å‹ - 3ï¼‰ï¼Œè¡¨ç¤ºNSNumberç±»å‹ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œå¦‚æœNSNumberçš„å€¼æ˜¯-1ï¼Œå…¶åœ°å€ä¸­çš„å€¼æ˜¯ç”¨è¡¥ç è¡¨ç¤ºçš„

è¿™é‡Œå¯ä»¥é€šè¿‡_objc_makeTaggedPointeræ–¹æ³•çš„å‚æ•°tagç±»å‹objc_tag_index_tè¿›å…¥å…¶æšä¸¾ï¼Œå…¶ä¸­ 2è¡¨ç¤ºNSStringï¼Œ3è¡¨ç¤ºNSNumber

```
#if __has_feature(objc_fixed_enum)  ||  __cplusplus >= 201103L
enum objc_tag_index_t : uint16_t
#else
typedef uint16_t objc_tag_index_t;
enum
#endif
{
    // 60-bit payloads
    OBJC_TAG_NSAtom            = 0, 
    OBJC_TAG_1                 = 1, 
    OBJC_TAG_NSString          = 2,     // NSString
    OBJC_TAG_NSNumber          = 3,     // NSNumber
    OBJC_TAG_NSIndexPath       = 4, 
    OBJC_TAG_NSManagedObjectID = 5, 
    OBJC_TAG_NSDate            = 6,

    // 60-bit reserved
    OBJC_TAG_RESERVED_7        = 7, 

    // 52-bit payloads
    OBJC_TAG_Photos_1          = 8,
    OBJC_TAG_Photos_2          = 9,
    OBJC_TAG_Photos_3          = 10,
    OBJC_TAG_Photos_4          = 11,
    OBJC_TAG_XPC_1             = 12,
    OBJC_TAG_XPC_2             = 13,
    OBJC_TAG_XPC_3             = 14,
    OBJC_TAG_XPC_4             = 15,
    OBJC_TAG_NSColor           = 16,
    OBJC_TAG_UIColor           = 17,
    OBJC_TAG_CGColor           = 18,
    OBJC_TAG_NSIndexSet        = 19,

    OBJC_TAG_First60BitPayload = 0, 
    OBJC_TAG_Last60BitPayload  = 6, 
    OBJC_TAG_First52BitPayload = 8, 
    OBJC_TAG_Last52BitPayload  = 263, 

    OBJC_TAG_RESERVED_264      = 264
};
```

è·Ÿæˆ‘ä»¬ä¸Šé¢å¾—åˆ°çš„ç»“æœæ˜¯ä¸€æ ·çš„ã€‚

## æ€»ç»“

* Tagged Pointerå°å¯¹è±¡ç±»å‹ï¼ˆç”¨äºå­˜å‚¨NSNumberã€NSDateã€å°NSStringï¼‰ï¼Œå°å¯¹è±¡æŒ‡é’ˆä¸å†æ˜¯ç®€å•çš„åœ°å€ï¼Œè€Œæ˜¯åœ°å€ + å€¼ï¼Œå³çœŸæ­£çš„å€¼ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªæŠ«ç€å¯¹è±¡çš®çš„æ™®é€šå˜é‡è€Œä»¥ã€‚æ‰€ä»¥å¯ä»¥ç›´æ¥è¿›è¡Œè¯»å–ã€‚ä¼˜ç‚¹æ˜¯å ç”¨ç©ºé—´å°ï¼ŒèŠ‚çœå†…å­˜
* Tagged Pointerå°å¯¹è±¡ ä¸ä¼šè¿›å…¥retain å’Œ releaseï¼Œæ„å‘³ç€ä¸éœ€è¦ARCè¿›è¡Œç®¡ç†ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è¢«ç³»ç»Ÿè‡ªä¸»çš„é‡Šæ”¾å’Œå›æ”¶ã€‚
* Tagged Pointerçš„å†…å­˜å¹¶ä¸å­˜å‚¨åœ¨å †ä¸­ï¼Œè€Œæ˜¯åœ¨å¸¸é‡åŒºä¸­ï¼Œä¹Ÿä¸éœ€è¦mallocå’Œfreeã€‚
* å¯¹äºNSStringç±»å‹ï¼Œå»ºè®®ç›´æ¥ä½¿ç”¨`@""`åˆå§‹åŒ–èµ‹å€¼ã€‚


# SideTables æ•£åˆ—è¡¨

SideTablesæ˜¯ä¸€ä¸ªhashè¡¨ã€‚åœ¨weakä¿®é¥°æ—¶ä¼šå­˜æ”¾åœ¨SideTablesè¿™ä¸ªè¡¨ä¸­ã€‚

å¯¹äºOCæ­£å¸¸çš„å¯¹è±¡æ¥è¯´å½“æ‰§è¡Œretainæ“ä½œæ—¶ï¼Œå½“å¼•ç”¨è®¡æ•°è¾¾åˆ°ä¸€å®šçš„å€¼ï¼ˆ256ï¼‰æ—¶ï¼Œåˆ™ä¼šå­˜æ”¾åœ¨SideTablesä¸­ã€‚

æˆ‘ä»¬æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹retain çš„æµç¨‹

## retainæµç¨‹

çœ‹ä¸€äº›æºç ï¼šè¿›å…¥`objc_retain` -> `retain` -> `rootRetain`æŸ¥çœ‹æºç å®ç°ã€‚

```
LWAYS_INLINE id 
objc_object::rootRetain(bool tryRetain, bool handleOverflow)
{
    if (isTaggedPointer()) return (id)this;

    bool sideTableLocked = false;
    bool transcribeToSideTable = false;
    //ä¸ºä»€ä¹ˆæœ‰isaï¼Ÿå› ä¸ºéœ€è¦å¯¹å¼•ç”¨è®¡æ•°+1ï¼Œå³retain+1ï¼Œè€Œå¼•ç”¨è®¡æ•°å­˜å‚¨åœ¨isaçš„bitsä¸­ï¼Œéœ€è¦è¿›è¡Œæ–°æ—§isaçš„æ›¿æ¢
    isa_t oldisa;
    isa_t newisa;
    //é‡ç‚¹
    do {
        transcribeToSideTable = false;
        oldisa = LoadExclusive(&isa.bits);
        newisa = oldisa;
        //åˆ¤æ–­æ˜¯å¦ä¸ºnonpointer isa
        if (slowpath(!newisa.nonpointer)) {
            //å¦‚æœä¸æ˜¯ nonpointer isaï¼Œç›´æ¥æ“ä½œæ•£åˆ—è¡¨sidetable
            ClearExclusive(&isa.bits);
            if (rawISA()->isMetaClass()) return (id)this;
            if (!tryRetain && sideTableLocked) sidetable_unlock();
            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;
            else return sidetable_retain();
        }
        // don't check newisa.fast_rr; we already called any RR overrides
        //deallocæºç 
        if (slowpath(tryRetain && newisa.deallocating)) {
            ClearExclusive(&isa.bits);
            if (!tryRetain && sideTableLocked) sidetable_unlock();
            return nil;
        }
        
        
        uintptr_t carry;
        //æ‰§è¡Œå¼•ç”¨è®¡æ•°+1æ“ä½œï¼Œå³å¯¹bitsä¸­çš„ 1ULL<<45ï¼ˆarm64ï¼‰ å³extra_rcï¼Œç”¨äºè¯¥å¯¹è±¡å­˜å‚¨å¼•ç”¨è®¡æ•°å€¼
        newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc++
        //åˆ¤æ–­extra_rcæ˜¯å¦æ»¡äº†ï¼Œcarryæ˜¯æ ‡è¯†ç¬¦
        if (slowpath(carry)) {
            // newisa.extra_rc++ overflowed
            if (!handleOverflow) {
                ClearExclusive(&isa.bits);
                return rootRetain_overflow(tryRetain);
            }
            // Leave half of the retain counts inline and 
            // prepare to copy the other half to the side table.
            if (!tryRetain && !sideTableLocked) sidetable_lock();
            sideTableLocked = true;
            transcribeToSideTable = true;
            //å¦‚æœextra_rcæ»¡äº†ï¼Œåˆ™ç›´æ¥å°†æ»¡çŠ¶æ€çš„ä¸€åŠæ‹¿å‡ºæ¥å­˜åˆ°extra_rc
            newisa.extra_rc = RC_HALF;
            //ç»™ä¸€ä¸ªæ ‡è¯†ç¬¦ä¸ºYESï¼Œè¡¨ç¤ºéœ€è¦å­˜å‚¨åˆ°æ•£åˆ—è¡¨
            newisa.has_sidetable_rc = true;
        }
    } while (slowpath(!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)));

    if (slowpath(transcribeToSideTable)) {
        // Copy the other half of the retain counts to the side table.
        //å°†å¦ä¸€åŠå­˜åœ¨æ•£åˆ—è¡¨çš„rc_halfä¸­ï¼Œå³æ»¡çŠ¶æ€ä¸‹æ˜¯8ä½ï¼Œä¸€åŠå°±æ˜¯1å·¦ç§»7ä½ï¼Œå³é™¤ä»¥2
        //è¿™ä¹ˆæ“ä½œçš„ç›®çš„åœ¨äºæé«˜æ€§èƒ½ï¼Œå› ä¸ºå¦‚æœéƒ½å­˜åœ¨æ•£åˆ—è¡¨ä¸­ï¼Œå½“éœ€è¦release-1æ—¶ï¼Œéœ€è¦å»è®¿é—®æ•£åˆ—è¡¨ï¼Œæ¯æ¬¡éƒ½éœ€è¦å¼€è§£é”ï¼Œæ¯”è¾ƒæ¶ˆè€—æ€§èƒ½ã€‚extra_rcå­˜å‚¨ä¸€åŠçš„è¯ï¼Œå¯ä»¥ç›´æ¥æ“ä½œextra_rcå³å¯ï¼Œä¸éœ€è¦æ“ä½œæ•£åˆ—è¡¨ã€‚æ€§èƒ½ä¼šæé«˜å¾ˆå¤š
        sidetable_addExtraRC_nolock(RC_HALF);
    }

    if (slowpath(!tryRetain && sideTableLocked)) sidetable_unlock();
    return (id)this;
}
```

æµç¨‹åˆ†æï¼š

1. isTaggedPointerç›´æ¥è¿”å›ã€‚
2. ä¸æ˜¯nonpointerï¼Œç›´æ¥å­˜sideTable
3. æ˜¯å¦æ­£åœ¨é‡Šæ”¾ï¼Œdeallocatingï¼Œè¿”å›nil
4. å¼•ç”¨è®¡æ•°+1ã€‚
5. åˆ¤æ–­å¼•ç”¨è®¡æ•°æ˜¯å¦å­˜æ»¡äº†ï¼Œæ»¡äº†åˆ™å˜æˆä¸€åŠï¼Œå¦ä¸€åŠå­˜æ”¾åœ¨æ•£åˆ—è¡¨ä¸­ã€‚

ä¹‹æ‰€ä»¥ä¸ç›´æ¥æŠŠå¼•ç”¨è®¡æ•°å­˜æ”¾åœ¨æ•£åˆ—è¡¨ä¸­ï¼Œæ˜¯å› ä¸ºå¯¹è¡¨çš„æ“ä½œï¼Œéœ€è¦ç”¨åˆ°é”ï¼Œè¿™æ˜¯è€—æ—¶æ“ä½œã€‚
å¦‚æœæ¯ä¸€ä¸ªå¯¹è±¡éƒ½éœ€è¦ä¸€ä¸ªæ•£åˆ—è¡¨ï¼Œä¹Ÿä¼šé€ æˆæ€§èƒ½é—®é¢˜ã€‚å¦‚æœæ‰€æœ‰å¯¹è±¡å…¬ç”¨ä¸€ä¸ªæ•£åˆ—è¡¨ï¼Œåˆ™å…¶ä»–æ•°æ®å¯èƒ½ä¸å®‰å…¨ï¼Œæ‰€ä»¥ä¹Ÿä¸ä¼šå…¬ç”¨ä¸€ä¸ªè¡¨ã€‚çœŸæœºä¸Šæœ€å¤šæœ‰8ä¸ªè¡¨ã€‚


## releaseæµç¨‹

releaseæµç¨‹ä¸retainç›¸åã€‚

`setProperty` -> `reallySetProperty` -> `objc_release` -> `release` -> `rootRelease` -> `rootRelease`æŸ¥çœ‹æºç ï¼š

```
ALWAYS_INLINE bool 
objc_object::rootRelease(bool performDealloc, bool handleUnderflow)
{
    if (isTaggedPointer()) return false;

    bool sideTableLocked = false;

    isa_t oldisa;
    isa_t newisa;

 retry:
    do {
        oldisa = LoadExclusive(&isa.bits);
        newisa = oldisa;
        //åˆ¤æ–­æ˜¯å¦æ˜¯Nonpointer isa
        if (slowpath(!newisa.nonpointer)) {
            //å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥æ“ä½œæ•£åˆ—è¡¨-1
            ClearExclusive(&isa.bits);
            if (rawISA()->isMetaClass()) return false;
            if (sideTableLocked) sidetable_unlock();
            return sidetable_release(performDealloc);
        }
        // don't check newisa.fast_rr; we already called any RR overrides
        uintptr_t carry;
        //è¿›è¡Œå¼•ç”¨è®¡æ•°-1æ“ä½œï¼Œå³extra_rc-1
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--
        //å¦‚æœæ­¤æ—¶extra_rcçš„å€¼ä¸º0äº†ï¼Œåˆ™èµ°åˆ°underflow
        if (slowpath(carry)) {
            // don't ClearExclusive()
            goto underflow;
        }
    } while (slowpath(!StoreReleaseExclusive(&isa.bits, 
                                             oldisa.bits, newisa.bits)));

    if (slowpath(sideTableLocked)) sidetable_unlock();
    return false;

 underflow:
    // newisa.extra_rc-- underflowed: borrow from side table or deallocate

    // abandon newisa to undo the decrement
    newisa = oldisa;
    //åˆ¤æ–­æ•£åˆ—è¡¨ä¸­æ˜¯å¦å­˜å‚¨äº†ä¸€åŠçš„å¼•ç”¨è®¡æ•°
    if (slowpath(newisa.has_sidetable_rc)) {
        if (!handleUnderflow) {
            ClearExclusive(&isa.bits);
            return rootRelease_underflow(performDealloc);
        }

        // Transfer retain count from side table to inline storage.

        if (!sideTableLocked) {
            ClearExclusive(&isa.bits);
            sidetable_lock();
            sideTableLocked = true;
            // Need to start over to avoid a race against 
            // the nonpointer -> raw pointer transition.
            goto retry;
        }

        // Try to remove some retain counts from the side table.
        //ä»æ•£åˆ—è¡¨ä¸­å–å‡ºå­˜å‚¨çš„ä¸€åŠå¼•ç”¨è®¡æ•°
        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);

        // To avoid races, has_sidetable_rc must remain set 
        // even if the side table count is now zero.

        if (borrowed > 0) {
            // Side table retain count decreased.
            // Try to add them to the inline count.
            //è¿›è¡Œ-1æ“ä½œï¼Œç„¶åå­˜å‚¨åˆ°extra_rcä¸­
            newisa.extra_rc = borrowed - 1;  // redo the original decrement too
            bool stored = StoreReleaseExclusive(&isa.bits, 
                                                oldisa.bits, newisa.bits);
            if (!stored) {
                // Inline update failed. 
                // Try it again right now. This prevents livelock on LL/SC 
                // architectures where the side table access itself may have 
                // dropped the reservation.
                isa_t oldisa2 = LoadExclusive(&isa.bits);
                isa_t newisa2 = oldisa2;
                if (newisa2.nonpointer) {
                    uintptr_t overflow;
                    newisa2.bits = 
                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);
                    if (!overflow) {
                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, 
                                                       newisa2.bits);
                    }
                }
            }

            if (!stored) {
                // Inline update failed.
                // Put the retains back in the side table.
                sidetable_addExtraRC_nolock(borrowed);
                goto retry;
            }

            // Decrement successful after borrowing from side table.
            // This decrement cannot be the deallocating decrement - the side 
            // table lock and has_sidetable_rc bit ensure that if everyone 
            // else tried to -release while we worked, the last one would block.
            sidetable_unlock();
            return false;
        }
        else {
            // Side table is empty after all. Fall-through to the dealloc path.
        }
    }
    //æ­¤æ—¶extra_rcä¸­å€¼ä¸º0ï¼Œæ•£åˆ—è¡¨ä¸­ä¹Ÿæ˜¯ç©ºçš„ï¼Œåˆ™ç›´æ¥è¿›è¡Œææ„ï¼Œå³è‡ªåŠ¨è§¦å‘deallocæµç¨‹
    // Really deallocate.
    //è§¦å‘deallocçš„æ—¶æœº
    if (slowpath(newisa.deallocating)) {
        ClearExclusive(&isa.bits);
        if (sideTableLocked) sidetable_unlock();
        return overrelease_error();
        // does not actually return
    }
    newisa.deallocating = true;
    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;

    if (slowpath(sideTableLocked)) sidetable_unlock();

    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);

    if (performDealloc) {
        //å‘é€ä¸€ä¸ªdeallocæ¶ˆæ¯
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
    }
    return true;
}
```

æµç¨‹åˆ†æå¦‚ä¸‹ï¼š

1. åˆ¤æ–­æ˜¯å¦æ˜¯Nonpointer isaï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥å¯¹æ•£åˆ—è¡¨è¿›è¡Œ-1æ“ä½œ
2. å¦‚æœæ˜¯Nonpointer isaï¼Œåˆ™å¯¹extra_rcä¸­çš„å¼•ç”¨è®¡æ•°å€¼è¿›è¡Œ-1æ“ä½œï¼Œå¹¶å­˜å‚¨æ­¤æ—¶çš„extra_rcçŠ¶æ€åˆ°carryä¸­
3. å¦‚æœæ­¤æ—¶çš„çŠ¶æ€carrayä¸º0ï¼Œåˆ™èµ°åˆ°underflowæµç¨‹

    underflowæµç¨‹æœ‰ä»¥ä¸‹å‡ æ­¥ï¼š
    1. åˆ¤æ–­æ•£åˆ—è¡¨ä¸­æ˜¯å¦å­˜å‚¨äº†ä¸€åŠçš„å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ä»æ•£åˆ—è¡¨ä¸­å–å‡ºå­˜å‚¨çš„ä¸€åŠå¼•ç”¨è®¡æ•°ï¼Œè¿›è¡Œ-1æ“ä½œï¼Œç„¶åå­˜å‚¨åˆ°extra_rcä¸­
    2. å¦‚æœæ­¤æ—¶extra_rcæ²¡æœ‰å€¼ï¼Œæ•£åˆ—è¡¨ä¸­ä¹Ÿæ˜¯ç©ºçš„ï¼Œåˆ™ç›´æ¥è¿›è¡Œææ„ï¼Œå³deallocæ“ä½œï¼Œå±äºè‡ªåŠ¨è§¦å‘

## deallocåˆ†æ

deallocæ˜¯åœ¨retainCountä¸º0æ—¶ç³»ç»Ÿè‡ªåŠ¨è§¦å‘çš„ã€‚

`dealloc` -> `_objc_rootDealloc` -> `rootDealloc`æŸ¥çœ‹æºç ï¼š

```
inline void
objc_object::rootDealloc()
{
    //å¯¹è±¡è¦é‡Šæ”¾ï¼Œéœ€è¦åšå“ªäº›äº‹æƒ…ï¼Ÿ
    //1ã€isa - cxx - å…³è”å¯¹è±¡ - å¼±å¼•ç”¨è¡¨ - å¼•ç”¨è®¡æ•°è¡¨
    //2ã€free
    if (isTaggedPointer()) return;  // fixme necessary?

    //å¦‚æœæ²¡æœ‰è¿™äº›ï¼Œåˆ™ç›´æ¥free
    if (fastpath(isa.nonpointer  &&  
                 !isa.weakly_referenced  &&  
                 !isa.has_assoc  &&  
                 !isa.has_cxx_dtor  &&  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        //å¦‚æœæœ‰
        object_dispose((id)this);
    }
}
```

1. æ ¹æ®æ¡ä»¶åˆ¤æ–­æ˜¯å¦æœ‰isaã€cxxã€å…³è”å¯¹è±¡ã€å¼±å¼•ç”¨è¡¨ã€å¼•ç”¨è®¡æ•°è¡¨ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™ç›´æ¥freeé‡Šæ”¾å†…å­˜
2. å¦‚æœæœ‰ï¼Œåˆ™è¿›å…¥object_disposeæ–¹æ³•

```
id 
object_dispose(id obj)
{
    if (!obj) return nil;
    // é”€æ¯å®ä¾‹è€Œä¸ä¼šé‡Šæ”¾å†…å­˜
    objc_destructInstance(obj);
    //é‡Šæ”¾å†…å­˜
    free(obj);

    return nil;
}
```

`objc_destructInstance`ä¸ºäº†æ¶ˆè€—å®ä¾‹å¯¹è±¡ã€‚

```
void *objc_destructInstance(id obj) 
{
    if (obj) {
        // Read all of the flags at once for performance.
        bool cxx = obj->hasCxxDtor();
        bool assoc = obj->hasAssociatedObjects();

        // This order is important.
        //è°ƒç”¨C ++ææ„å‡½æ•°
        if (cxx) object_cxxDestruct(obj);
        //åˆ é™¤å…³è”å¼•ç”¨
        if (assoc) _object_remove_assocations(obj);
        //é‡Šæ”¾
        obj->clearDeallocating();
    }
    return obj;
}
```

1. åœ¨å†…éƒ¨åˆ¤æ–­æ˜¯å¦æœ‰ææ„å‡½æ•°ï¼Œå¦‚æœæœ‰åˆ™è°ƒç”¨ã€‚
2. æ˜¯å¦æœ‰å…³è”å¯¹è±¡ï¼Œæœ‰çš„èŠ±ç§»é™¤å…³è”å¯¹è±¡ã€‚
3. æ‰§è¡ŒclearDeallocating

```
inline void 
objc_object::clearDeallocating()
{
    //åˆ¤æ–­æ˜¯å¦ä¸ºnonpointer isa
    if (slowpath(!isa.nonpointer)) {
        // Slow path for raw pointer isa.
        //å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥é‡Šæ”¾æ•£åˆ—è¡¨
        sidetable_clearDeallocating();
    }
    //å¦‚æœæ˜¯ï¼Œæ¸…ç©ºå¼±å¼•ç”¨è¡¨ + æ•£åˆ—è¡¨
    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {
        // Slow path for non-pointer isa with weak refs and/or side table data.
        clearDeallocating_slow();
    }

    assert(!sidetable_present());
}
```

`clearDeallocating`çš„ç›®çš„ä¸»è¦æ˜¯ä¸ºäº†æ¸…ç©ºæ•£åˆ—è¡¨ã€‚

```
NEVER_INLINE void
objc_object::clearDeallocating_slow()
{
    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));

    SideTable& table = SideTables()[this];
    table.lock();
    if (isa.weakly_referenced) {
        //æ¸…ç©ºå¼±å¼•ç”¨è¡¨
        weak_clear_no_lock(&table.weak_table, (id)this);
    }
    if (isa.has_sidetable_rc) {
        //æ¸…ç©ºå¼•ç”¨è®¡æ•°
        table.refcnts.erase(this);
    }
    table.unlock();
}
```

æ¸…ç©ºå¼•ç”¨è®¡æ•°ï¼Œæƒ…å†µå¼±å¼•ç”¨è¡¨ã€‚

ä»¥ä¸Šå°±æ˜¯dealloc çš„æµç¨‹ã€‚

## retainCount

```
NSObject *objc = [NSObject alloc];
NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)objc));
```

ä¸Šé¢è¾“å‡ºçš„å¼•ç”¨è®¡æ•°æ˜¯å¤šå°‘ï¼Ÿè¿™æ˜¯ä¸€ä¸ªç»å…¸çš„é¢è¯•é¢˜ã€‚

è¿™é‡Œè¾“å‡ºçš„ç»“æœæ˜¯1ã€‚ä½†æ˜¯1æ˜¯ä¸å¯¹çš„ã€‚

```
- (NSUInteger)retainCount {
    return _objc_rootRetainCount(self);
}
ğŸ‘‡
uintptr_t
_objc_rootRetainCount(id obj)
{
    ASSERT(obj);

    return obj->rootRetainCount();
}
ğŸ‘‡
inline uintptr_t 
objc_object::rootRetainCount()
{
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    isa_t bits = LoadExclusive(&isa.bits);
    ClearExclusive(&isa.bits);
    //å¦‚æœæ˜¯nonpointer isaï¼Œæ‰æœ‰å¼•ç”¨è®¡æ•°çš„ä¸‹å±‚å¤„ç†
    if (bits.nonpointer) {
        //allocåˆ›å»ºçš„å¯¹è±¡å¼•ç”¨è®¡æ•°ä¸º0ï¼ŒåŒ…æ‹¬sideTable,æ‰€ä»¥å¯¹äºallocæ¥è¯´ï¼Œæ˜¯ 0+1=1ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆé€šè¿‡retaincountè·å–çš„å¼•ç”¨è®¡æ•°ä¸º1çš„åŸå› 
        uintptr_t rc = 1 + bits.extra_rc;
        if (bits.has_sidetable_rc) {
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }
    //å¦‚æœä¸æ˜¯ï¼Œåˆ™æ­£å¸¸è¿”å›
    sidetable_unlock();
    return sidetable_retainCount();
}
```

å½“å¯¹è±¡åˆ›å»ºæ—¶ï¼Œå¹¶æ²¡æœ‰å­˜å¼•ç”¨è®¡æ•°ï¼Œbits.extra_rcè¿˜æ˜¯0ï¼Œå½“è°ƒç”¨äº†retainCountæ—¶æ‰§è¡Œäº†`1 + bits.extra_rc`ï¼Œæ‰€ä»¥å°±å˜æˆäº†1 ã€‚å¦‚æœreatinCount=0ï¼Œç›¸å½“äºåˆ›å»ºæˆåŠŸä¹‹åå°±ä¼šè¢«é‡Šæ”¾æ‰ã€‚

æ‰€ä»¥è¿™é‡Œçš„ç­”æ¡ˆåº”è¯¥æ˜¯0ã€‚ä¸ç®¡æˆ‘æœ‰æ²¡æœ‰æ‰§è¡Œinitæ“ä½œï¼Œéƒ½æ˜¯0 ã€‚åœ¨è¯»çš„æ—¶å€™æ‰ä¼šæ˜¯1ã€‚