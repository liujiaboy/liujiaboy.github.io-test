---
title: ARM汇编-3 状态寄存器 if、switch
date: 2021-04-14 22:05:25
tags:
    - ARM汇编
categories:
    - 逆向
---

# 1. 状态寄存器

CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同)。这种寄存器在ARM中，被称为状态寄存器就是CPSR(current program status register)寄存器。

CPSR和其他寄存器不一样,其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

> CPSR寄存器是32位的。

* CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!
* N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行！


![](.jpg)


## 1.1 N （Negative）

cpsr的第31位是N，它记录相关指令执行后的结果，结果是负数，则N=1，非负数则N=0。

> 在ARM64的指令集中，逻辑运算或者算数运算（add、sub、or等）指令的执行会影响状态寄存器的值。

n=1：结果是负数
n=0：结果位非负数，包括0

## 1.2 Z（Zero）

cpsr的第30位是Z，0标志位。它记录相关指令执行后其结果是否为。如果结果为0，那么Z = 1；如果结果不为0，那么Z = 0.

z=1：结果为0
z=0：结果不为0

## 1.3 C（Carry）

cpsr第29位是c进位标志位，一般情况进行下无符号述的运算。

加法运算：当运算结果产生了进位时（无符号数溢出）c=1，没有溢出c=0
减法运算：包括（CPM）当运算时产生了借位（无符号数溢出），c=0，没有溢出c=1


### 1.3.1 进位

两个数据相加，比如正常的十进制运算，5+5=10，向十位数进1，个位数为0。但是超过其最大的位数时，发生溢出，导致进位的值无法保存，也就是说进位的值丢失了。但是CPU在运算的时候，并不会丢弃这个进位的值，二手放在寄存器里了，也就是cpsr的c位。

### 1.3.2 借位

两个数据做减法操作，有可能向更高位借位。比如：10-5=5，各位不够减，需要向十位去借。这时候会用c位来标记借位。


## 1.4 V（Overflow）
cpsr的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。

* 正数 + 正数 = 负数。溢出
* 负数 + 负数 = 正数。溢出
* 正数 + 负数 不可能发生溢出


# 1.5 总结

NZ：是否为0，判断正负
CV：无符号，有符号判断是否溢出 


# 2. 全局变量、常量
开始这一节之前，先知道我们的内存分区划分：

代码区：存放代码，可读，可执行
栈区：参数、局部变量、临时数据，可读可写
堆区：动态申请，可读可写

全局变量：可读可写
常量区：只读

接下来，我们分析代码：

```
// 定义一个全局变量
int g = 12;

// 定义一个方法
int func(int a,int b){
    // 'haha'就是一个常量，在常量区
    printf("haha");
    // 局部变量c
    int c = a + g + b;
    return c;
}

int main(int argc, char * argv[]) {
   
    func(10, 20);
    
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
```

执行之后，走汇编流程，进行查看

```
Demo`func:
->  0x100bc211c <+0>:  sub    sp, sp, #0x20             ; =0x20 
    0x100bc2120 <+4>:  stp    x29, x30, [sp, #0x10]
    0x100bc2124 <+8>:  add    x29, sp, #0x10            ; =0x10 
    0x100bc2128 <+12>: stur   w0, [x29, #-0x4]
    0x100bc212c <+16>: str    w1, [sp, #0x8]
    0x100bc2130 <+20>: adrp   x0, 1
    0x100bc2134 <+24>: add    x0, x0, #0xf9f            ; =0xf9f 
    // ① 这里执行了printf操作，大致可以判断，x0中存的就是'haha'
    0x100bc2138 <+28>: bl     0x100bc25b0               ; symbol stub for: printf
    0x100bc213c <+32>: ldur   w8, [x29, #-0x4]
    // ② 这里获取的是全局变量
    0x100bc2140 <+36>: adrp   x9, 3
    0x100bc2144 <+40>: add    x9, x9, #0x648            ; =0x648 
    0x100bc2148 <+44>: ldr    w10, [x9]
    0x100bc214c <+48>: add    w8, w8, w10
    0x100bc2150 <+52>: ldr    w10, [sp, #0x8]
    0x100bc2154 <+56>: add    w8, w8, w10
    0x100bc2158 <+60>: str    w8, [sp, #0x4]
    0x100bc215c <+64>: ldr    w8, [sp, #0x4]
    0x100bc2160 <+68>: mov    x0, x8
    0x100bc2164 <+72>: ldp    x29, x30, [sp, #0x10]
    0x100bc2168 <+76>: add    sp, sp, #0x20             ; =0x20 
    0x100bc216c <+80>: ret    

```

①这里执行了printf操作，这里看一些是否真的打印了'haha'。我们追一下x0寄存器的变化。

```
0x100bc2130 <+20>: adrp   x0, 1
```
这里有一个关键字需要注意一下：
adrp: 针对address page操作
这一行代码有三个操作：
1. 将1左移12位（即在1后加3个0变成1000）
2. 将当前寄存器的地址的低12位清0，即当前行的地址的后3位清0。0x1002b2184 -> 0x100bc2130
3. 把0x1000+0x100bc2000赋值给x0，x0=0x100bc3000，即当前行地址的倒数第4位与x0后面的数字相加

说白了，这句代码的意思就是找到某一页地址的开始。我们走断点，打印一下x0.

```
(lldb) register read x0
x0 = 0x0000000100bc3000
```

下一句的代码是，`add x0, x0, #0xf9f`，就x0的地址+0x0xf9f
获取x0的值位0x100bc3f9f

```
(lldb) register read x0
x0 = 0x0000000100bc3f9f  "haha"

(lldb) x 0x0000000100bc3f9f
0x100bc3f9f: 68 61 68 61 00 01 00 00 00 1c 00 00 00 02 00 00  haha............
0x100bc3faf: 00 24 00 00 00 00 00 00 00 24 00 00 00 02 00 00  .$.......$......
```

我们知道'h'的ASCII码是97，对应的16进制就行0x61，'a'是0x68。就是我们的常量'haha'。

这样也就拿到了常量的值。
需要注意的是，我们的常量是在编译的时候就已经确定了地址。这里通过当前寄存器的地址为参照，偏移一定的值来获取常量所在的页数。

那继续看一下全局变量

```
0x100bc2140 <+36>: adrp   x9, 3
0x100bc2144 <+40>: add    x9, x9, #0x648            ; =0x648 
```

我们使用相同的方式，打印一下x9的值。

```
// adrp的断点
(lldb) register read x9
x9 = 0x0000000100bc5000  

// add 的断点
lldb) register read x9
x9 = 0x0000000100bc5648  g  // 这里拿到的是变量g，而g在内存中的值是0c
(lldb) x 0x0000000100bc5648
0x100bc5648: 0c 00 00 00 0c 00 00 00 38 5e 44 29 02 00 00 00  ........8^D)....
0x100bc5658: f0 33 bc 00 01 00 00 00 d0 4f bc 00 01 00 00 00  .3.......O......

```

我们可以通过相同的方式获取全局变量的值，g=12。

所以局部变量和全局变量都是通过adrp以当前寄存器的地址为参照来查找address来获取值的。

## 2.1 汇编还原高级语言

这里使用一个牛逼的工具Hopper，可以查看对应的方法转化成汇编之后的代码。我们找到对应的方法func

```
_func:
000000010000611c         sub        sp, sp, #0x20                               ; CODE XREF=_main+32
0000000100006120         stp        x29, x30, [sp, #0x10]
0000000100006124         add        x29, sp, #0x10
0000000100006128         stur       w0, [x29, #-0x4]
000000010000612c         str        w1, [sp, #0x8]
0000000100006130         adrp       x0, #0x100007000                            ; argument #1 for method imp___stubs__printf
0000000100006134         add        x0, x0, #0xf9f                              ; "haha"
0000000100006138         bl         imp___stubs__printf
000000010000613c         ldur       w8, [x29, #-0x4]
0000000100006140         adrp       x9, #0x100009000
0000000100006144         add        x9, x9, #0x648                              ; _g
0000000100006148         ldr        w10, x9
000000010000614c         add        w8, w8, w10
0000000100006150         ldr        w10, [sp, #0x8]
0000000100006154         add        w8, w8, w10
0000000100006158         str        w8, [sp, #0x4]
000000010000615c         ldr        w8, [sp, #0x4]
0000000100006160         mov        x0, x8
0000000100006164         ldp        x29, x30, [sp, #0x10]
0000000100006168         add        sp, sp, #0x20
000000010000616c         ret
```

# 2. 条件判断

## 2.1 cmp（Compare）比较指令

cmp把一个寄存器的内容和另一个寄存器的内容（或立即数）进行比较。但不存储结果，只是更改标志。

一般cmp做完判断后会进行跳转，后面通常会跟上b指令。

* BL 标号：跳转到标号处执行
* B.GT 标号：比较结果是大于（greater than），执行标号，否则不跳转
* B.GE 标号：比较结果是大于等于（greater than or equal to），执行标号，否则不跳转
* B.EQ 标号：比较结果是等于，执行标号，否则不跳转
* B.HI 标号：比较结果是无符号大于，执行标号，否则不跳转


# 3. switch

1. 假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。
2. 各个分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。
3. 在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）


