---
title: ARM汇编-3 状态寄存器 if、switch
date: 2021-04-14 22:05:25
tags:
    - ARM汇编
categories:
    - 逆向
---

# 1. 状态寄存器

CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同)。这种寄存器在ARM中，被称为状态寄存器就是CPSR(current program status register)寄存器。

CPSR和其他寄存器不一样,其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

> CPSR寄存器是32位的。

* CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!
* N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行！


![](.jpg)


## 1.1 N （Negative）

cpsr的第31位是N，它记录相关指令执行后的结果，结果是负数，则N=1，非负数则N=0。

> 在ARM64的指令集中，逻辑运算或者算数运算（add、sub、or等）指令的执行会影响状态寄存器的值。

n=1：结果是负数
n=0：结果位非负数，包括0

## 1.2 Z（Zero）

cpsr的第30位是Z，0标志位。它记录相关指令执行后其结果是否为。如果结果为0，那么Z = 1；如果结果不为0，那么Z = 0.

z=1：结果为0
z=0：结果不为0

## 1.3 C（Carry）

cpsr第29位是c进位标志位，一般情况进行下无符号述的运算。

加法运算：当运算结果产生了进位时（无符号数溢出）c=1，没有溢出c=0
减法运算：包括（CPM）当运算时产生了借位（无符号数溢出），c=0，没有溢出c=1


### 1.3.1 进位

两个数据相加，比如正常的十进制运算，5+5=10，向十位数进1，个位数为0。但是超过其最大的位数时，发生溢出，导致进位的值无法保存，也就是说进位的值丢失了。但是CPU在运算的时候，并不会丢弃这个进位的值，二手放在寄存器里了，也就是cpsr的c位。

### 1.3.2 借位

两个数据做减法操作，有可能向更高位借位。比如：10-5=5，各位不够减，需要向十位去借。这时候会用c位来标记借位。


## 1.4 V（Overflow）
cpsr的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。

* 正数 + 正数 = 负数。溢出
* 负数 + 负数 = 正数。溢出
* 正数 + 负数 不可能发生溢出


# 1.5 总结

NZ：是否为0，判断正负
CV：无符号，有符号判断是否溢出 


# 2. 条件判断

## 2.1 cmp（Compare）比较指令

cmp把一个寄存器的内容和另一个寄存器的内容（或立即数）进行比较。但不存储结果，只是更改标志。

一般cmp做完判断后会进行跳转，后面通常会跟上b指令。

* BL 标号：跳转到标号处执行
* B.GT 标号：比较结果是大于（greater than），执行标号，否则不跳转
* B.GE 标号：比较结果是大于等于（greater than or equal to），执行标号，否则不跳转
* B.EQ 标号：比较结果是等于，执行标号，否则不跳转
* B.HI 标号：比较结果是无符号大于，执行标号，否则不跳转


# 3. switch

1. 假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。
2. 各个分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。
3. 在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）


