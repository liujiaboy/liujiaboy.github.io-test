<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/page/2/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-7-hook/" class="post-title-link" itemprop="url">nx-7-hook</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 14:37:29" itemprop="dateCreated datePublished" datetime="2021-09-13T14:37:29+08:00">2021-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/19/github/github-443%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">github-443解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-19 11:12:52" itemprop="dateCreated datePublished" datetime="2021-06-19T11:12:52+08:00">2021-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 14:06:47" itemprop="dateModified" datetime="2021-06-21T14:06:47+08:00">2021-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/github/" itemprop="url" rel="index"><span itemprop="name">github</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><p>在使用github的时候，执行<code>git pull</code>或者<code>git push</code>时，经常会出现以下错误：</p>
<blockquote>
<p>【Failed to connect to github.com port 443: Operation timed out】</p>
</blockquote>
<p>这个时候就一通百度、google发现有解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意啊、这个是不行的</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>这个时候你可能觉得：OK终于解决了。</p>
<p>但是，可能再你下次使用的时候又会出现类似的问题，或者又有新的问题出现。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>打开网站：<a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></p>
<p><img src="step-1.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p>打开网站：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></p>
<p><img src="step-2.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><p>打开网站<a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></p>
<p><img src="step-3.jpg" alt=""></p>
<p>web页面不要关，一会要用</p>
<h2 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h2><p>打开系统host，进行编辑，我这里使用的是Mac，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<p><code>sudo</code>命令需要输入密码，之后，把我们上面打开的3个web对应的ip和host绑定，如下图：</p>
<p><img src="step-4.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ip            对应的host    </span><br><span class="line"># Github</span><br><span class="line">140.82.114.4    github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<p>ip以自己打开的那3个web显示的为准。Windows请自行百度如何操作host。</p>
<h2 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h2><p>如果设置了<code>http.proxy</code>和<code>https.proxy</code> http/https代理，需要取消代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h2><p>刷新DNS，如果机型不同，不起作用，请自行查看<a href="https://support.apple.com/zh-cn/HT202516" target="_blank" rel="noopener">还原OS X 中的DNS缓存</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;support.apple.com&#x2F;zh-cn&#x2F;HT202516</span><br></pre></td></tr></table></figure>

<p>到这里就可以正常使用了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">OC原理/oc-4-类的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-18 18:04:13" itemprop="dateCreated datePublished" datetime="2021-06-18T18:04:13+08:00">2021-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象、类对象、元类"><a href="#1-对象、类对象、元类" class="headerlink" title="1. 对象、类对象、元类"></a>1. 对象、类对象、元类</h1><h2 id="1-1-isa指向、superClass指向"><a href="#1-1-isa指向、superClass指向" class="headerlink" title="1.1 isa指向、superClass指向"></a>1.1 isa指向、superClass指向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#x2F;&#x2F;先把这里的协议注释掉，用到的时候再打开</span><br><span class="line">@protocol PersonProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *p_address;</span><br><span class="line"></span><br><span class="line">- (void)p_func1;</span><br><span class="line">+ (void)p_func1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_hobby;</span><br><span class="line">    CGFloat _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic) int age;</span><br><span class="line"></span><br><span class="line">- (void)func1;</span><br><span class="line">- (void)func2;</span><br><span class="line">+ (void)func3;</span><br><span class="line">+ (void)func4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后执行，直接打断点。</span><br><span class="line">Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">Teacher *t &#x3D; [[Teacher alloc] init];</span><br></pre></td></tr></table></figure>

<p>我们根据述代码进行分析，isa指针的指向。</p>
<blockquote>
<p>注意，这里是用的是模拟器</p>
</blockquote>
<h2 id="1-2-实例对象的isa"><a href="#1-2-实例对象的isa" class="headerlink" title="1.2 实例对象的isa"></a>1.2 实例对象的isa</h2><p>首先我们先看Person的实例p的isa指向情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先打印一下p的内存情况</span><br><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x1006460b0&gt;</span><br><span class="line">&#x2F;&#x2F; 输出p指针的情况</span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x1006460b0: 0x011d8001000083f9 0x0000000000000000</span><br><span class="line">0x1006460c0: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) p p 0x011d8001000083f9</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br></pre></td></tr></table></figure>

<p>这里拿到p指针指向的内存情况，我们知道第一块内存区域存放的是isa指针，直接打印的话，发现就是一串数字，啥也看不出来。还记得上一章中object_getClass反向验证isa指向最后的”&amp;”运算吗？<code>0x011d8001000083f9</code>这个值就是isa-&gt;bits，我们用它与<code>ISA_MASK</code>进行&amp;运算。因为这里是用的真机，所以<code>ISA_MASK = 0x00007ffffffffff8</code>，如果是用Mac或者模拟器，根据芯片类型判断是否是ARM64架构还是x86，然后使用对应的值进行换算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; p&#x2F;x输出内存的16进制</span><br><span class="line">(lldb) p&#x2F;x 0x011d8001000083f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $2 &#x3D; 0x00000001000083f8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里po就是Person类</span><br><span class="line">(lldb) po 0x00000001000083f8</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>打印出来是Person。所以isa指向的就是Person类。那我们做一下验证，直接通过<code>object_getClass</code>方法来找一下Person这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x object_getClass(p)</span><br><span class="line">(Class) $12 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>

<p>是不是发现，Person类的内存地址是一样的。如果再实例化一个p1，看p1-&gt;isa指向的和p-&gt;isa指向的是否是同一个Person类的内存地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接使用object_getClass获取类对象。</span><br><span class="line">lldb) p&#x2F;x object_getClass([Person alloc])</span><br><span class="line">(Class) $26 &#x3D; 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>
<p>答案是肯定的，Person类在内存中只有一份，也就是说所有的类对象在内存中都只有一份。</p>
<h2 id="1-3-类对象的isa"><a href="#1-3-类对象的isa" class="headerlink" title="1.3 类对象的isa"></a>1.3 类对象的isa</h2><p>接下来，我们继续寻找Person类对象的isa指向情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083f8</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x0000000100645d60 0x0001803000000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 &#x3D; 0x00000001000083d0</span><br><span class="line">(lldb) po 0x00000001000083d0</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>发现Person类对象的isa指向的还是Person，但是这个Person所在的内存地址与Person类对象不一样。</p>
<p>这里就出现了元类的概念（Meta Class）。</p>
<h2 id="1-4-元类的isa"><a href="#1-4-元类的isa" class="headerlink" title="1.4 元类的isa"></a>1.4 元类的isa</h2><p>我们继续寻找元类的isa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0x00000001000083d0是Person元类所在的内存</span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083d0</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x0000000100714d10 0x0002e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $9 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到NSObject的地址继续x&#x2F;4gx</span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a0f0</span><br><span class="line">0x10036a0f0: 0x000000010036a0f0 0x000000010036a140</span><br><span class="line">0x10036a100: 0x00000001007877b0 0x0003e03100000007</span><br></pre></td></tr></table></figure>

<p>使用相同的方法找到元类的<code>isa</code>指向的是<code>NSObject</code>，这个<code>NSObject</code>是类对象吗？</p>
<p>对<code>NSObject</code>继续<code>x/4gx</code>发现<code>isa</code>锁指向的内存地址是一样的。</p>
<p>我们通过<code>object_getClass([[NSObject alloc] init])</code>来看看<code>NSObject</code>类对象的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取NSObject类的地址，与p&#x2F;x NSObject.class效果一致</span><br><span class="line">(lldb) p&#x2F;x object_getClass([NSObject alloc])</span><br><span class="line">(Class) $13 &#x3D; 0x000000010036a140 NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010036a140</span><br><span class="line">0x10036a140: 0x000000010036a0f0 0x0000000000000000</span><br><span class="line">0x10036a150: 0x0000000100786740 0x0002801000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从这里开始，就已经跟上面的内存地址重复了</span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $14 &#x3D; 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>到这里，是不是看明白了点啥？<code>NSObject</code>类对象也有指向<code>NSObject</code>的元类，<code>Person</code>的元类的<code>isa</code>指向的是<code>NSObject</code>的元类。</p>
<h3 id="1-5-使用相同的办法查看Teacher的isa"><a href="#1-5-使用相同的办法查看Teacher的isa" class="headerlink" title="1.5 使用相同的办法查看Teacher的isa"></a>1.5 使用相同的办法查看Teacher的isa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里使用简单的方式，直接使用Teacher类</span><br><span class="line">(lldb) x&#x2F;4gx Teacher.class</span><br><span class="line">0x100008380: 0x00000001000083a8 0x00000001000083f8</span><br><span class="line">0x100008390: 0x0000000100362370 0x0000803000000000</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x00000001000083a8 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $18 &#x3D; 0x00000001000083a8</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000001000083a8</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001000083a8</span><br><span class="line">0x1000083a8: 0x000000010036a0f0 0x00000001000083d0</span><br><span class="line">0x1000083b8: 0x0000000101138140 0x0001e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $20 &#x3D; 0x000000010036a0f0</span><br><span class="line">&#x2F;&#x2F; 这里又指向了NSObject</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>看到这里应该发现了点东西吧。实例对象的isa-&gt;类对象的isa-&gt;NSObject的isa，中间类对象与继承没有一丢丢关系。</p>
<h3 id="1-6-类的继承链"><a href="#1-6-类的继承链" class="headerlink" title="1.6 类的继承链"></a>1.6 类的继承链</h3><p>上面我们查看了isa的走向，接下来看一下继承链。首先看一下类的继承关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void testSuperClass(void)&#123;</span><br><span class="line">    Teacher *t &#x3D; [Teacher alloc];</span><br><span class="line">    Person  *p &#x3D; [Person alloc];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Teacher.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Person.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(NSObject.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里输出一下对应类的<code>superclass</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">NSObject</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>

<p>从打印出来的信息可以看到:</p>
<ul>
<li>Teacher   -&gt; superclass = Person</li>
<li>Person    -&gt; superClass = NSObject</li>
<li>NSObject  -&gt; superClass = null</li>
</ul>
<h3 id="1-7-元类的继承链"><a href="#1-7-元类的继承链" class="headerlink" title="1.7 元类的继承链"></a>1.7 元类的继承链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void testNSObject(void) &#123;</span><br><span class="line">    &#x2F;&#x2F; NSObject实例对象</span><br><span class="line">    NSObject *object1 &#x3D; [NSObject alloc];</span><br><span class="line">    &#x2F;&#x2F; NSObject类</span><br><span class="line">    Class cls &#x3D; object_getClass(object1);</span><br><span class="line">    &#x2F;&#x2F; NSObject元类</span><br><span class="line">    Class metaClass &#x3D; object_getClass(cls);</span><br><span class="line">    &#x2F;&#x2F; NSObject根元类</span><br><span class="line">    Class rootMetaClass &#x3D; object_getClass(metaClass);</span><br><span class="line">    &#x2F;&#x2F; NSObject根根元类</span><br><span class="line">    Class rootRootMetaClass &#x3D; object_getClass(rootMetaClass);</span><br><span class="line">    NSLog(@&quot;\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类&quot;,object1,cls,metaClass,rootMetaClass,rootRootMetaClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Person元类</span><br><span class="line">    Class pMetaClass &#x3D; object_getClass(Person.class);</span><br><span class="line">    Class psuperClass &#x3D; class_getSuperclass(pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,pMetaClass,pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,psuperClass,psuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Teacher -&gt; Person -&gt; NSObject</span><br><span class="line">    &#x2F;&#x2F; 元类也有一条继承链</span><br><span class="line">    Class tMetaClass &#x3D; object_getClass(Teacher.class);</span><br><span class="line">    Class tsuperClass &#x3D; class_getSuperclass(tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tMetaClass,tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tsuperClass,tsuperClass);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; NSObject 根类特殊情况</span><br><span class="line">    Class nsuperClass &#x3D; class_getSuperclass(NSObject.class);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,nsuperClass,nsuperClass);</span><br><span class="line">    &#x2F;&#x2F; 根元类 -&gt; NSObject</span><br><span class="line">    Class rnsuperClass &#x3D; class_getSuperclass(metaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,rnsuperClass,rnsuperClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下输出结果：</p>
<ol>
<li><p>首先输出的NSObject的isa走位。NSObject实例对象 -&gt; 类 -&gt; 元类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x10124ba40 实例对象</span><br><span class="line">0x10036a140 类</span><br><span class="line">0x10036a0f0 元类</span><br><span class="line">0x10036a0f0 根元类</span><br><span class="line">0x10036a0f0 根根元类</span><br></pre></td></tr></table></figure>

<p> 从这里的输出结果可以进一步判断出NSObject类对象的元类指向它自己。</p>
</li>
<li><p>Person类对象的元类 -&gt; super</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Person类对象的元类</span><br><span class="line">Person - 0x100008498</span><br><span class="line">&#x2F;&#x2F; Person类对象的元类 -&gt; super</span><br><span class="line">NSObject - 0x10036a0f0</span><br></pre></td></tr></table></figure>

<p> 从地址的打印信息可以看出来，person类的元类的super指向的是NSObject类的元类。</p>
</li>
<li><p>Teacher元类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Teacher类对象的元类</span><br><span class="line">Teacher - 0x100008470</span><br><span class="line">&#x2F;&#x2F; Teacher类对象的元类 -&gt; super</span><br><span class="line">Person - 0x100008498</span><br></pre></td></tr></table></figure>

<p> 从这里可以看出来，Teacher元类的super指向的Person的元类，地址信息都是相同的。</p>
</li>
</ol>
<p>从上面的流程可以看到，类的继承关系和对应元类的继承关系是相对应的。可以用一张图完美的诠释isa的走向和super的指向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="isa_metaclass.png" alt=""></p>
<ul>
<li>每个实例对象的isa指针指向与之对应的类对象(Class)。</li>
<li>每个类对象(Class)都有一个isa指针指向一个唯一的元类(Meta Class)。</li>
<li>每一个元类(Meta Class)的isa指针都指向最上层的元类(Meta Class)（图中的NSObject的Meta Class）。最上层的元类(Meta Class)的isa指针指向自己，形成一个回路。</li>
<li>每一个元类(Meta Class)的Super Class指向它原本Class的Super Class的Meta Class。最上层的Meta Class的Super Class指向NSObject Class本身。</li>
<li>最上层的NSObject Class的Super Class指向nil。</li>
<li>只有Class才有继承关系，实例对象与实例对象不存在继承关系。</li>
<li>每一个类对象(Class)在内存中都只有一份。</li>
</ul>
<h1 id="2-通过源码分析"><a href="#2-通过源码分析" class="headerlink" title="2. 通过源码分析"></a>2. 通过源码分析</h1><p>接下来我们从objc的源码上分析这些都是什么东西。</p>
<h2 id="2-1-实例对象-id（Instance）"><a href="#2-1-实例对象-id（Instance）" class="headerlink" title="2.1 实例对象 id（Instance）"></a>2.1 实例对象 id（Instance）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>id 这个struct的定义本身就带了 个 ＊, 所以我们在使用其他NSObject类型的实例时需要在前加上 ＊, 使 id 时却不用 。</p>
<p>什么是objc_object?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class. </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体, 在这个struct中有 个 isa 指针,指向它的类别 Class。 </p>
<h2 id="2-2-类对象-Class"><a href="#2-2-类对象-Class" class="headerlink" title="2.2 类对象 Class"></a>2.2 类对象 Class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>Class的本质就是一个<code>objc_class</code>的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意，这个源码是被简化之后的。</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    Class getSuperclass() const &#123;</span><br><span class="line">        return superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setSuperclass(Class newSuperclass) &#123;</span><br><span class="line">        superclass &#x3D; newSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 用这个是无法获取rw_t，只能通过内存偏移获取bits，然后再获取rw_t</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isRootClass() &#123;</span><br><span class="line">        return getSuperclass() &#x3D;&#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isRootMetaclass() &#123;</span><br><span class="line">        return ISA() &#x3D;&#x3D; (Class)this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体，大家可能会觉得不对，这个源码是错的，不是我们经常看到的，里头没有那些我们常说的变量，methodLists、ivars等等。<br>大家看仔细了哦，下面这个实现基本都是大家常看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;  </span><br><span class="line">    ...</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE</span><br></pre></td></tr></table></figure>
<p>里头确实有ivars、methodLists等，但是这个是<code>OBJC2_UNAVAILABLE</code>（我们目前使用的Objective-C的版本是2.0版本）。其内部确实有这些东西的，我们一步步去探究。</p>
<p>继续回到上面的结构体，发现ISA变量被注释掉了，其实也没有影响的，因为<code>objc_class</code> 继承自 <code>objc_object</code>（内部有isa变量）。那我们的属性、方法是存放在哪了呢？</p>
<p>通过查看源码，我们看到有这么一个属性<code>class_data_bits_t bits;</code>，这个东西里可能存放着我们需要的东西。稍后我们做验证。</p>
<h2 id="2-3-元类-Meta-Class"><a href="#2-3-元类-Meta-Class" class="headerlink" title="2.3 元类 Meta Class"></a>2.3 元类 Meta Class</h2><p>OC中一切皆为对象<br>Class在设计中本身也是一个对象,也有superclass。而这个Class对应的类我们叫“元类”（Meta Class）。也就是说Class中有一个isa指向的是Meta Class。</p>
<h1 id="3-验证属性、方法、协议存在的位置"><a href="#3-验证属性、方法、协议存在的位置" class="headerlink" title="3 验证属性、方法、协议存在的位置"></a>3 验证属性、方法、协议存在的位置</h1><h2 id="3-1-验证之前的准备-源码"><a href="#3-1-验证之前的准备-源码" class="headerlink" title="3.1 验证之前的准备 - 源码"></a>3.1 验证之前的准备 - 源码</h2><p>在2.2小结我们说了属性、方法、等可能存在于<code>class_data_bits_t</code>这个结构体内部，我们查看它的源码：</p>
<h3 id="3-1-1-class-data-bits-t"><a href="#3-1-1-class-data-bits-t" class="headerlink" title="3.1.1 class_data_bits_t"></a>3.1.1 class_data_bits_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">            return maybe_rw-&gt;ro();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">            return (class_ro_t *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在public的方法中有<code>class_rw_t* data()</code>这个方法，我们进一步探索：</p>
<h3 id="3-1-2-class-rw-t"><a href="#3-1-2-class-rw-t" class="headerlink" title="3.1.2 class_rw_t"></a>3.1.2 class_rw_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t witness;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint16_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实如我们所说的，这里确实存在着我们想要的东西：methods()、properties()、protocols()等。</p>
<p>那我们该怎么获取到这些数据，来证明这些就是我们想要的东西呢？</p>
<h3 id="3-1-3-内存偏移"><a href="#3-1-3-内存偏移" class="headerlink" title="3.1.3 内存偏移"></a>3.1.3 内存偏移</h3><p>我们知道在c语言中，一个数组，获取数组中的某个元素的值有多种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">printf(&quot;index 1 &#x3D; %d - %d&quot;, a[1], *(a+1));</span><br></pre></td></tr></table></figure>

<p>比如上面的代码，我们可以直接输出某个元素的下标，也可以通过内存地址来偏移进行读取，同样，我们也可以采取地址偏移来获取<code>objc_class-&gt;bits</code>的值。</p>
<p>需要偏移多少呢？</p>
<p>第一个变量是Class，这是一个结构体，内部有一个isa指针，所以这是8个字节。<br>第二个变量是cache_t，我们进源码看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">private:</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;    &#x2F;&#x2F; 8</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask;      &#x2F;&#x2F; 4</span><br><span class="line">#if __LP64__</span><br><span class="line">            uint16_t                   _flags;          &#x2F;&#x2F; 2</span><br><span class="line">#endif</span><br><span class="line">            uint16_t                   _occupied;       &#x2F;&#x2F; 2</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache; &#x2F;&#x2F; 8</span><br><span class="line">    &#125;;</span><br><span class="line">...   </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实这些就能算出来我们需要多少字节，我已经标好了。静态变量和方法是没有算在结构体内部的哈，而且cache_t内部有一个共用体，所以其所占用的空间一共是8，再加上<code>_bucketsAndMaybeMask</code>变量一共是16个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class ISA;              &#x2F;&#x2F; 8</span><br><span class="line">Class superclass;       &#x2F;&#x2F; 8</span><br><span class="line">cache_t cache;          &#x2F;&#x2F; 16</span><br><span class="line">class_data_bits_t bits;</span><br></pre></td></tr></table></figure>
<p>所以8+8+16 = 32个字节。</p>
<p>也就是我们获取到的<code>objc_class</code>的isa指针，然后偏移32个字节，也就是<code>0x20</code>。当然也可以直接通过lldb输出<code>sizeOf(cache_t)</code>来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $4 &#x3D; 16</span><br></pre></td></tr></table></figure>

<p>我们做一下验证，看看属性在哪。其实需要注意的一点是，我们要获取的是类对象，从类对象中查看我们的变量、方法和协议等，而不是从实例对象中获取，因为实例对象是已经在内存中了，比如属性已经有了具体的值了。</p>
<h3 id="3-1-4-method-array-t"><a href="#3-1-4-method-array-t" class="headerlink" title="3.1.4 method_array_t"></a>3.1.4 method_array_t</h3><p>我们继续跟踪源码，查看<code>method_array_t</code>是个啥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_array_t() : Super() &#123; &#125;</span><br><span class="line">    method_array_t(method_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *beginCategoryMethodLists() const &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *endCategoryMethodLists(Class cls) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们猜测我们想要的数据是在<code>method_list_t</code>中，而<code>method</code>就是我们的每一个的方法等结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    struct big &#123;</span><br><span class="line">        SEL name;</span><br><span class="line">        const char *types;</span><br><span class="line">        MethodListIMP imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">public:</span><br><span class="line">    big &amp;big() const &#123;</span><br><span class="line">        ASSERT(!isSmall());</span><br><span class="line">        return *(struct big *)this;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 中间代码有删减</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-1-5-property-array-t"><a href="#3-1-5-property-array-t" class="headerlink" title="3.1.5 property_array_t"></a>3.1.5 property_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class property_array_t : </span><br><span class="line">    public list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;property_t, property_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    property_array_t() : Super() &#123; &#125;</span><br><span class="line">    property_array_t(property_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同methods方法，我们看一下property_t</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-protocol-array-t"><a href="#3-1-6-protocol-array-t" class="headerlink" title="3.1.6 protocol_array_t"></a>3.1.6 protocol_array_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class protocol_array_t : </span><br><span class="line">    public list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    protocol_array_t() : Super() &#123; &#125;</span><br><span class="line">    protocol_array_t(protocol_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>这三个分别对应<code>methods()、properties()、protocols()</code>方法，里头也一个共同点就是<code>protocol_array_t</code>。那我们重点看一下list_array_tt的结构。</p>
<h3 id="3-1-7-list-array-tt"><a href="#3-1-7-list-array-tt" class="headerlink" title="3.1.7 list_array_tt"></a>3.1.7 list_array_tt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class list_array_tt &#123;</span><br><span class="line">    struct array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        Ptr&lt;List&gt; lists[0];</span><br><span class="line"></span><br><span class="line">        static size_t byteSize(uint32_t count) &#123;</span><br><span class="line">            return sizeof(array_t) + count*sizeof(lists[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t byteSize() &#123;</span><br><span class="line">            return byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">    &#x2F;&#x2F; 这是一个迭代器</span><br><span class="line">    class iterator &#123;</span><br><span class="line">        const Ptr&lt;List&gt; *lists;</span><br><span class="line">        const Ptr&lt;List&gt; *listsEnd;</span><br><span class="line">        typename List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 迭代器相关的方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    union &#123;</span><br><span class="line">        Ptr&lt;List&gt; list;</span><br><span class="line">        uintptr_t arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>list_array_tt</code>结构体大概的可以看出来，<code>list_array_tt</code>只是一个list的封装。以<code>property_array_t</code>为例：</p>
<p><code>list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</code>就是一个存放了<code>property_t</code>类型的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    Ptr&lt;List&gt; list;</span><br><span class="line">    uintptr_t arrayAndFlag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>union</code>共用体才是一个list_array_tt对外暴露的真是结构，一会我们通过lldb进行验证。</p>
<h1 id="4-lldb-验证属性存放的位置"><a href="#4-lldb-验证属性存放的位置" class="headerlink" title="4 lldb 验证属性存放的位置"></a>4 lldb 验证属性存放的位置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line">0x100008418: 0x00000001012042e4 0x00000001000b9970</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过指针偏移0x20，也就是0x1000083f8+0x20，加上强制转换</span><br><span class="line">(lldb) p (class_data_bits_t *)0x100008418</span><br><span class="line">(class_data_bits_t *) $1 &#x3D; 0x0000000100008418</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到变量bits之后，通过class_data_bits_t -&gt; data()函数获取rw_t</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 &#x3D; 0x00000001012042e0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 看一下class_rw_t都有哪些值</span><br><span class="line">(lldb) p *$2</span><br><span class="line">(class_rw_t) $4 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2156396544</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4295000480</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; Teacher</span><br><span class="line">  nextSiblingClass &#x3D; NSBinder</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果有Subclass，则会有firstSubclass&#x3D;Teacher，如果没有子类则是nil</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们在class_rw_t中已经查看过源码，可以通过properties()获取属性列表</span><br><span class="line">(lldb) p $2-&gt;properties()</span><br><span class="line">(const property_array_t) $5 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008320</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000864</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合我们上面分析的结果，<code>property_array_t</code>输出的数据与上方<code>list_array_tt</code>内部的<code>union</code>共用体的结构是一直的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取属性列表</span><br><span class="line">(lldb) p $5.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $6 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008320</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">(lldb) p $6.ptr</span><br><span class="line">(property_list_t *const) $7 &#x3D; 0x0000000100008320</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; $8也就是我们的ptr内存储的列表</span><br></pre></td></tr></table></figure>

<p>但是<code>entsize_list_tt</code>又是什么类型？我们又该通过那种方式来获取我们最后想要的property呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt;&#x3D; count);</span><br><span class="line">        return *PointerModifier::modify(*this, (Element *)((uint8_t *)this + sizeof(*this) + i*entsize()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 注意。这里有一个 【&amp;】符号，调用getOrEnd，返回的是一个指针，进行转换</span><br><span class="line">    Element&amp; get(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt; count);</span><br><span class="line">        return getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>entsize_list_tt</code>内部有get方法，来获取其中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $8.get(0)</span><br><span class="line">(property_t) $9 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $8.get(1)</span><br><span class="line">(property_t) $10 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) </span><br><span class="line">(lldb) p $8.get(2)</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br></pre></td></tr></table></figure>

<p>到这里，我们就输出了我们定义的2个属性，但是变量却没有在这里提现出来。我们继续看ivar存放在哪。</p>
<h1 id="5-lldb-成员变量"><a href="#5-lldb-成员变量" class="headerlink" title="5. lldb 成员变量"></a>5. lldb 成员变量</h1><p>从上面我们知道属性都存放在<code>class_rw_t</code>中，在查看<code>class_data_bits_t</code>源码的时候，也有看到<code>class_ro_t</code>。那ivar会不会就在这里呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; class_data_bits_t 内部</span><br><span class="line"></span><br><span class="line">const class_ro_t *safe_ro() const &#123;</span><br><span class="line">    class_rw_t *maybe_rw &#x3D; data();</span><br><span class="line">    if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is rw</span><br><span class="line">        return maybe_rw-&gt;ro();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; maybe_rw is actually ro</span><br><span class="line">        return (class_ro_t *)maybe_rw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    union &#123;</span><br><span class="line">        const uint8_t * ivarLayout;</span><br><span class="line">        Class nonMetaclass;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;const char *&gt; name;</span><br><span class="line">    &#x2F;&#x2F; With ptrauth, this is signed if it points to a small list, but</span><br><span class="line">    &#x2F;&#x2F; may be unsigned if it points to a big list.</span><br><span class="line">    void *baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    &#x2F;&#x2F; 这里存放的是ivars</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了获取property的经验，这里就方便多了，我们按照相同的方式来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $1 (class_data_bits_t *) </span><br><span class="line">(lldb) p $1-&gt;safe_ro()</span><br><span class="line">(const class_ro_t *) $11 &#x3D; 0x00000001000081a0</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(const class_ro_t) $12 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 0</span><br><span class="line">  instanceStart &#x3D; 8</span><br><span class="line">  instanceSize &#x3D; 40</span><br><span class="line">  reserved &#x3D; 0</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    ivarLayout &#x3D; 0x0000000000000000</span><br><span class="line">    nonMetaclass &#x3D; nil</span><br><span class="line">  &#125;</span><br><span class="line">  name &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;const char *&gt; &#x3D; &quot;Person&quot; &#123;</span><br><span class="line">      Value &#x3D; 0x0000000100003edc &quot;Person&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList &#x3D; 0x00000001000081e8</span><br><span class="line">  baseProtocols &#x3D; 0x0000000000000000</span><br><span class="line">  ivars &#x3D; 0x0000000100008298</span><br><span class="line">  weakIvarLayout &#x3D; 0x0000000000000000</span><br><span class="line">  baseProperties &#x3D; 0x0000000100008320</span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE &#x3D; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从打印中的内容可以大致的猜测ivar应该存放在ivars。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $11.ivars</span><br><span class="line">(const ivar_list_t *const) $13 &#x3D; 0x0000000100008298</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $11-&gt;ivars</span><br><span class="line">(lldb) p $11-&gt;ivars</span><br><span class="line">(const ivar_list_t *const) $14 &#x3D; 0x0000000100008298</span><br><span class="line">(lldb) p *$14</span><br><span class="line">(const ivar_list_t) $15 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;ivar_t, ivar_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 32, count &#x3D; 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与property list是相同的结构</span><br><span class="line">(lldb) p $15.get(0)</span><br><span class="line">(ivar_t) $16 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008360</span><br><span class="line">  name &#x3D; 0x0000000100003f06 &quot;_hobby&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(1)</span><br><span class="line">(ivar_t) $17 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008368</span><br><span class="line">  name &#x3D; 0x0000000100003f0d &quot;_height&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f6f &quot;d&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(2)</span><br><span class="line">(ivar_t) $18 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008370</span><br><span class="line">  name &#x3D; 0x0000000100003f15 &quot;_age&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f71 &quot;i&quot;</span><br><span class="line">  alignment_raw &#x3D; 2</span><br><span class="line">  size &#x3D; 4</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(3)</span><br><span class="line">(ivar_t) $19 &#x3D; &#123;</span><br><span class="line">  offset &#x3D; 0x0000000100008378</span><br><span class="line">  name &#x3D; 0x0000000100003f1a &quot;_name&quot;</span><br><span class="line">  type &#x3D; 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw &#x3D; 3</span><br><span class="line">  size &#x3D; 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>到这里，我们也获取到了变量的位置，也说明了定义的属性会默认生成带下划线的同名变量。</p>
<p>接下来就是方法了。</p>
<h1 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $20 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x00000001000081e8</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与属性一致</span><br><span class="line">(lldb) p $20.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $21 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x00000001000081e8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $21.ptr</span><br><span class="line">(method_list_t *const) $22 &#x3D; 0x00000001000081e8</span><br><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $23.get(0)</span><br><span class="line">(method_t) $24 &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照属性的方式继续输出，结果<code>$23.get(0)</code>输出的确实空内容。</p>
<p>在说method_t时，结构体内部有<code>big()</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $23.get(0).big()</span><br><span class="line">(method_t::big) $26 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func1&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c90 (AL-Objc&#96;-[Person func1])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(1).big()</span><br><span class="line">(method_t::big) $27 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func2&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cc0 (AL-Objc&#96;-[Person func2])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(2).big()</span><br><span class="line">(method_t::big) $28 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;name&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f53 &quot;@16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003cf0 (AL-Objc&#96;-[Person name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(3).big()</span><br><span class="line">(method_t::big) $29 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setName:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f73 &quot;v24@0:8@16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d20 (AL-Objc&#96;-[Person setName:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(4).big()</span><br><span class="line">(method_t::big) $30 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;age&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f7e &quot;i16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d50 (AL-Objc&#96;-[Person age])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(5).big()</span><br><span class="line">(method_t::big) $31 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;setAge:&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f86 &quot;v20@0:8i16&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003d70 (AL-Objc&#96;-[Person setAge:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(6).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>我们在类中声明的方法都在<code>method_list_t</code>中，这里有我们自己声明的方法，还有属性自动生成的set和get方法。</p>
<p>发现这里并没有我们的类方法。因为类方法在元类里。</p>
<h1 id="7-类方法"><a href="#7-类方法" class="headerlink" title="7. 类方法"></a>7. 类方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取元类</span><br><span class="line">(lldb) p 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $33 &#x3D; 4295001040</span><br><span class="line">(lldb) po $33</span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;6gx $33</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x00000001006959d0 0x0002e03100000003</span><br><span class="line">0x1000083f0: 0x0000000101204304 0x00000001000083d0</span><br><span class="line">&#x2F;&#x2F; 获取元类的bits</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000083f0</span><br><span class="line">(class_data_bits_t *) $34 &#x3D; 0x00000001000083f0</span><br><span class="line">(lldb) p $34-&gt;data()</span><br><span class="line">(class_rw_t *) $35 &#x3D; 0x0000000101204300</span><br><span class="line">(lldb) p *$35</span><br><span class="line">(class_rw_t) $36 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 2684878849</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4302330705</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; 0x00000001000083a8</span><br><span class="line">  nextSiblingClass &#x3D; 0x00007fff883ac410</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $35-&gt;methods()</span><br><span class="line">(const method_array_t) $37 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008168</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295000424</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $37.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $38 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008168</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $38.ptr</span><br><span class="line">(method_list_t *const) $39 &#x3D; 0x0000000100008168</span><br><span class="line">(lldb) p *$39</span><br><span class="line">(method_list_t) $40 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 2)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; count &#x3D; 2告诉我们有2个</span><br><span class="line"></span><br><span class="line">(lldb) p $40.get(0).big()</span><br><span class="line">(method_t::big) $41 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func3&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c00 (AL-Objc&#96;+[Person func3])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(1).big()</span><br><span class="line">(method_t::big) $42 &#x3D; &#123;</span><br><span class="line">  name &#x3D; &quot;func4&quot;</span><br><span class="line">  types &#x3D; 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp &#x3D; 0x0000000100003c30 (AL-Objc&#96;+[Person func4])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(2).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2&#x2F;runtime&#x2F;objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>这里是获取类方法所在的位置。</p>
<h1 id="8-协议"><a href="#8-协议" class="headerlink" title="8 协议"></a>8 协议</h1><p>属性、变量、方法都已经有所了解，接下来看一下协议。把我们一开始注释的协议打开，重新运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;6gx Person.class</span><br><span class="line">0x1000088d0: 0x00000001000088a8 0x000000010036a140</span><br><span class="line">0x1000088e0: 0x0000000100362370 0x0000803400000000</span><br><span class="line">0x1000088f0: 0x0000000100604204 0x00000001000b9970</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000088f0</span><br><span class="line">(class_data_bits_t *) $4 &#x3D; 0x00000001000088f0</span><br><span class="line">(lldb) p $4-&gt;data()</span><br><span class="line">(class_rw_t *) $5 &#x3D; 0x0000000100604200</span><br><span class="line">(lldb) p $5-&gt;protocols()</span><br><span class="line">(const protocol_array_t) $6 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008560</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001440</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $6.list</span><br><span class="line">(const RawPtr&lt;protocol_list_t&gt;) $7 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008560</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $7.ptr</span><br><span class="line">(protocol_list_t *const) $8 &#x3D; 0x0000000100008560</span><br><span class="line">(lldb) p *$8</span><br><span class="line">(protocol_list_t) $9 &#x3D; (count &#x3D; 1, list &#x3D; protocol_ref_t [] @ 0x00007ff5f7e1e9f8)</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>到此时，就不知道怎么处理，我们看一下<code>protocol_list_t</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    &#x2F;&#x2F; count is pointer-sized by accident.</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0]; &#x2F;&#x2F; variable-size</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是其内部的主要结构。我们用<code>list[0]</code>打印一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $9.list[0]</span><br><span class="line">(protocol_ref_t) $11 &#x3D; 4295002464</span><br></pre></td></tr></table></figure>

<p>上面我们已经说过<code>protocol_ref_t</code>只是一个定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef uintptr_t protocol_ref_t;  &#x2F;&#x2F; protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>接下来强转一下，看是否可以转成<code>protocol_t *</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (protocol_t *)$11</span><br><span class="line">(protocol_t *) $12 &#x3D; 0x0000000100008960</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们查看protocol_t内部的结构有demangledName()方法.</span><br><span class="line">(lldb) p $12-&gt;demangledName()</span><br><span class="line">(const char *) $13 &#x3D; 0x0000000100003b51 &quot;PersonProtocol&quot;</span><br></pre></td></tr></table></figure>

<p>到这里呢，协议存放的位置也找到了。</p>
<h1 id="9-补充添加协议之后"><a href="#9-补充添加协议之后" class="headerlink" title="9. 补充添加协议之后"></a>9. 补充添加协议之后</h1><h2 id="9-1-多了4个属性"><a href="#9-1-多了4个属性" class="headerlink" title="9.1 多了4个属性"></a>9.1 多了4个属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $5-&gt;properties()</span><br><span class="line">(const property_array_t) $15 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100008710</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4295001872</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $16 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100008710</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $16.ptr</span><br><span class="line">(property_list_t *const) $17 &#x3D; 0x0000000100008710</span><br><span class="line">(lldb) p *$17</span><br><span class="line">(property_list_t) $18 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加协议之后，又返回去重新打印了一下属性列表，发现这里变成了7个。明明之前只有2个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前打印的数据</span><br><span class="line">(property_list_t) $8 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; &#x3D; (entsizeAndFlags &#x3D; 16, count &#x3D; 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上协议中定义的一个，加起来也才3个，为什么会变成7个？这7个又是哪个属性？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $18.get(0)</span><br><span class="line">(property_t) $19 &#x3D; (name &#x3D; &quot;name&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $18.get(1)</span><br><span class="line">(property_t) $20 &#x3D; (name &#x3D; &quot;age&quot;, attributes &#x3D; &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) p $18.get(2)</span><br><span class="line">(property_t) $21 &#x3D; (name &#x3D; &quot;p_address&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,C,N&quot;)</span><br><span class="line">(lldb) p $18.get(3)</span><br><span class="line">(property_t) $22 &#x3D; (name &#x3D; &quot;hash&quot;, attributes &#x3D; &quot;TQ,R&quot;)</span><br><span class="line">(lldb) p $18.get(4)</span><br><span class="line">(property_t) $23 &#x3D; (name &#x3D; &quot;superclass&quot;, attributes &#x3D; &quot;T#,R&quot;)</span><br><span class="line">(lldb) p $18.get(5)</span><br><span class="line">(property_t) $24 &#x3D; (name &#x3D; &quot;description&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br><span class="line">(lldb) p $18.get(6)</span><br><span class="line">(property_t) $25 &#x3D; (name &#x3D; &quot;debugDescription&quot;, attributes &#x3D; &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br></pre></td></tr></table></figure>

<p>发现，添加了协议之后，会增加<code>hash、superclass、description、debugDescription</code>4个属性。是因为我们定义的协议都遵循<code>&lt;NSObject&gt;</code>协议，在<code>&lt;NSObject&gt;</code>协议内部有这4个属性的声明。</p>
<h2 id="9-2-方法找不到了"><a href="#9-2-方法找不到了" class="headerlink" title="9.2 方法找不到了"></a>9.2 方法找不到了</h2><p>我们按照上面获取方法等顺序，结果在最后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $3 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100722d01</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4302449921</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $4 &#x3D; &#123;</span><br><span class="line">  ptr &#x3D; 0x0000000100722d01</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $4.ptr</span><br><span class="line">(method_list_t *const) $5 &#x3D; 0x0000000100722d01</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 0, count &#x3D; 2281701376)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在第6节的时候，输出过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 &#x3D; &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; &#x3D; (entsizeAndFlags &#x3D; 27, count &#x3D; 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共有7个，但是这里怎么变成了这么大的一个值？？？<br>有知道的大佬，欢迎指导，谢谢。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>添加协议之后<ul>
<li>多了4个属性</li>
<li>方法找不到了，待补充</li>
</ul>
</li>
</ul>
<p>这里我们以name的get方法为例子，说明一下这都是什么意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;</span><br></pre></td></tr></table></figure>

<p><img src="function_table.png" alt=""></p>
<blockquote>
<p>@16@0:8</p>
</blockquote>
<ul>
<li>‘@’：第一个@表示返回值，对象</li>
<li>‘16’：16个字节</li>
<li>‘@’：第二个@表示对象类型(id)</li>
<li>‘0’：我们知道@表示对象，0表示从0开始，占8个字节</li>
<li>‘:’：SEL，方法明</li>
<li>‘8’：表示从8开始，占8个字节，满足一共16个字节</li>
</ul>
<p>sel 和 imp<br>sel：方法名<br>imp：方法实现。函数指针地址</p>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>sel、imp的区别</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E9%80%86%E5%90%91/nx-6-dyld/" class="post-title-link" itemprop="url">nx-6-dyld</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 11:45:14" itemprop="dateCreated datePublished" datetime="2021-06-04T11:45:14+08:00">2021-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E9%80%86%E5%90%91/nx-5-MachO/" class="post-title-link" itemprop="url">MachO</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 11:11:58" itemprop="dateCreated datePublished" datetime="2021-06-02T11:11:58+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 11:44:46" itemprop="dateModified" datetime="2021-06-04T11:44:46+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h1><p>Mach-O其实是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式， 类似于windows上的PE格式 (Portable Executable )， linux上的elf格式 (Executable and Linking Format)。</p>
<p>Mach-O是一种用于可执行文件、目标代码、动态库的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性。</p>
<h1 id="MachO格式的常见文件"><a href="#MachO格式的常见文件" class="headerlink" title="MachO格式的常见文件"></a>MachO格式的常见文件</h1><ul>
<li>目标文件.o </li>
<li>库文件<ul>
<li>.a</li>
<li>.dylib</li>
<li>.Framework</li>
</ul>
</li>
<li>可执行文件<ul>
<li>dyld</li>
<li>.dsym</li>
</ul>
</li>
</ul>
<p>关于静态库、动态库，这里有一篇文章，写的很好。<br><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a></p>
<h2 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h2><p>可以通过clang命令把对应的文件编译成mach-o文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -c test.c</span><br></pre></td></tr></table></figure>

<p>就会出现一个test.o的文件，这个就是mach-o类型的文件。</p>
<p>可以通过file命令查看文件类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ file [文件路径]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比如：</span><br><span class="line">$ file test.o</span><br><span class="line">test.o: Mach-O 64-bit object x86_64</span><br></pre></td></tr></table></figure>

<p>说明test.o文件是Mach-O，64位的object，适用于x86架构，64位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译为可执行文件</span><br><span class="line">$ clang text.o</span><br></pre></td></tr></table></figure>

<p>这个命令会吧test.o文件转换为可执行文件，类型为.out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.out</span><br><span class="line">test.out: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure>

<p>text.out是一个可执行文件。</p>
<h2 id="clang编译多个文件"><a href="#clang编译多个文件" class="headerlink" title="clang编译多个文件"></a>clang编译多个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo test.c test1.c</span><br></pre></td></tr></table></figure>

<p>就是把<code>test.c</code>和<code>test1.c</code>两个文件合并为一个可执行文件demo</p>
<p>如果更改链接到顺序，则生成的可执行文件是不同的，md5值不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -o demo1 test1.c test.c</span><br></pre></td></tr></table></figure>

<p>可以查看一下两个文件的md5值，是不同的，命令为<code>md5 [filename]</code>。</p>
<p>也可以通过<code>objdump</code>命令查看内容是否一样，这个命令类似于<code>MachOView</code>工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ objdump --macho -d [可执行文件file name]</span><br><span class="line">&#x2F;&#x2F; 查看demo可执行文件</span><br><span class="line">$ objdump --macho -d demo</span><br></pre></td></tr></table></figure>

<h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><p>dyld（the dynamic link editor）是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作。而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。</p>
<h2 id="dsym文件"><a href="#dsym文件" class="headerlink" title="dsym文件"></a>dsym文件</h2><p>当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。</p>
<p>在release下，编译之后查看dsym文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file file HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O dSYM companion file arm_v7] [arm64:Mach-O 64-bit dSYM companion file arm64]</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture armv7):	Mach-O dSYM companion file arm_v7</span><br><span class="line">HookDemo.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;HookDemo (for architecture arm64):	Mach-O 64-bit dSYM companion file arm64</span><br></pre></td></tr></table></figure>

<p>这里出现了<code>universal binary</code>。这是个啥？就是通用二进制文件</p>
<h2 id="通用二进制文件"><a href="#通用二进制文件" class="headerlink" title="通用二进制文件"></a>通用二进制文件</h2><p>mac系统所支持的cpu及硬件平台发生了很大的变化，为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）,又称胖二进制（Fat Binary）。</p>
<ul>
<li>苹果公司提出的一种程序代码。能同时适用多种架构的二进制文件</li>
<li>同一个程序包中同时为多种架构提供最理想的性能。</li>
<li>因为需要储存多种代码，通用二进制应用程序通常比单一平台二进制的程序要大。但是由于两种架构有共通的非执行资源(代码以外的，图片等)，所以并不会达到单一版本的两倍之多。</li>
<li>而且由于执行中只调用一部分代码，运行起来也不需要额外的内存。</li>
</ul>
<p>在xcode中可以更改Mach-O Type：</p>
<p><img src="macho_xcode.jpg" alt=""></p>
<p>对于现在的Xcode来说，iOS11以上通过真机生成的可执行文件都是arm64架构，是单一架构。如果把最低版本修改为iOS10，重新真机编译，发现生成的可执行文件就是两种架构<code>armv7 + arm64</code>。</p>
<p>接下来，随便找个工程，release下编译，然后查看<code>HookDemo.app -&gt; HookDemo</code>可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file HookDemo</span><br><span class="line">HookDemo: Mach-O universal binary with 2 architectures: [arm_v7:Mach-O executable arm_v7] [arm64:Mach-O 64-bit executable arm64]</span><br><span class="line">HookDemo (for architecture armv7):	Mach-O executable arm_v7</span><br><span class="line">HookDemo (for architecture arm64):	Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>Targets -&gt; Build Setting - Architectures</code>修改架构，只不过目前来说都是arm64。可以添加armv7、armv7s。</p>
<p>armv7s是一种临时的支持iPhone5c上可用的架构。</p>
<p><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>
<p>原则上来说，架构都是向下兼容的。</p>
<h3 id="lipo命令拆分、合并通用二进制文件"><a href="#lipo命令拆分、合并通用二进制文件" class="headerlink" title="lipo命令拆分、合并通用二进制文件"></a>lipo命令拆分、合并通用二进制文件</h3><ul>
<li><p>查看Mach-O文件包含的架构信息</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info [MachO文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分某种架构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</span><br><span class="line">$ lipo HookDemo -thin armv7 -output HookDemo_armv7</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并多种架构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</span><br><span class="line">lipo -create HookDemo_armv7 HookDemo_arm64 -output HookDemo_v7_64</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以在通过file命令查看拆分、合并的文件。</p>
<h1 id="Macho文件结构"><a href="#Macho文件结构" class="headerlink" title="Macho文件结构"></a>Macho文件结构</h1><ul>
<li>Header ：包含该二进制文件的一般信息<ul>
<li>字节顺序、架构类型、加载指令的数量等。</li>
<li>使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么、文件类型是什么</li>
</ul>
</li>
<li>Load commands：包含加载所需要的指令（动态库、静态库等）<ul>
<li>内容包括区域的位置、符号表、动态符号表等</li>
</ul>
</li>
<li>Data ：内容包括区域的位置、符号表、动态符号表等<ul>
<li>包含Segement的具体数据</li>
</ul>
</li>
</ul>
<p><img src="macho_1.jpg" alt=""></p>
<p>接下来使用MachOView工具来分析可执行文件，有两种类型：</p>
<ol>
<li>通用二进制文件，则显示的是Fat Binary</li>
<li>单一架构的文件，直接显示对应的Executable</li>
</ol>
<p><img src="MachOView_Fat.jpg" alt=""></p>
<h2 id="Fat-Binary"><a href="#Fat-Binary" class="headerlink" title="Fat Binary"></a>Fat Binary</h2><p>在上图中可以看到，首先是一个Fat Header的结构。在header中，可以猜到两个架构之间必定存在某些关联。</p>
<p>armv7：offset=16384，size=79872<br>arm64：offset=98304，size=80672</p>
<p>arm64是从98304开始的，比armv7多了 98304-(16384+79872)=2048，这个值只是一个差值，而从偏移的差值来看98304-16384=81920 = 5 * 16 * 1024</p>
<p>正好是5页数据，iOS中1页是16k，所以armv7是5页数据，最后的2038只是第5页数据没有排满而已。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>接下来看看arm64架构下的内容：</p>
<p><img src="MachOView.png" alt=""></p>
<p>在Xcode中，我们可以在<code>loader.h</code>文件中找到Header的相关信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;      &#x2F;* 魔数，快速定位属于64还是32位 *&#x2F;</span><br><span class="line">    cpu_type_t  cputype;    &#x2F;* CPU类型 *&#x2F;</span><br><span class="line">    cpu_subtype_t   cpusubtype; &#x2F;* CPU的具体类型 *&#x2F;</span><br><span class="line">    uint32_t    filetype;   &#x2F;* 文件类型，比如可执行文件 *&#x2F;</span><br><span class="line">    uint32_t    ncmds;      &#x2F;* Load Commands的条数 *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds; &#x2F;* Load Commands的大小 *&#x2F;</span><br><span class="line">    uint32_t    flags;      &#x2F;* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 *&#x2F;</span><br><span class="line">    uint32_t    reserved;   &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只放了arm64下的内容，当然也有32位的，内容基本一致。<br>这里需要注意的是filettype类型，是一组宏定义，也能找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define	MH_OBJECT	0x1		&#x2F;* relocatable object file *&#x2F; object文件</span><br><span class="line">#define	MH_EXECUTE	0x2		&#x2F;* demand paged executable file *&#x2F; 可执行文件</span><br><span class="line">#define	MH_FVMLIB	0x3		&#x2F;* fixed VM shared library file *&#x2F;</span><br><span class="line">#define	MH_CORE		0x4		&#x2F;* core file *&#x2F;</span><br><span class="line">#define	MH_PRELOAD	0x5		&#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#define	MH_DYLIB	0x6		&#x2F;* dynamically bound shared library *&#x2F; dylib文件</span><br><span class="line">#define	MH_DYLINKER	0x7		&#x2F;* dynamic link editor *&#x2F;</span><br><span class="line">#define	MH_BUNDLE	0x8		&#x2F;* dynamically bound bundle file *&#x2F;</span><br><span class="line">#define	MH_DYLIB_STUB	0x9		&#x2F;* shared library stub for static</span><br><span class="line">					   linking only, no section contents *&#x2F;</span><br><span class="line">#define	MH_DSYM		0xa		&#x2F;* companion file with only debug</span><br><span class="line">					   sections *&#x2F; dsym文件</span><br><span class="line">#define	MH_KEXT_BUNDLE	0xb		&#x2F;* x86_64 kexts *&#x2F;</span><br><span class="line">#define MH_FILESET	0xc		&#x2F;* a file composed of other Mach-Os to</span><br><span class="line">					   be run in the same userspace sharing</span><br><span class="line">					   a single linkedit. *&#x2F;</span><br></pre></td></tr></table></figure>

<p>所以当看到0x2时，标识的就是可执行文件。在MachOView中，在Header中，可以看到对应的数据信息。</p>
<h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><table>
<thead>
<tr>
<th align="left">LoadCommands</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LC_SEGMENT_64</td>
<td align="left">将文件中（32位或64位）的段映射到进程地址空间中，<br>主要分为<strong>TEXT、</strong>DATA、LINKEDIT几大块</td>
</tr>
<tr>
<td align="left">LC_DYLD_INFO_ONLY</td>
<td align="left">动态链接相关信息</td>
</tr>
<tr>
<td align="left">LC_SYMTAB</td>
<td align="left">符号地址</td>
</tr>
<tr>
<td align="left">LC_DYSYMTAB</td>
<td align="left">动态符号表地址</td>
</tr>
<tr>
<td align="left">LC_LOAD_DYLINKER</td>
<td align="left">使用谁加载，我们使用dyld</td>
</tr>
<tr>
<td align="left">LC_UUID</td>
<td align="left">Mach-O文件的唯一识别标识 UUID</td>
</tr>
<tr>
<td align="left">LC_VERSION_MIN_MACOSX</td>
<td align="left">支持最低的操作系统版本</td>
</tr>
<tr>
<td align="left">LC_SOURCE_VERSION</td>
<td align="left">源代码版本</td>
</tr>
<tr>
<td align="left">LC_MAIN</td>
<td align="left">设置程序主线程的入口地址和栈大小<br>当别人的app做了防护时，运行就是闪退，这个时候就需要从这里找切入点</td>
</tr>
<tr>
<td align="left">LC_ENCRYPTION_INFO_64</td>
<td align="left">加密信息</td>
</tr>
<tr>
<td align="left">LC_LOAD_DYLIB</td>
<td align="left">依赖库的路径，包含三方库</td>
</tr>
<tr>
<td align="left">LC_FUNCTION_STARTS</td>
<td align="left">函数起始地址表</td>
</tr>
<tr>
<td align="left">LC_CODE_SIGNATURE</td>
<td align="left">代码签名</td>
</tr>
</tbody></table>
<h3 id="LC-SEGMENT-64"><a href="#LC-SEGMENT-64" class="headerlink" title="LC_SEGMENT_64"></a>LC_SEGMENT_64</h3><p>这里面包含了一些基本信息：</p>
<ul>
<li><code>VM Address</code>：虚拟内存地址</li>
<li><code>VM Size</code>：(虚拟内存)大小为4G</li>
<li><code>File Offset</code>：数据在文件中的偏移地址</li>
<li><code>File Size</code>：数据在文件中的大小</li>
</ul>
<h3 id="LC-DYLD-INFO-ONLY"><a href="#LC-DYLD-INFO-ONLY" class="headerlink" title="LC_DYLD_INFO_ONLY"></a>LC_DYLD_INFO_ONLY</h3><p>这里主要说一下<code>Rebase Info Offset</code>，这个是重定向的偏移地址。</p>
<p>系统为了安全，在运行时，把Mach-O放在虚拟内存中，会随机生成一个<code>ASLR</code>，在运行时会进行重定向，比如查找字符串、方法等，都需要重定向，而重定向的方式是<code>ASLR</code>+<code>Rebase Info Offset</code>的值。</p>
<h2 id="Section64"><a href="#Section64" class="headerlink" title="Section64"></a>Section64</h2><p>主要氛围两大部分：</p>
<p>###__TEXT</p>
<p>主要存放：代码、字符常量、类、方法等。</p>
<table>
<thead>
<tr>
<th align="left">Section</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__TEXT, __text</td>
<td align="left">主程序代码段</td>
</tr>
<tr>
<td align="left">__TEXT, __stubs</td>
<td align="left">Stub可以理解为一段占位空间，placeholder，用于符号的lazy binding。</td>
</tr>
<tr>
<td align="left">__TEXT, __stubs_helper</td>
<td align="left">辅助绑定</td>
</tr>
<tr>
<td align="left">__TEXT, __cstring</td>
<td align="left">C语言字符串</td>
</tr>
<tr>
<td align="left">__TEXT, __entitlements</td>
<td align="left">__entitlements</td>
</tr>
<tr>
<td align="left">__TEXT, __unwind_info</td>
<td align="left">C语言字符串</td>
</tr>
<tr>
<td align="left">__TEXT, __const</td>
<td align="left">常量段（const修饰）</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_classname</td>
<td align="left">OC的类名</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_methname</td>
<td align="left">OC方法名称</td>
</tr>
<tr>
<td align="left">__TEXT, __objc_methtype</td>
<td align="left">OC方法类型，即方法签名</td>
</tr>
</tbody></table>
<h3 id="DATA"><a href="#DATA" class="headerlink" title="__DATA:"></a>__DATA:</h3><table>
<thead>
<tr>
<th align="left">Section</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__DATA_CONST, __got</td>
<td align="left">__got</td>
</tr>
<tr>
<td align="left">__DATA, __got</td>
<td align="left">__got</td>
</tr>
<tr>
<td align="left"><strong>DATA</strong>data</td>
<td align="left">已初始化的全局变量。static int a = 1;</td>
</tr>
<tr>
<td align="left">__DATA, __bss</td>
<td align="left">未初始化的静态变量。static int a;</td>
</tr>
<tr>
<td align="left">__DATA, __const</td>
<td align="left">常量。 char * const p = “foo”;</td>
</tr>
<tr>
<td align="left">__DATA, __cfstring</td>
<td align="left">字符串（CFStringRefs）</td>
</tr>
<tr>
<td align="left">__DATA, __common</td>
<td align="left">未初始化的外部全局变量。 int a;</td>
</tr>
<tr>
<td align="left">__DATA, __la_symbol_ptr</td>
<td align="left">懒绑定的符号指针表。</td>
</tr>
<tr>
<td align="left">__DATA, __nl_symbol_ptr</td>
<td align="left">非懒绑定的符号指针表。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_classlist</td>
<td align="left">OC的类列表，存储一个个指向objc_class结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_nlclslist</td>
<td align="left">OC的类列表，+load相关？</td>
</tr>
<tr>
<td align="left">__DATA, __objc_catlist</td>
<td align="left">OC的category列表，存储一个个指向__objc_category结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_protolist</td>
<td align="left">OC的协议列表，存储一个个指向protocol_t结构体的指针</td>
</tr>
<tr>
<td align="left">__DATA, __objc_imginfo</td>
<td align="left">OC的image信息</td>
</tr>
<tr>
<td align="left">__DATA, __objc_selrefs</td>
<td align="left">哪些SEL对应的字符串被引用了</td>
</tr>
<tr>
<td align="left">__DATA, __objc_classrefs</td>
<td align="left">类的引用，即msg_objSend相关</td>
</tr>
<tr>
<td align="left">__DATA, __objc_superrefs</td>
<td align="left">super引用，记录了super方法调用的类。<br>如ViewController中的viewDidLoad中调用了<code>[super viewDidLoad]</code>，<br>则ViewController class即被记录。<br>也可以理解为objc_msgSendSuper相关。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_protorefs</td>
<td align="left">协议引用</td>
</tr>
<tr>
<td align="left">__DATA, __objc_ivar</td>
<td align="left">成员变量</td>
</tr>
<tr>
<td align="left">__DATA, __objc_const</td>
<td align="left">这里的const与<code>__TEXT-&gt;const</code>完全不同。<br><code>__objc_const</code>指的是OC内存布局中的不可变部分，即class_ro_t类型。</td>
</tr>
<tr>
<td align="left">__DATA, __objc_data</td>
<td align="left">保存类所需的数据？</td>
</tr>
</tbody></table>
<p>篇幅原因，动态加载以及符号表下一篇再介绍。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Mach-O简介</li>
<li>clang命令<ul>
<li>编译成点O文件：$ clang -c test.c</li>
<li>把点O文件编译为可执行文件：$ clang text.o</li>
<li>查看文件类型：$ file text.out</li>
</ul>
</li>
<li>lipo命令<ul>
<li>查看二进制文件 $ lipo -info [MachO文件]</li>
<li>拆分为某一种架构：$ lipo [MachO文件] –thin [架构] –output [输出文件路径]</li>
<li>合并多种架构：$ lipo -create [MachO文件1] [MachO文件2] -output [生成的MachO文件]</li>
</ul>
</li>
<li>MachO就结构<ul>
<li>Header<ul>
<li>用于快速群定该文件的CPU类型、文件类型</li>
</ul>
</li>
<li>Load Commands<ul>
<li>指示加载器如何设置并且加载二进制数据</li>
</ul>
</li>
<li>Section64<ul>
<li>存放数据：代码、数据、字符串常量、类、方法等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.csdn.net/liyunxiangrxm/article/details/78918147" target="_blank" rel="noopener">iOS静态库 【.a 和framework】【超详细】</a><br><a href="https://www.cnblogs.com/lulushen/p/8135269.html" target="_blank" rel="noopener">iOS 指令集架构 armv6、armv7、armv7s、arm64、arm64e、x86_64、i386</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/OC%E5%8E%9F%E7%90%86/runloop/" class="post-title-link" itemprop="url">runloop</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 13:34:10" itemprop="dateCreated datePublished" datetime="2021-05-30T13:34:10+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:58" itemprop="dateModified" datetime="2021-05-31T10:29:58+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RunLoop是事件接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个RunLoop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。</p>
<p>RunLoop本质是一个 do-while循环，没事做就休息，来活了就干活。与普通的while循环是有区别的，普通的while循环会导致CPU进入忙等待状态，即一直消耗cpu，而RunLoop则不会，RunLoop是一种闲等待，即RunLoop具备休眠功能。</p>
<h2 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h2><ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（触摸、定时器、performSelector）</li>
<li>节省cpu资源，提供程序的性能，该做事就做事，该休息就休息</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>
<h2 id="runloop与线程"><a href="#runloop与线程" class="headerlink" title="runloop与线程"></a>runloop与线程</h2><p>通常情况下获取runloop的两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主运行循环</span><br><span class="line">CFRunLoopRef mainRunloop &#x3D; CFRunLoopGetMain();</span><br><span class="line">&#x2F;&#x2F; 当前运行循环</span><br><span class="line">CFRunLoopRef currentRunloop &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>

<p>接下来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    &#x2F;&#x2F; 这是一个静态变量</span><br><span class="line">    static CFRunLoopRef __main &#x3D; NULL; &#x2F;&#x2F; no retain needed</span><br><span class="line">    &#x2F;&#x2F; 没有获取到，则通过_CFRunLoopGet0函数去获取，参数是主线程</span><br><span class="line">    if (!__main) __main &#x3D; _CFRunLoopGet0(pthread_main_thread_np()); &#x2F;&#x2F; no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下<code>_CFRunLoopGet0</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如参数t不存在，则默认为主线程</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t &#x3D; pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建一个字典</span><br><span class="line">        CFMutableDictionaryRef dict &#x3D; CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        &#x2F;&#x2F; 创建mainLoop</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; dict : key value</span><br><span class="line">        &#x2F;&#x2F; 把main_thread和mainloop通过key-value的形式绑定</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从字典中通过线程获取run loop</span><br><span class="line">    CFRunLoopRef loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有则创建</span><br><span class="line">        CFRunLoopRef newLoop &#x3D; __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop &#x3D; (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有loop也要存，存的是新创建的。</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop &#x3D; newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 &#x3D;&#x3D; _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出，runloo只有两种类型，一种主线程的mainloop，还有就是其它runloop。</p>
<h2 id="runloop的创建"><a href="#runloop的创建" class="headerlink" title="runloop的创建"></a>runloop的创建</h2><p>接下来看runloop是怎么创建的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    CFRunLoopRef loop &#x3D; NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size &#x3D; sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop &#x3D; (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</span><br><span class="line">    &#x2F;&#x2F; 如果loop为空，则直接返回NULL</span><br><span class="line">    if (NULL &#x3D;&#x3D; loop) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; runloop属性赋值</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort &#x3D; __CFPortAllocate();</span><br><span class="line">    if (CFPORT_NULL &#x3D;&#x3D; loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems &#x3D; NULL;</span><br><span class="line">    loop-&gt;_currentMode &#x3D; NULL;</span><br><span class="line">    loop-&gt;_modes &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head &#x3D; NULL;</span><br><span class="line">    loop-&gt;_blocks_tail &#x3D; NULL;</span><br><span class="line">    loop-&gt;_counterpart &#x3D; NULL;</span><br><span class="line">    loop-&gt;_pthread &#x3D; t;</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    loop-&gt;_winthread &#x3D; GetCurrentThreadId();</span><br><span class="line">#else</span><br><span class="line">    loop-&gt;_winthread &#x3D; 0;</span><br><span class="line">#endif</span><br><span class="line">    rlm &#x3D; __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL !&#x3D; rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面又有了一个CFRunLoopRef,盲猜应该是结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            &#x2F;* locked for accessing mode list *&#x2F;</span><br><span class="line">    __CFPort _wakeUpPort;            &#x2F;&#x2F; used for CFRunLoopWakeUp</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              &#x2F;&#x2F; reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从定义中可以得出，一个RunLoop有多个Mode，意味着一个RunLoop需要处理多个事务，即一个Mode对应多个Item，而一个item中，包含了timer、source、observer，如图：</p>
<p><img src="runloop_1.jpg" alt=""></p>
<h3 id="mode类型"><a href="#mode类型" class="headerlink" title="mode类型"></a>mode类型</h3><p>其中mode在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code>和<code>NSRunLoopCommonModes</code>。</p>
<p><code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p>
<ul>
<li>NSDefaultRunLoopMode：默认的mode，正常情况下都是在这个mode</li>
<li>NSConnectionReplyMode</li>
<li>NSModalPanelRunLoopMode</li>
<li>NSEventTrackingRunLoopMode：使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</li>
<li>NSRunLoopCommonModes：伪模式，灵活性更好</li>
</ul>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><ul>
<li>Source0 表示 非系统事件，即用户自定义的事件</li>
<li>Source1 表示系统事件，主要负责底层的通讯，具备唤醒能力</li>
</ul>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    &#x2F;&#x2F;进入RunLoop</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),</span><br><span class="line">    &#x2F;&#x2F;即将处理Timers</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),</span><br><span class="line">    &#x2F;&#x2F;即将处理Source</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),</span><br><span class="line">    &#x2F;&#x2F;即将进入休眠</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),</span><br><span class="line">    &#x2F;&#x2F;被唤醒</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),</span><br><span class="line">    &#x2F;&#x2F;退出RunLoop</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mode对应的items"><a href="#mode对应的items" class="headerlink" title="mode对应的items"></a>mode对应的items</h3><ul>
<li>block：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></li>
<li>timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></li>
<li>source0： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></li>
<li>source1： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></li>
<li>主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></li>
<li>observer： <strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></li>
</ul>
<h3 id="以Timer为例"><a href="#以Timer为例" class="headerlink" title="以Timer为例"></a>以Timer为例</h3><p>在子线程创建的timer是没有办法一直执行的，而想让它继续执行，则需要添加到runloop中，并且run才行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">self.isStopping &#x3D; NO;</span><br><span class="line">NSThread *thread &#x3D; [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; thread.name &#x3D; nil 因为这个变量只是捕捉</span><br><span class="line">    &#x2F;&#x2F; LGThread *thread &#x3D; nil</span><br><span class="line">    &#x2F;&#x2F; thread &#x3D; 初始化 捕捉一个nil进来</span><br><span class="line">    NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">    NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;~~hello word&quot;);            &#x2F;&#x2F; 退出线程--结果runloop也停止了</span><br><span class="line">        if (self.isStopping) &#123;</span><br><span class="line">            [NSThread exit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">thread.name &#x3D; @&quot;lgcode.com&quot;;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<p>我们看一下addTimer是怎么操作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">oid CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</span><br><span class="line">    if (!__CFIsValid(rlt) || (NULL !&#x3D; rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop !&#x3D; rl)) return;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点 : kCFRunLoopCommonModes</span><br><span class="line">    if (modeName &#x3D;&#x3D; kCFRunLoopCommonModes) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是kCFRunLoopCommonModes 类型</span><br><span class="line">        CFSetRef set &#x3D; rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        </span><br><span class="line">        if (NULL &#x3D;&#x3D; rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            &#x2F;&#x2F; modeItems是空，则创建一个defalut</span><br><span class="line">            rl-&gt;_commonModeItems &#x3D; CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;runloop与mode 是一对多的， mode与item也是一对多的</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        if (NULL !&#x3D; set) &#123;</span><br><span class="line">            CFTypeRef context[2] &#x3D; &#123;rl, rlt&#125;;</span><br><span class="line">            &#x2F;* add new item to all common-modes *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;执行</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是非commonMode类型</span><br><span class="line">        &#x2F;&#x2F;查找runloop的模型</span><br><span class="line">        CFRunLoopModeRef rlm &#x3D; __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb &#x3D; kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal &#x3D; NULL;</span><br><span class="line">                rlm-&gt;_timers &#x3D; CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断mode是否匹配</span><br><span class="line">        if (NULL !&#x3D; rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            if (NULL &#x3D;&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop &#x3D; rl;</span><br><span class="line">            &#125; else if (rl !&#x3D; rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Normally we don&#39;t do this on behalf of clients, but for</span><br><span class="line">                &#x2F;&#x2F; backwards compatibility due to the change in timer handling...</span><br><span class="line">                if (rl !&#x3D; CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL !&#x3D; rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要目的就是把timer添加到对应的mode中。mode 和 item是一对多的关系，timer是item的一种。</p>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><p>接下来上源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    do &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是timer</span><br><span class="line">        else if (modeQueuePort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                &#x2F;&#x2F; Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果是source1</span><br><span class="line">        CFRunLoopSourceRef rls &#x3D; __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            mach_msg_header_t *reply &#x3D; NULL;</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            if (NULL !&#x3D; reply) &#123;</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__CFRunLoopDoTimers源码，主要是通过for循环，对单个timer进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;循环遍历，做下层单个timer的执行</span><br><span class="line">    for (CFIndex idx &#x3D; 0, cnt &#x3D; timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt &#x3D; (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        Boolean did &#x3D; __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled &#x3D; timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mode and rl are locked on entry and exit</span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    Boolean timerHandled &#x3D; false;</span><br><span class="line">    uint64_t oldFireTSR &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* Fire a timer *&#x2F;</span><br><span class="line">    CFRetain(rlt);</span><br><span class="line">    __CFRunLoopTimerLock(rlt);</span><br><span class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;&#x3D; mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop &#x3D;&#x3D; rl) &#123;</span><br><span class="line">    __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">        __CFRunLoopTimerFireTSRLock();</span><br><span class="line">        oldFireTSR &#x3D; rlt-&gt;_fireTSR;</span><br><span class="line">        __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">        </span><br><span class="line">        __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        &#x2F;&#x2F; 执行timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        if (doInvalidate) &#123;</span><br><span class="line">            CFRunLoopTimerInvalidate(rlt);      &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        if (context_release) &#123;</span><br><span class="line">            context_release(context_info);</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        __CFRunLoopTimerLock(rlt);</span><br><span class="line">        timerHandled &#x3D; true;</span><br><span class="line">        __CFRunLoopTimerUnsetFiring(rlt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在timer执行的位置打上断点，使用lldb -&gt; bt命令查看调用栈：</p>
<p><img src="runloop_2.jpg" alt=""></p>
<h3 id="timer的调用顺序"><a href="#timer的调用顺序" class="headerlink" title="timer的调用顺序"></a>timer的调用顺序</h3><ol>
<li>自定义的timer，设置Mode，并将其加入RunLoop中</li>
<li>在RunLoop的run方法执行时，会调用__CFRunLoopDoTimers执行所有timer</li>
<li>在__CFRunLoopDoTimers方法中，会通过for循环执行单个timer的操作</li>
<li>在__CFRunLoopDoTimer方法中，timer执行完毕后，会执行对应的timer回调函数</li>
</ol>
<p>是针对timer的执行分析，对于observer、block、source0、source1，其执行原理与timer是类似的</p>
<p><img src="runloop_3.jpg" alt=""></p>
<h1 id="runloop底层原理"><a href="#runloop底层原理" class="headerlink" title="runloop底层原理"></a>runloop底层原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;    &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.0e10 : 科学计数 1*10^10，很大的值</span><br><span class="line">        result &#x3D; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped !&#x3D; result &amp;&amp; kCFRunLoopRunFinished !&#x3D; result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runloop就是一个do-while循环。当stop或者执行完成之后，则退出循环。</p>
<p>看一下<code>CFRunLoopRunSpecific</code>的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     &#x2F;* DOES CALLOUT *&#x2F;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内部函数，进入loop，seconds是一个很大的值</span><br><span class="line">    result &#x3D; __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来又回到<code>__CFRunLoopRun</code>的代码，上面提到的逻辑只是针对timer的，这里详细的说明一下，使用伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;核心函数</span><br><span class="line">&#x2F;* rl, rlm are locked on entrance and exit *&#x2F;</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;通过GCD开启一个定时器，然后开始跑圈</span><br><span class="line">    dispatch_source_t timeout_timer &#x3D; NULL;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    int32_t retVal &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;处理事务,即处理items</span><br><span class="line">    do &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理timer事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将处理Source事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 判断有无端口消息(Source1)</span><br><span class="line">        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理消息</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 等待被唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 Observers: 被唤醒，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;else if (被GCD唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 处理gcd</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;else if (被source1唤醒)&#123;</span><br><span class="line">            &#x2F;&#x2F; 被Source1唤醒，处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunHandledSource;&#x2F;&#x2F;处理源</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunTimedOut;&#x2F;&#x2F;超时</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunStopped;&#x2F;&#x2F;停止</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunFinished;&#x2F;&#x2F;结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整理一下runloop的整体流程如下：</p>
<p><img src="runloop_4.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码下载</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/30/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/" class="post-title-link" itemprop="url">内存管理-自动释放池</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 10:05:30" itemprop="dateCreated datePublished" datetime="2021-05-30T10:05:30+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h1><p>新建一个工程，在main.m中就有一个autoreleasepool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过clang编译一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc main.m -o main.cpp</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">$ xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc main.m -o main-arm64.cpp</span><br></pre></td></tr></table></figure>

<p>我们打开对应的cpp文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    __AtAutoreleasePool() &#123;</span><br><span class="line">        atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 析构函数</span><br><span class="line">    ~__AtAutoreleasePool() &#123;</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        &#x2F;&#x2F; 是一个结构体</span><br><span class="line">         __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">&#123;__AtAutoreleasePool __autoreleasepool; &#125;</span><br></pre></td></tr></table></figure>

<p>__AtAutoreleasePool是一个结构体，有<code>构造函数</code> 和 <code>析构函数</code>，在结构体定义的对象在作用域结束后，会自动调用析构函数。</p>
<p>在源码中有这么一段话：</p>
<blockquote>
<p>  Autorelease pool implementation</p>
</blockquote>
<blockquote>
<p>  A thread’s autorelease pool is a stack of pointers.<br>  Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.<br>  A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.<br> The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary.<br> Thread-local storage points to the hot page, where newly autoreleased objects are stored. </p>
</blockquote>
<p>通过上述描述，可以大概的知道以下几点：</p>
<p>通过描述，有以下几点说明</p>
<ol>
<li>自动释放池 是一个 关于指针的栈结构</li>
<li>其中的指针是指要释放的对象或者 pool_boundary 哨兵（现在经常被称为 边界）</li>
<li>自动释放池是一个页的结构（虚拟内存中提及过） ，而且这个页是一个双向链表（表示有父节点 和 子节点，在类中有提及，即类的继承链）</li>
<li>自动释放池和线程有关系</li>
</ol>
<p>接下来看一下源码中的实现：</p>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都有一个<code>AutoreleasePoolPage</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#96;class AutoreleasePoolPage : private AutoreleasePoolPageData&#96;</span><br><span class="line"></span><br><span class="line">struct AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;用来校验AutoreleasePoolPage的结构是否完整</span><br><span class="line">    magic_t const magic;    &#x2F;&#x2F;16个字节，以结构体中的变量对齐后的值为准，m[4] &#x3D; 4*4 &#x3D;16字节</span><br><span class="line">    &#x2F;&#x2F;指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()</span><br><span class="line">    __unsafe_unretained id *next;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向当前线程</span><br><span class="line">    pthread_t const thread;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向父节点，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage * const parent;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;指向子节点，最后一个结点的child值为nil</span><br><span class="line">    AutoreleasePoolPage *child;&#x2F;&#x2F;8字节</span><br><span class="line">    &#x2F;&#x2F;表示深度，从0开始，往后递增1</span><br><span class="line">    uint32_t const depth;&#x2F;&#x2F;4字节</span><br><span class="line">    &#x2F;&#x2F;表示high water mark 最大入栈数量标记</span><br><span class="line">    uint32_t hiwat;&#x2F;&#x2F;4字节</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们在回过头看看<code>objc_autoreleasePoolPush</code></p>
<h2 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    &#x2F;&#x2F;判断是否有pool</span><br><span class="line">    if (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Each autorelease pool starts on a new pool page</span><br><span class="line">        &#x2F;&#x2F; 自动释放池从新池页面开始</span><br><span class="line">        &#x2F;&#x2F;如果没有，则创建</span><br><span class="line">        dest &#x3D; autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;压栈一个POOL_BOUNDARY，即压栈哨兵</span><br><span class="line">        dest &#x3D; autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER || *dest &#x3D;&#x3D; POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autoreleaseNewPage"><a href="#autoreleaseNewPage" class="headerlink" title="autoreleaseNewPage"></a>autoreleaseNewPage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建新页</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNewPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    &#x2F;&#x2F;如果存在，则压栈对象</span><br><span class="line">    if (page) return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#x2F;&#x2F;如果不存在，则创建页</span><br><span class="line">    else return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** hotPage方法 ********</span><br><span class="line">&#x2F;&#x2F;获取当前操作页</span><br><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前页</span><br><span class="line">    AutoreleasePoolPage *result &#x3D; (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    &#x2F;&#x2F;如果是一个空池，则返回nil，否则，返回当前线程的自动释放池</span><br><span class="line">    if ((id *)result &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;******** autoreleaseNoPage方法 ********</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; &quot;No page&quot; could mean no pool has been pushed</span><br><span class="line">    &#x2F;&#x2F; or an empty placeholder pool has been pushed and has no contents yet</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing a second pool over the empty placeholder pool</span><br><span class="line">        &#x2F;&#x2F; or pushing the first object into the empty placeholder pool.</span><br><span class="line">        &#x2F;&#x2F; Before doing that, push a pool boundary on behalf of the pool </span><br><span class="line">        &#x2F;&#x2F; that is currently represented by the empty placeholder.</span><br><span class="line">        pushExtraBoundary &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果对象不是哨兵对象，且没有Pool，则报错</span><br><span class="line">    else if (obj !&#x3D; POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place, </span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                     objc_thread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span><br><span class="line">    else if (obj &#x3D;&#x3D; POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;&#x2F;&#x2F;如果传入参数为哨兵</span><br><span class="line">        &#x2F;&#x2F; We are pushing a pool with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and alloc-per-pool debugging was not requested.</span><br><span class="line">        &#x2F;&#x2F; Install and return the empty pool placeholder.</span><br><span class="line">        return setEmptyPoolPlaceholder();&#x2F;&#x2F;设置空的占位符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We are pushing an object or a non-placeholder&#39;d pool.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    &#x2F;&#x2F;初始化第一页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    &#x2F;&#x2F;设置page为当前聚焦页</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push a boundary on behalf of the previously-placeholder&#39;d pool.</span><br><span class="line">    &#x2F;&#x2F;压栈哨兵的标识符为YES，则压栈哨兵对象</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        &#x2F;&#x2F;压栈哨兵</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object or pool.</span><br><span class="line">    &#x2F;&#x2F;压栈对象</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中autoreleaseNoPage方法中发现当前线程的自动释放池是通过AutoreleasePoolPage创建的，其定义中有构造方法，而构造方法的实现是通过父类AutoreleasePoolPageData的初始化方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;**********AutoreleasePoolPage构造方法**********</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),&#x2F;&#x2F;开始存储的位置</span><br><span class="line">                                objc_thread_self(),&#x2F;&#x2F;传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,&#x2F;&#x2F;如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">&#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        ASSERT(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        &#x2F;&#x2F;this 表示 新建页面，将当前页面的子节点 赋值为新建页面</span><br><span class="line">        parent-&gt;child &#x3D; this;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;**********AutoreleasePoolPageData初始化方法**********</span><br><span class="line">AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下几个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AutoreleasePoolPageData(begin(),&#x2F;&#x2F;开始存储的位置</span><br><span class="line">                                objc_thread_self(),&#x2F;&#x2F;传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,&#x2F;&#x2F;如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br></pre></td></tr></table></figure>


<ul>
<li><p><code>begin()</code>:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;页的开始位置</span><br><span class="line">id * begin() &#123;</span><br><span class="line">    &#x2F;&#x2F;等于 首地址+56（AutoreleasePoolPage类所占内存大小）</span><br><span class="line">    return (id *) ((uint8_t *)this+sizeof(*this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>objc_thread_self()</code>： 表示的是当前线程，而当前线程时通过tls获取</p>
</li>
<li><p><code>newParent</code>： 父节点</p>
</li>
<li><p>后面两个参数是通过父节点的深度、最大入栈个数计算depth以及hiwat</p>
</li>
</ul>
<h3 id="自动释放池内存结构"><a href="#自动释放池内存结构" class="headerlink" title="自动释放池内存结构"></a>自动释放池内存结构</h3><p>由于在ARC模式下，是无法手动调用autorelease，所以将Demo切换至MRC模式。<br><code>Build Settings</code> -&gt; <code>Objectice-C Automatic Reference Counting</code>设置为<code>NO</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动释放池打印</span><br><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;************运行代码************</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F;循环创建对象，并加入自动释放池</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">             NSObject *objc &#x3D; [[NSObject alloc] sutorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用</span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="autorelease_1.png" alt=""></p>
<p>查看自动释放池的内存结构，发现page的开始与第一个对象的地址差是0x38，转换成十进制刚好是56，也就是 AutoreleasePoolPage自己本身的内存大小。</p>
<p>但是打印的是5个对象，但是这里有6个。第一个<code>pool</code>是啥？</p>
<p>哨兵对象。只在第一页有，防止释放时越界。</p>
<p>接着我们修改i的最大值为505。发现第二页开始有1个数据了。<br>接着在继续修改最大值为504+506，发现第三页也开始有1个数据了。</p>
<p>所以第一页有哨兵对象，可以存504个对象。第二页之后可以存505个对象。</p>
<p>在源码中<code>AutoreleasePoolPage</code>-&gt;size可以看到一页的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">	static size_t const SIZE &#x3D; PAGE_MIN_SIZE;</span><br><span class="line"></span><br><span class="line">#define PAGE_MIN_SHIFT          12</span><br><span class="line">#define PAGE_MIN_SIZE           (1 &lt;&lt; PAGE_MIN_SHIFT)</span><br></pre></td></tr></table></figure>

<p>size = 1&lt;&lt;12 = 4096。</p>
<p>首地址是从0x38开始的，也就是56个字节，4096-46 = 4040 = 505 * 8<br>所以一页有506个对象。</p>
<p><img src="autorelease_2.jpg" alt=""></p>
<h3 id="autoreleaseFast压栈"><a href="#autoreleaseFast压栈" class="headerlink" title="autoreleaseFast压栈"></a>autoreleaseFast压栈</h3><p>push方法的第二步，第一步是创建，第二步是直接存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    &#x2F;&#x2F;判断页是否满了</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果未满，则压栈</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果满了，则安排新的页面</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;页不存在，则新建页</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前页没有满，则添加<code>add</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加释放对象</span><br><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    &#x2F;&#x2F;传入对象存储的位置</span><br><span class="line">    id *ret &#x3D; next;  &#x2F;&#x2F; faster than &#96;return next-1&#96; because of aliasing</span><br><span class="line">    &#x2F;&#x2F;将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置</span><br><span class="line">    *next++ &#x3D; obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果页满了则处理<code>autoreleaseFullPage</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full. </span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    ASSERT(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;do-while遍历循环查找界面是否满了</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;如果子页面存在，则将页面替换为子页面</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        &#x2F;&#x2F;如果子页面不存在，则新建页面</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置为当前操作页面</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    &#x2F;&#x2F;对象压栈</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="压栈流程"><a href="#压栈流程" class="headerlink" title="压栈流程"></a>压栈流程</h4><ol>
<li>如果页存在，且未满，则通过add方法压栈对象</li>
<li>如果页存在，且满了，则通过autoreleaseFullPage方法安排新的页面</li>
<li>如果页不存在，则通过autoreleaseNoPage方法创建新页</li>
</ol>
<h2 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 析构函数</span><br><span class="line">~__AtAutoreleasePool() &#123;</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在析构函数中传了一个参数，就是<code>atautoreleasepoolobj</code>对象，这样就可以和创建的autoreleasepool关联上了。接下来看一下pop的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;出栈</span><br><span class="line">static inline void</span><br><span class="line">pop(void *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">   &#x2F;&#x2F;判断对象是否是空占位符</span><br><span class="line">    if (token &#x3D;&#x3D; (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当是空占位符</span><br><span class="line">        &#x2F;&#x2F; Popping the top-level placeholder pool.</span><br><span class="line">        &#x2F;&#x2F;获取当前页</span><br><span class="line">        page &#x3D; hotPage();</span><br><span class="line">        if (!page) &#123;</span><br><span class="line">            &#x2F;&#x2F; Pool was never used. Clear the placeholder.</span><br><span class="line">            &#x2F;&#x2F;如果当前页不存在，则清除空占位符</span><br><span class="line">            return setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Pool was used. Pop its contents normally.</span><br><span class="line">        &#x2F;&#x2F; Pool pages remain allocated for re-use as usual.</span><br><span class="line">        &#x2F;&#x2F;如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置</span><br><span class="line">        page &#x3D; coldPage();</span><br><span class="line">        token &#x3D; page-&gt;begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;获取token所在的页</span><br><span class="line">        page &#x3D; pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stop &#x3D; (id *)token;</span><br><span class="line">    &#x2F;&#x2F;判断最后一个位置，是否是哨兵</span><br><span class="line">    if (*stop !&#x3D; POOL_BOUNDARY) &#123;</span><br><span class="line">        &#x2F;&#x2F;最后一个位置不是哨兵，即最后一个位置是一个对象</span><br><span class="line">        if (stop &#x3D;&#x3D; page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是第一个位置，且没有父节点，什么也不做</span><br><span class="line">            &#x2F;&#x2F; Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            &#x2F;&#x2F; 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            &#x2F;&#x2F; 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是第一个位置，且有父节点，则出现了混乱</span><br><span class="line">            &#x2F;&#x2F; Error. For bincompat purposes this is not </span><br><span class="line">            &#x2F;&#x2F; fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        return popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;出栈页</span><br><span class="line">    return popPage&lt;false&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下popPage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;出栈页面</span><br><span class="line">template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    if (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line">    &#x2F;&#x2F; 出栈当前操作页面对象</span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; memory: delete empty children 删除空子项</span><br><span class="line">    if (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        &#x2F;&#x2F; special case: delete everything during page-per-pool debugging</span><br><span class="line">        &#x2F;&#x2F;调试期间删除每个特殊情况下的所有池</span><br><span class="line">        &#x2F;&#x2F;获取当前页面的父节点</span><br><span class="line">        AutoreleasePoolPage *parent &#x3D; page-&gt;parent;</span><br><span class="line">        &#x2F;&#x2F;将当前页面杀掉</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        &#x2F;&#x2F;设置操作页面为父节点页面</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        &#x2F;&#x2F; special case: delete everything for pop(top)</span><br><span class="line">        &#x2F;&#x2F; when debugging missing autorelease pools</span><br><span class="line">        &#x2F;&#x2F;特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        &#x2F;&#x2F; hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop就是自动释放池创建的位置。拿到stop的位置后，释放到stop位置之后的所有对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;释放到stop位置之前的所有对象</span><br><span class="line">void releaseUntil(id *stop) </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Not recursive: we don&#39;t want to blow out the stack  </span><br><span class="line">    &#x2F;&#x2F; 不是递归的：我们不想破坏堆栈</span><br><span class="line">    &#x2F;&#x2F; if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    &#x2F;&#x2F;判断下一个对象是否等于stop，如果不等于，则进入while循环</span><br><span class="line">    while (this-&gt;next !&#x3D; stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; Restart from hotPage() every time, in case -release </span><br><span class="line">        &#x2F;&#x2F; autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象</span><br><span class="line">        &#x2F;&#x2F;获取当前操作页面，即hot页面</span><br><span class="line">        AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fixme I think this &#96;while&#96; can be &#96;if&#96;, but I can&#39;t prove it</span><br><span class="line">        &#x2F;&#x2F;如果当前页是空的</span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;将page赋值为父节点页</span><br><span class="line">            page &#x3D; page-&gt;parent;</span><br><span class="line">            &#x2F;&#x2F;并设置当前页为父节点页</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        &#x2F;&#x2F;next进行--操作，即出栈</span><br><span class="line">        id obj &#x3D; *--page-&gt;next;</span><br><span class="line">        &#x2F;&#x2F;将页索引位置置为SCRIBBLE，表示已经被释放</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        if (obj !&#x3D; POOL_BOUNDARY) &#123;</span><br><span class="line">            &#x2F;&#x2F;释放</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置当前页</span><br><span class="line">    setHotPage(this);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; we expect any children to be completely empty</span><br><span class="line">    for (AutoreleasePoolPage *page &#x3D; child; page; page &#x3D; page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下<code>kill</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;销毁</span><br><span class="line">void kill() </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Not recursive: we don&#39;t want to blow out the stack </span><br><span class="line">    &#x2F;&#x2F; if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F;获取最后一个页</span><br><span class="line">    while (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr &#x3D; page;</span><br><span class="line">        &#x2F;&#x2F;子节点 变成 父节点</span><br><span class="line">        page &#x3D; page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            &#x2F;&#x2F;子节点为nil</span><br><span class="line">            page-&gt;child &#x3D; nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr !&#x3D; this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autorelease-pop流程"><a href="#autorelease-pop流程" class="headerlink" title="autorelease pop流程"></a>autorelease pop流程</h3><ol>
<li>是否是空页，做容错处理</li>
<li>releaseUntil(stop)，按页倒序进行，循环释放所有对象，直到位置执行stop。先从child开始</li>
<li>页中的对象释放之后，page执行kill，循环删除child节点</li>
</ol>
<h2 id="autorelease底层"><a href="#autorelease底层" class="headerlink" title="autorelease底层"></a>autorelease底层</h2><p>看一下mrc下autorelease的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;如果不是对象，则直接返回</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    &#x2F;&#x2F;如果是小对象，也直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是小对象，则直接return，不处理。</li>
<li>如果是对象，执行<code>obj-&gt;autorelease()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    &#x2F;&#x2F; 自定义对象</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootAutorelease();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 系统</span><br><span class="line">    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义对象，执行<code>rootAutorelease</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否为小对象</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象执行<code>rootAutorelease2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行的还是<code>AutoreleasePoolPage</code>这个对象，调用<code>autorelease</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    static inline id autorelease(id obj)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(obj);</span><br><span class="line">        ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused &#x3D; autoreleaseFast(obj);</span><br><span class="line">        ASSERT(!dest  ||  dest &#x3D;&#x3D; EMPTY_POOL_PLACEHOLDER  ||  *dest &#x3D;&#x3D; obj);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的就是<code>autoreleaseFast</code>。就又回到了上面的压栈流程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>@autoreleasepool {} 等价于 {__AtAutoreleasePool __autoreleasepool; }，这是构造和析构函数</li>
<li>autorelease push压栈流程<ol>
<li>如果页存在，且未满，则通过add方法压栈对象</li>
<li>如果页存在，且满了，则通过autoreleaseFullPage方法安排新的页面</li>
<li>如果页不存在，则通过autoreleaseNoPage方法创建新页</li>
</ol>
</li>
<li>autorelease pop流程<ol>
<li>是否是空页，做容错处理</li>
<li>releaseUntil(stop)，按页倒序进行，循环释放所有对象，直到位置执行stop。先从child开始</li>
<li>页中的对象释放之后，page执行kill，循环删除child节点</li>
</ol>
</li>
<li>mrc下 autorelease原理<ol>
<li>判断是否为小对象，是直接return</li>
<li>执行<code>autoreleaseFast</code>，执行autorelease push压栈流程</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/29/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/29/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-29 19:35:15" itemprop="dateCreated datePublished" datetime="2021-05-29T19:35:15+08:00">2021-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h1><ol>
<li>ARC/MRC</li>
<li>TarggedPointer: 专门用来处理小对象，比如NSNumber、NSDate、（NSString中有一种是targeed pointer）</li>
<li>Nonpointer_isa：非指针类型的isa。主要用来优化64位地址。</li>
<li>SideTables：散列表。主要有两种类型的表，引用计数表，弱引用表。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; viewDidLoad添加</span><br><span class="line">- (void)taggedPointerDemo &#123;</span><br><span class="line">  self.queue &#x3D; dispatch_queue_create(&quot;com.cjl.cn&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i&lt;10000; i++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            &#x2F;&#x2F; alloc堆上，iOS优化之后变成 taggedpointer</span><br><span class="line">            &#x2F;&#x2F; nameStr是NSTaggedPointerString</span><br><span class="line">            self.nameStr &#x3D; [NSString stringWithFormat:@&quot;aaa&quot;];  </span><br><span class="line">             NSLog(@&quot;%@&quot;,self.nameStr);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;来了&quot;);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;10000; i++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            &#x2F;&#x2F; nameStr是NSCFString</span><br><span class="line">            self.nameStr &#x3D; [NSString stringWithFormat:@&quot;aa-加油&quot;];</span><br><span class="line">            NSLog(@&quot;%@&quot;,self.nameStr);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码啊，发现在<code>taggedPointerDemo</code>方法中没有问题，但是点击屏幕，执行了touchesBegan就发生了崩溃。虽然在多线程时有过类似的例子，是由于多次释放造成的。但是这里的根本原因是<code>nameStr</code>在底层的类型不一致导致的，分别在两个赋值的方法处打上断点，看看是什么类型。</p>
<ul>
<li>taggedPointerDemo方法中的nameStr类型是 NSTaggedPointerString，存储在常量区。因为nameStr在alloc分配时在堆区，由于较小，所以经过xcode中iOS的优化，成了NSTaggedPointerString类型，存储在常量区。</li>
<li>touchesBegan方法中的nameStr类型是 NSCFString类型，存储在堆上</li>
</ul>
<h2 id="NSString的类型"><a href="#NSString的类型" class="headerlink" title="NSString的类型"></a>NSString的类型</h2><ol>
<li>NSCFConstantString：字符串常量，是一种编译时常量，retainCount值很大，对其操作，不会引起引用计数变化，存储在字符串常量区。</li>
<li>NSCFString：是在运行时创建的NSString子类，创建后引用计数会加1，存储在堆上。</li>
<li>NSTaggedPointerString：标签指针，是苹果在64位环境下对NSString、NSNumber等对象做的优化。对于NSString对象来说，当字符串是由数字、英文字母组合且长度小于等于9时，会自动成为NSTaggedPointerString类型，存储在常量区。</li>
<li>当有中文或者其他特殊符号时，会直接成为__NSCFString类型，存储在堆区。</li>
</ol>
<h2 id="Tagged-Pointer小对象"><a href="#Tagged-Pointer小对象" class="headerlink" title="Tagged Pointer小对象"></a>Tagged Pointer小对象</h2><p>接下来看一下tagged pointer对象的引用计数相关逻辑。直接上源码：</p>
<p><code>void objc_setProperty</code> -&gt; <code>reallySetProperty</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; copy和mutableCopy处理</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot &#x3D;&#x3D; newValue) return;</span><br><span class="line">        &#x2F;&#x2F; retain操作</span><br><span class="line">        newValue &#x3D; objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; release操作</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看retain和release内部做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    &#x2F;&#x2F;判断是否是小对象，如果是，则直接返回对象</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    &#x2F;&#x2F;如果不是小对象，则retain</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;****************objc_release****************</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">void </span><br><span class="line">objc_release(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return;</span><br><span class="line">    &#x2F;&#x2F;如果是小对象，则直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return;</span><br><span class="line">    &#x2F;&#x2F;如果不是小对象，则release</span><br><span class="line">    return obj-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是Tagged Pointer小对象，不会对引用计数做处理。</p>
<h3 id="小对象地址分析"><a href="#小对象地址分析" class="headerlink" title="小对象地址分析"></a>小对象地址分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">NSString *str2 &#x3D; [NSString stringWithFormat:@&quot;啊&quot;];</span><br><span class="line">NSLog(@&quot;%p-%@&quot;,str1,str1);</span><br><span class="line">NSLog(@&quot;%p-%@&quot;,str2,str2);</span><br></pre></td></tr></table></figure>

<p>看一下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xd3c9816ac08c01c6-a</span><br><span class="line">0x6000033631e0-啊</span><br></pre></td></tr></table></figure>

<p>在类的加载时，其中的_read_images源码有一个方法对小对象进行了处理，即initializeTaggedPointerObfuscator方法。</p>
<p>查看一下源码：<code>_read_images</code> -&gt; <code>initializeTaggedPointerObfuscator</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">initializeTaggedPointerObfuscator(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) ||</span><br><span class="line">        &#x2F;&#x2F; Set the obfuscator to zero for apps linked against older SDKs,</span><br><span class="line">        &#x2F;&#x2F; in case they&#39;re relying on the tagged pointer representation.</span><br><span class="line">        DisableTaggedPointerObfuscation) &#123;</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &#x3D; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Pull random data into the variable, then shift away all non-payload bits.</span><br><span class="line">        arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,</span><br><span class="line">                       sizeof(objc_debug_taggedpointer_obfuscator));</span><br><span class="line">        &#x2F;&#x2F; _OBJC_TAG_MASK 进行混淆</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &amp;&#x3D; ~_OBJC_TAG_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局搜索<code>objc_debug_taggedpointer_obfuscator</code>，找到了encode和decode方法。分别是对tagged pointer的编码和解码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline uintptr_t</span><br><span class="line">_objc_decodeTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>encode时进行了一次<code>^</code>操作，decode时也进行了一次<code>^</code>操作。可以对值进行还原。</p>
<p>那我们分别打印一下decode后的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">NSLog(@&quot;%p-%@&quot;,str1,str1);</span><br><span class="line">NSLog(@&quot;0x%lx&quot;,_objc_decodeTaggedPointer_(str1));</span><br><span class="line"></span><br><span class="line">NSNumber *number1 &#x3D; @1;</span><br><span class="line">NSLog(@&quot;%@-%p-%@&quot;,object_getClass(number1),number1,number1);</span><br><span class="line">NSLog(@&quot;0x%lx&quot;,_objc_decodeTaggedPointer_(number3));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xe4742f5bd16235e6-a</span><br><span class="line">0xa000000000000611</span><br><span class="line"></span><br><span class="line">__NSCFNumber-0xf4742f5bd16233e5-1</span><br><span class="line">0xb000000000000012</span><br></pre></td></tr></table></figure>

<p>在源码中有一个判断条件，是否为TaggedPointer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline bool </span><br><span class="line">_objc_isTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;等价于 ptr &amp; 1左移63，即2^63，相当于除了64位，其他位都为0，即只是保留了最高位的值</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以0xa、0xb主要是用于判断是否是小对象taggedpointer，即判断条件，判断第64位上是否为1（taggedpointer指针地址即表示指针地址，也表示值）</p>
<p>0xa 转换成二进制为 1 010（64为为1，63~61后三位表示 tagType类型 - 2），表示NSString类型</p>
<p>0xb 转换为二进制为 1 011（64为为1，63~61后三位表示 tagType类型 - 3），表示NSNumber类型，这里需要注意一点，如果NSNumber的值是-1，其地址中的值是用补码表示的</p>
<p>这里可以通过_objc_makeTaggedPointer方法的参数tag类型objc_tag_index_t进入其枚举，其中 2表示NSString，3表示NSNumber</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;&#x3D; 201103L</span><br><span class="line">enum objc_tag_index_t : uint16_t</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t objc_tag_index_t;</span><br><span class="line">enum</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 60-bit payloads</span><br><span class="line">    OBJC_TAG_NSAtom            &#x3D; 0, </span><br><span class="line">    OBJC_TAG_1                 &#x3D; 1, </span><br><span class="line">    OBJC_TAG_NSString          &#x3D; 2,     &#x2F;&#x2F; NSString</span><br><span class="line">    OBJC_TAG_NSNumber          &#x3D; 3,     &#x2F;&#x2F; NSNumber</span><br><span class="line">    OBJC_TAG_NSIndexPath       &#x3D; 4, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID &#x3D; 5, </span><br><span class="line">    OBJC_TAG_NSDate            &#x3D; 6,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 60-bit reserved</span><br><span class="line">    OBJC_TAG_RESERVED_7        &#x3D; 7, </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 52-bit payloads</span><br><span class="line">    OBJC_TAG_Photos_1          &#x3D; 8,</span><br><span class="line">    OBJC_TAG_Photos_2          &#x3D; 9,</span><br><span class="line">    OBJC_TAG_Photos_3          &#x3D; 10,</span><br><span class="line">    OBJC_TAG_Photos_4          &#x3D; 11,</span><br><span class="line">    OBJC_TAG_XPC_1             &#x3D; 12,</span><br><span class="line">    OBJC_TAG_XPC_2             &#x3D; 13,</span><br><span class="line">    OBJC_TAG_XPC_3             &#x3D; 14,</span><br><span class="line">    OBJC_TAG_XPC_4             &#x3D; 15,</span><br><span class="line">    OBJC_TAG_NSColor           &#x3D; 16,</span><br><span class="line">    OBJC_TAG_UIColor           &#x3D; 17,</span><br><span class="line">    OBJC_TAG_CGColor           &#x3D; 18,</span><br><span class="line">    OBJC_TAG_NSIndexSet        &#x3D; 19,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload &#x3D; 0, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  &#x3D; 6, </span><br><span class="line">    OBJC_TAG_First52BitPayload &#x3D; 8, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  &#x3D; 263, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      &#x3D; 264</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>跟我们上面得到的结果是一样的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Tagged Pointer小对象类型（用于存储NSNumber、NSDate、小NSString），小对象指针不再是简单的地址，而是地址 + 值，即真正的值，它只是一个披着对象皮的普通变量而以。所以可以直接进行读取。优点是占用空间小，节省内存</li>
<li>Tagged Pointer小对象 不会进入retain 和 release，意味着不需要ARC进行管理，所以可以直接被系统自主的释放和回收。</li>
<li>Tagged Pointer的内存并不存储在堆中，而是在常量区中，也不需要malloc和free。</li>
<li>对于NSString类型，建议直接使用<code>@&quot;&quot;</code>初始化赋值。</li>
</ul>
<h1 id="SideTables-散列表"><a href="#SideTables-散列表" class="headerlink" title="SideTables 散列表"></a>SideTables 散列表</h1><p>SideTables是一个hash表。在weak修饰时会存放在SideTables这个表中。</p>
<p>对于OC正常的对象来说当执行retain操作时，当引用计数达到一定的值（256）时，则会存放在SideTables中。</p>
<p>我们接下来看一下retain 的流程</p>
<h2 id="retain流程"><a href="#retain流程" class="headerlink" title="retain流程"></a>retain流程</h2><p>看一些源码：进入<code>objc_retain</code> -&gt; <code>retain</code> -&gt; <code>rootRetain</code>查看源码实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">LWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line">    bool transcribeToSideTable &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;为什么有isa？因为需要对引用计数+1，即retain+1，而引用计数存储在isa的bits中，需要进行新旧isa的替换</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    &#x2F;&#x2F;重点</span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable &#x3D; false;</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">        &#x2F;&#x2F;判断是否为nonpointer isa</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果不是 nonpointer isa，直接操作散列表sidetable</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return (id)this;</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">            else return sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        &#x2F;&#x2F;dealloc源码</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        &#x2F;&#x2F;执行引用计数+1操作，即对bits中的 1ULL&lt;&lt;45（arm64） 即extra_rc，用于该对象存储引用计数值</span><br><span class="line">        newisa.bits &#x3D; addc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc++</span><br><span class="line">        &#x2F;&#x2F;判断extra_rc是否满了，carry是标识符</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; newisa.extra_rc++ overflowed</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Leave half of the retain counts inline and </span><br><span class="line">            &#x2F;&#x2F; prepare to copy the other half to the side table.</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            transcribeToSideTable &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F;如果extra_rc满了，则直接将满状态的一半拿出来存到extra_rc</span><br><span class="line">            newisa.extra_rc &#x3D; RC_HALF;</span><br><span class="line">            &#x2F;&#x2F;给一个标识符为YES，表示需要存储到散列表</span><br><span class="line">            newisa.has_sidetable_rc &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Copy the other half of the retain counts to the side table.</span><br><span class="line">        &#x2F;&#x2F;将另一半存在散列表的rc_half中，即满状态下是8位，一半就是1左移7位，即除以2</span><br><span class="line">        &#x2F;&#x2F;这么操作的目的在于提高性能，因为如果都存在散列表中，当需要release-1时，需要去访问散列表，每次都需要开解锁，比较消耗性能。extra_rc存储一半的话，可以直接操作extra_rc即可，不需要操作散列表。性能会提高很多</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程分析：</p>
<ol>
<li>isTaggedPointer直接返回。</li>
<li>不是nonpointer，直接存sideTable</li>
<li>是否正在释放，deallocating，返回nil</li>
<li>引用计数+1。</li>
<li>判断引用计数是否存满了，满了则变成一半，另一半存放在散列表中。</li>
</ol>
<p>之所以不直接把引用计数存放在散列表中，是因为对表的操作，需要用到锁，这是耗时操作。<br>如果每一个对象都需要一个散列表，也会造成性能问题。如果所有对象公用一个散列表，则其他数据可能不安全，所以也不会公用一个表。真机上最多有8个表。</p>
<h2 id="release流程"><a href="#release流程" class="headerlink" title="release流程"></a>release流程</h2><p>release流程与retain相反。</p>
<p><code>setProperty</code> -&gt; <code>reallySetProperty</code> -&gt; <code>objc_release</code> -&gt; <code>release</code> -&gt; <code>rootRelease</code> -&gt; <code>rootRelease</code>查看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool </span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return false;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">        &#x2F;&#x2F;判断是否是Nonpointer isa</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果不是，则直接操作散列表-1</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return false;</span><br><span class="line">            if (sideTableLocked) sidetable_unlock();</span><br><span class="line">            return sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        &#x2F;&#x2F;进行引用计数-1操作，即extra_rc-1</span><br><span class="line">        newisa.bits &#x3D; subc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc--</span><br><span class="line">        &#x2F;&#x2F;如果此时extra_rc的值为0了，则走到underflow</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; don&#39;t ClearExclusive()</span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    &#x2F;&#x2F; newisa.extra_rc-- underflowed: borrow from side table or deallocate</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; abandon newisa to undo the decrement</span><br><span class="line">    newisa &#x3D; oldisa;</span><br><span class="line">    &#x2F;&#x2F;判断散列表中是否存储了一半的引用计数</span><br><span class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            return rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Transfer retain count from side table to inline storage.</span><br><span class="line"></span><br><span class="line">        if (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; Need to start over to avoid a race against </span><br><span class="line">            &#x2F;&#x2F; the nonpointer -&gt; raw pointer transition.</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Try to remove some retain counts from the side table.</span><br><span class="line">        &#x2F;&#x2F;从散列表中取出存储的一半引用计数</span><br><span class="line">        size_t borrowed &#x3D; sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; To avoid races, has_sidetable_rc must remain set </span><br><span class="line">        &#x2F;&#x2F; even if the side table count is now zero.</span><br><span class="line"></span><br><span class="line">        if (borrowed &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Side table retain count decreased.</span><br><span class="line">            &#x2F;&#x2F; Try to add them to the inline count.</span><br><span class="line">            &#x2F;&#x2F;进行-1操作，然后存储到extra_rc中</span><br><span class="line">            newisa.extra_rc &#x3D; borrowed - 1;  &#x2F;&#x2F; redo the original decrement too</span><br><span class="line">            bool stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                &#x2F;&#x2F; Inline update failed. </span><br><span class="line">                &#x2F;&#x2F; Try it again right now. This prevents livelock on LL&#x2F;SC </span><br><span class="line">                &#x2F;&#x2F; architectures where the side table access itself may have </span><br><span class="line">                &#x2F;&#x2F; dropped the reservation.</span><br><span class="line">                isa_t oldisa2 &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 &#x3D; oldisa2;</span><br><span class="line">                if (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits &#x3D; </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</span><br><span class="line">                    if (!overflow) &#123;</span><br><span class="line">                        stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                &#x2F;&#x2F; Inline update failed.</span><br><span class="line">                &#x2F;&#x2F; Put the retains back in the side table.</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Decrement successful after borrowing from side table.</span><br><span class="line">            &#x2F;&#x2F; This decrement cannot be the deallocating decrement - the side </span><br><span class="line">            &#x2F;&#x2F; table lock and has_sidetable_rc bit ensure that if everyone </span><br><span class="line">            &#x2F;&#x2F; else tried to -release while we worked, the last one would block.</span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Side table is empty after all. Fall-through to the dealloc path.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;此时extra_rc中值为0，散列表中也是空的，则直接进行析构，即自动触发dealloc流程</span><br><span class="line">    &#x2F;&#x2F; Really deallocate.</span><br><span class="line">    &#x2F;&#x2F;触发dealloc的时机</span><br><span class="line">    if (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return overrelease_error();</span><br><span class="line">        &#x2F;&#x2F; does not actually return</span><br><span class="line">    &#125;</span><br><span class="line">    newisa.deallocating &#x3D; true;</span><br><span class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line"></span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送一个dealloc消息</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程分析如下：</p>
<ol>
<li><p>判断是否是Nonpointer isa，如果不是，则直接对散列表进行-1操作</p>
</li>
<li><p>如果是Nonpointer isa，则对extra_rc中的引用计数值进行-1操作，并存储此时的extra_rc状态到carry中</p>
</li>
<li><p>如果此时的状态carray为0，则走到underflow流程</p>
<p> underflow流程有以下几步：</p>
<ol>
<li>判断散列表中是否存储了一半的引用计数，如果是，则从散列表中取出存储的一半引用计数，进行-1操作，然后存储到extra_rc中</li>
<li>如果此时extra_rc没有值，散列表中也是空的，则直接进行析构，即dealloc操作，属于自动触发</li>
</ol>
</li>
</ol>
<h2 id="dealloc分析"><a href="#dealloc分析" class="headerlink" title="dealloc分析"></a>dealloc分析</h2><p>dealloc是在retainCount为0时系统自动触发的。</p>
<p><code>dealloc</code> -&gt; <code>_objc_rootDealloc</code> -&gt; <code>rootDealloc</code>查看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;对象要释放，需要做哪些事情？</span><br><span class="line">    &#x2F;&#x2F;1、isa - cxx - 关联对象 - 弱引用表 - 引用计数表</span><br><span class="line">    &#x2F;&#x2F;2、free</span><br><span class="line">    if (isTaggedPointer()) return;  &#x2F;&#x2F; fixme necessary?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果没有这些，则直接free</span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果有</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据条件判断是否有isa、cxx、关联对象、弱引用表、引用计数表，如果没有，则直接free释放内存</li>
<li>如果有，则进入object_dispose方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line">    &#x2F;&#x2F; 销毁实例而不会释放内存</span><br><span class="line">    objc_destructInstance(obj);</span><br><span class="line">    &#x2F;&#x2F;释放内存</span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_destructInstance</code>为了消耗实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        &#x2F;&#x2F;调用C ++析构函数</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        &#x2F;&#x2F;删除关联引用</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        &#x2F;&#x2F;释放</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在内部判断是否有析构函数，如果有则调用。</li>
<li>是否有关联对象，有的花移除关联对象。</li>
<li>执行clearDeallocating</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;判断是否为nonpointer isa</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for raw pointer isa.</span><br><span class="line">        &#x2F;&#x2F;如果不是，则直接释放散列表</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果是，清空弱引用表 + 散列表</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for non-pointer isa with weak refs and&#x2F;or side table data.</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clearDeallocating</code>的目的主要是为了清空散列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        &#x2F;&#x2F;清空弱引用表</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        &#x2F;&#x2F;清空引用计数</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空引用计数，情况弱引用表。</p>
<p>以上就是dealloc 的流程。</p>
<h2 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject *objc &#x3D; [NSObject alloc];</span><br><span class="line">NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)objc));</span><br></pre></td></tr></table></figure>

<p>上面输出的引用计数是多少？这是一个经典的面试题。</p>
<p>这里输出的结果是1。但是1是不对的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return _objc_rootRetainCount(self);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">inline uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    &#x2F;&#x2F;如果是nonpointer isa，才有引用计数的下层处理</span><br><span class="line">    if (bits.nonpointer) &#123;</span><br><span class="line">        &#x2F;&#x2F;alloc创建的对象引用计数为0，包括sideTable,所以对于alloc来说，是 0+1&#x3D;1，这也是为什么通过retaincount获取的引用计数为1的原因</span><br><span class="line">        uintptr_t rc &#x3D; 1 + bits.extra_rc;</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc +&#x3D; sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果不是，则正常返回</span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对象创建时，并没有存引用计数，bits.extra_rc还是0，当调用了retainCount时执行了<code>1 + bits.extra_rc</code>，所以就变成了1 。如果reatinCount=0，相当于创建成功之后就会被释放掉。</p>
<p>所以这里的答案应该是0。不管我有没有执行init操作，都是0 。在读的时候才会是1。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/27/OC%E5%8E%9F%E7%90%86/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/27/OC%E5%8E%9F%E7%90%86/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">启动优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-27 21:35:54" itemprop="dateCreated datePublished" datetime="2021-05-27T21:35:54+08:00">2021-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="虚拟内存-amp-物理内存"><a href="#虚拟内存-amp-物理内存" class="headerlink" title="虚拟内存 &amp; 物理内存"></a>虚拟内存 &amp; 物理内存</h2><p>我们在进程和物理内存之间增加一个中间层，这个中间层就是所谓的虚拟内存，主要用于解决当多个进程同时存在时，对物理内存的管理。提高了CPU的利用率，使多个进程可以同时、按需加载。</p>
<p>所以虚拟内存其本质就是一张虚拟地址和物理地址对应关系的映射表。</p>
<ul>
<li>每个进程都有一个独立的虚拟内存，从0开始，大小是4G固定的，每个虚拟内存又会划分为一个一个的页（page的大小在iOS中是16K，其他的是4K），每次加载都是以页为单位加载的，进程间是无法互相访问的，保证了进程间数据的安全性。</li>
<li>一个进程中，只有部分功能是活跃的，所以只需要将进程中活跃的页放入物理内存，避免物理内存的浪费。</li>
<li>当CPU需要访问数据时，首先是访问虚拟内存，然后通过虚拟内存去寻找真正的物理内存，然后对相应的物理地址进行访问</li>
<li>如果在访问时，虚拟地址的内容未加载到物理内存，会发生缺页异常（pagefault），此时需要先将数据载入到物理内存（这个过程是很快的），然后再读取。这样就避免了内存浪费</li>
</ul>
<p><img src="ram_map.jpg" alt=""></p>
<h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>虚拟内存的起始地址与大小都是固定的，这意味着，当我们访问时，其数据的地址也是固定的，这会导致我们的数据非常容易被破解，为了解决这个问题，所以苹果为了解决这个问题，在iOS4.3开始引入了ASLR技术。</p>
<p>ASLR的概念：(Address Space Layout Randomization ) 地址空间配置随机加载，是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p>
<p>其目的的通过利用随机方式配置数据地址空间，使某些敏感数据（例如APP登录注册、支付相关代码）配置到一个恶意程序无法事先获知的地址，令攻击者难以进行攻击。</p>
<p>由于ASLR的存在，导致可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要在编译时来修复镜像中的资源指针，来指向正确的地址。即<code>正确的内存地址 = ASLR地址 + 偏移值</code></p>
<h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p>通用二进制文件是苹果公司提出的一种新的二进制文件的存储结构，可以同时存储多种架构的二进制指令，使CPU在读取该二进制文件时可以自动检测并选用合适的架构，以最理想的方式进行读取。</p>
<p>由于通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间，但由于系统会自动选择最合适的，不相关的架构代码不会占用内存空间，且执行效率高了。</p>
<p>Mach-O文件是Mach Object文件格式的缩写，它是用于可执行文件、动态库、目标代码的文件格式。作为a.out格式的替代，Mach-O格式提供了更强的扩展性，以及更快的符号表信息访问速度。经常使用<code>MachOView</code>工具来查看Mach-O文件。</p>
<h3 id="Mach-O的组成"><a href="#Mach-O的组成" class="headerlink" title="Mach-O的组成"></a>Mach-O的组成</h3><ul>
<li>Header：主要是Mach-O的cpu架构，文件类型以及加载命令等信息</li>
<li>Load Commands：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。（通常为framework、dylib的加载）</li>
<li>Data：数据区域<ul>
<li>__TEXT：只读，包括函数、静态变量等</li>
<li>__DATA：读写，可变的全局变量等</li>
<li>__LINKEDIT：方法、变量</li>
</ul>
</li>
</ul>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>启动的过程一般是指从用户点击app图标开始到<code>[AppDelegate didFinishLaunching</code>方法执行完成为止，其中，启动也分为冷启动和热启动</p>
<ul>
<li>冷启动：内存中不包含app相关数据的启动，一般我们可以通过重启手机来实现冷启动</li>
<li>热启动：是指杀掉app进程后，数据仍然存在时的启动</li>
</ul>
<p>而我们这里所说的启动优化，一般是指冷启动情况下的，这种情况下的启动主要分为两部分：</p>
<ul>
<li>T1 ：pre-main阶段，即main函数之前，操作系统加载App可执行文件到内存，执行一系列的加载、链接等工作，简单来说，就是dyld加载过程。</li>
<li>T2：main函数之后，即从main函数开始，到Appdelegate 的didFinishLaunching方法执行完成为止，主要是构建第一个界面，并完成渲染。</li>
</ul>
<p>所以，T1+T2的过程 就是 从用户点击App图标到用户能看到app主界面的过程，即需要启动优化的部分。</p>
<h2 id="pre-main阶段"><a href="#pre-main阶段" class="headerlink" title="pre-main阶段"></a>pre-main阶段</h2><p>pre-main阶段的启动时间其实就是dyld加载过程的时间。</p>
<p>针对main函数之前的启动时间，苹果提供了内建的测量方法，在<code>Edit Scheme -&gt; Run -&gt; Arguments -&gt; Environment Variables</code>点击【+】添加环境变量 <code>DYLD_PRINT_STATISTICS 设为 1</code>，然后运行，就可以直接打印相关数据。</p>
<p><img src="pre_main_time.jpg" alt=""></p>
<p>pre-main阶段一共耗时1.7s。</p>
<ul>
<li><code>dylib loading time</code>：主要是加载动态库，用时320.32ms</li>
<li><code>rebase/binding time</code>：偏移修正、符号绑定耗时，耗时160.52ms<ul>
<li><code>rebase</code>：偏移修正，任何一个app生成的二进制文件，在二进制文件内部所有的方法、函数调用，都有一个地址，这个地址是在当前二进制文件中的偏移地址。在APP运行是，每次系统都会随机分配一个ASLR（Address Space Layout Randomization，地址空间布局随机化）地址值，然后在加上偏移值就是运行时确定的内存地址。</li>
<li><code>binding</code>：绑定，例如NSLog方法，在编译时期生成的mach-o文件中，会创建一个符号！NSLog（目前指向一个随机的地址），然后在运行时（从磁盘加载到内存中，是一个镜像文件），会将真正的地址给符号（即在内存中将地址与符号进行绑定，是dyld做的，也称为动态库符号绑定），一句话概括：绑定就是给符号赋值的过程</li>
</ul>
</li>
<li><code>ObjC setup time</code>：OC类注册的耗时，OC类越多，越耗时</li>
<li><code>initializer time</code>：执行load和构造函数的耗时</li>
</ul>
<h3 id="pre-main优化建议"><a href="#pre-main优化建议" class="headerlink" title="pre-main优化建议"></a>pre-main优化建议</h3><ol>
<li>尽量减少外部动态库的使用。苹果建议自定义动态库的数量最好不要超过6个，超过6个则合并动态库。</li>
<li>减少OC类</li>
<li>讲不要的<code>+load</code>方法去掉，延迟到<code>+initialize</code>中</li>
<li>尽量减少C++函数</li>
</ol>
<h2 id="main-阶段"><a href="#main-阶段" class="headerlink" title="main 阶段"></a>main 阶段</h2><p>在main函数之后的<code>didFinishLaunching</code>方法中，主要是执行了各种业务，有很多并不是必须在这里立即执行的，这种业务我们可以采取延迟加载，防止影响启动时间。</p>
<p>在<code>didFinishLaunching</code>中，主要做一下几件事情：</p>
<ol>
<li>初始化第三方sdk</li>
<li>app运行环境配置</li>
<li>自定义工具的初始化等</li>
</ol>
<h3 id="main-阶段的优化"><a href="#main-阶段的优化" class="headerlink" title="main 阶段的优化"></a>main 阶段的优化</h3><ol>
<li>减少启动时需要初始化的sdk等，使用懒加载或者多线程处理。</li>
<li>优化代码，去除非必须的代码逻辑。</li>
<li>首页UI加载最后使用纯代码，避免使用xib和storybord（需要转换，更耗时）。</li>
<li>删除废弃的类、方法。</li>
</ol>
<h1 id="大招-二进制重排"><a href="#大招-二进制重排" class="headerlink" title="大招 二进制重排"></a>大招 二进制重排</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9" target="_blank" rel="noopener">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a></p>
<h3 id="System-Trace"><a href="#System-Trace" class="headerlink" title="System Trace"></a>System Trace</h3><p>基于Page Fault，App在冷启动过程中，会有大量的类、分类、三方等需要加载和执行，此时的产生的Page Fault所带来的的耗时是很大的。我们使用System Trace看下，在启动阶段的Page Fault的堆栈。</p>
<p>打开<code>Instruments</code>工具，选则<code>System Trace</code>。启动之后，在第一个界面出来之后，直接停掉。</p>
<p><img src="system_trace.jpg" alt=""></p>
<p>可以看到PageFault有2800次。</p>
<p>所以二进制重排要怎么重排呢？</p>
<h2 id="二进制重排原理"><a href="#二进制重排原理" class="headerlink" title="二进制重排原理"></a>二进制重排原理</h2><p>在虚拟内存部分，我们知道，当进程访问一个虚拟内存page，而对应的物理内存不存在时，会触发缺页中断（Page Fault），因此阻塞进程。此时就需要先加载数据到物理内存，然后再继续访问。这个对性能是有一定影响的。</p>
<p>所以我们就需要把先优先调用的方法等按照一定的顺序进行排列，这样就避免了<code>Page Falut</code>多次执行的情况。</p>
<p><img src="%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92.jpg" alt=""></p>
<p>可以查看上面抖音的文章，通过hook，大部分的方法都可以拿到，但是block、c++、initialize等方法是没有办法hook到，最后他们提到了clang插庄。</p>
<p>我们写一个Demo，来看一下编译的时期的顺序以及如何进行clang插庄。</p>
<p>在<code>target -&gt; Build Setting -&gt; Write Link Map File</code>设置为YES，可以查看linkMap文件代码的执行顺序。</p>
<h2 id="步奏"><a href="#步奏" class="headerlink" title="步奏"></a>步奏</h2><h3 id="添加编译参数"><a href="#添加编译参数" class="headerlink" title="添加编译参数"></a>添加编译参数</h3><p>在<code>Target -&gt; Build Setting -&gt; Custom Complier Flags -&gt; Other C Flags</code> 添加<br><code>-fsanitize-coverage=func,trace-pc-guard</code> 这个参数。此时编译会报错。</p>
<p>如果存在swift混编，还需要在 <code>Other Swift Flags</code> 中加入<code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code>。</p>
<h3 id="导入头文件，添加代码"><a href="#导入头文件，添加代码" class="headerlink" title="导入头文件，添加代码"></a>导入头文件，添加代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sanitizer&#x2F;coverage_interface.h&gt;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;原子队列，其目的是保证写入安全，线程安全</span><br><span class="line">static  OSQueueHead queue &#x3D; OS_ATOMIC_QUEUE_INIT;</span><br><span class="line">&#x2F;&#x2F;定义符号结构体，以链表的形式</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    void *pc;</span><br><span class="line">    void *next;</span><br><span class="line">&#125; ALNode;</span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,</span><br><span class="line">                                                    uint32_t *stop) &#123;</span><br><span class="line">  static uint64_t N;  &#x2F;&#x2F; Counter for the guards.</span><br><span class="line">  if (start &#x3D;&#x3D; stop || *start) return;  &#x2F;&#x2F; Initialize only once.</span><br><span class="line">  printf(&quot;INIT: %p %p\n&quot;, start, stop);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这个会拦截load方法，所以把这个注释掉</span><br><span class="line">    &#x2F;&#x2F; if (!*guard) return;</span><br><span class="line">    &#x2F;&#x2F;当前函数返回到上一个调用的地址，可以打断点通过lldb调试，使用bt命令，可以看到pc的值与0、1的关系。</span><br><span class="line">    void *PC &#x3D; __builtin_return_address(0);</span><br><span class="line">    &#x2F;&#x2F;创建结构体</span><br><span class="line">    SYNode * node &#x3D; malloc(sizeof(SYNode));</span><br><span class="line">    &#x2F;&#x2F; node赋值</span><br><span class="line">    *node &#x3D; (SYNode)&#123;PC,NULL&#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 加入结构!</span><br><span class="line">    OSAtomicEnqueue(&amp;symbolList, node, offsetof(SYNode, next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个页面加载完成，或者didFinishLaunching之后，调用输出，生成order_file。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)createOrderFile &#123;</span><br><span class="line">NSMutableArray&lt;NSString *&gt; * symbolNames &#x3D; [NSMutableArray array];</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F;offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量</span><br><span class="line">        SymbolNode * node &#x3D; OSAtomicDequeue(&amp;symboList, offsetof(SymbolNode, next));</span><br><span class="line">        if (node &#x3D;&#x3D; NULL) break;</span><br><span class="line">        Dl_info info;</span><br><span class="line">        dladdr(node-&gt;pc, &amp;info);</span><br><span class="line">        </span><br><span class="line">        NSString * name &#x3D; @(info.dli_sname);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 添加不是OC方法，需要添加下划线</span><br><span class="line">        BOOL isObjc &#x3D; [name hasPrefix:@&quot;+[&quot;] || [name hasPrefix:@&quot;-[&quot;];</span><br><span class="line">        NSString * symbolName &#x3D; isObjc ? name : [@&quot;_&quot; stringByAppendingString:name];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;去重</span><br><span class="line">        if (![symbolNames containsObject:symbolName]) &#123;</span><br><span class="line">            [symbolNames addObject:symbolName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取反</span><br><span class="line">    NSArray * symbolAry &#x3D; [[symbolNames reverseObjectEnumerator] allObjects];</span><br><span class="line">    NSLog(@&quot;%@&quot;,symbolAry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将结果写入到文件</span><br><span class="line">    NSString * funcString &#x3D; [symbolAry componentsJoinedByString:@&quot;\n&quot;];</span><br><span class="line">    NSString * filePath &#x3D; [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;lb.order&quot;];</span><br><span class="line">    NSData * fileContents &#x3D; [funcString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    BOOL result &#x3D; [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,filePath);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;文件写入出错&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接order-file"><a href="#链接order-file" class="headerlink" title="链接order file"></a>链接order file</h3><p>在<code>target -&gt; build setting -&gt; order file</code> 导入我们生成的<code>.order</code>文件。</p>
<h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9" target="_blank" rel="noopener">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a></p>
<p><img src="https://juejin.cn/post/6844904130406793224" alt="iOS 优化篇 - 启动优化之Clang插桩实现二进制重排"><br><img src="https://www.jianshu.com/p/bae1e9bddcc9" alt="iOS优化篇之App启动时间优化"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/25/%E9%80%86%E5%90%91/nx-4-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/25/%E9%80%86%E5%90%91/nx-4-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">代码注入</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-25 13:55:24" itemprop="dateCreated datePublished" datetime="2021-05-25T13:55:24+08:00">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-02 11:04:50" itemprop="dateModified" datetime="2021-06-02T11:04:50+08:00">2021-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h1><p>我们按照上一章（应用重签名）的逻辑，先把程序跑起来。</p>
<p>然后再<code>.app</code>中显示包内容，查看可执行文件。这里我们使用<code>MachOView</code>工具进行分析，这里我们主要查看的是<code>Load Commands</code>。</p>
<p><img src="MachOView.jpg" alt=""></p>
<p><code>Load Commands</code>：加载命令。</p>
<p>在<code>Load Commands</code>里头，可以看到所有的Framework。点击每一个Framework可以看到这个Framework的执行路径。</p>
<h2 id="Framework注入"><a href="#Framework注入" class="headerlink" title="Framework注入"></a>Framework注入</h2><h3 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h3><ol>
<li><p>在工程中选择<code>WeChat.xcodeproj</code>，然后在工程配置页面，选择左下角的加号”+“ -&gt; ”iOS“ -&gt; search ”Framework“。</p>
<p> <img src="add_framework.jpg" alt=""></p>
</li>
<li><p>创建一个类，添加<code>+(void)load</code>方法，打印一串字符串。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;\n\n hock success...\n\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li>重新运行工程（使用重签名）。这个时候我们的<code>NSLog</code>并不会执行，因为并没有链接到可执行文件。</li>
</ol>
<pre><code>然后在项目工程`project` -&gt; `show in finder` -&gt; 找到对应的APP -&gt; 显示包内容 -&gt; Framework文件夹。可以看到我们添加的ALHook.framework。

然后重新用`MachOView`工具打开可以执行文件（需要这个可执行文件），看看是否有链接ALHook.framework。这里是没有的。</code></pre><h3 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h3><p>通过<code>yololib</code>工具修改Mach-O文件，目的就是链接我们添加的动态库。</p>
<p>把<code>yololib</code>工具放到我们的工程文件中，与<code>appSign.sh</code>文件同级。然后把上面debug的可执行文件也同样复制过来。</p>
<p>然后执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;yololib [可执行文件] Frameworks&#x2F;[添加的动态库].framework&#x2F;[添加的动态库的可执行文件]</span><br><span class="line"></span><br><span class="line">$ .&#x2F;yololib WeChat Frameworks&#x2F;ALHook.framework&#x2F;ALHook</span><br></pre></td></tr></table></figure>

<p>执行完命令之后，重新使用<code>MachOView</code>工具打开可执行文件。</p>
<p><img src="MachO_ALHook.jpg" alt=""></p>
<h3 id="重新压缩，打包ipa文件"><a href="#重新压缩，打包ipa文件" class="headerlink" title="重新压缩，打包ipa文件"></a>重新压缩，打包ipa文件</h3><ol>
<li>重新解压<code>8.0.2.ipa</code>文件。</li>
<li>替换<code>Payload/xx.app -&gt; 显示包内容</code>中的可执行文件，把上一部链接好的可执行文件做替换。</li>
<li>重新压缩 <code>$ zip -ry WeChat.ipa Payload/</code>。</li>
<li>把压缩后的ipa包重新放在工程目录APP文件夹下。</li>
</ol>
<h3 id="重新运行"><a href="#重新运行" class="headerlink" title="重新运行"></a>重新运行</h3><p>这个时候重新运行，就可以看到我们的NSLog了。</p>
<p><img src="hook_success.jpg" alt=""></p>
<h2 id="dylib注入"><a href="#dylib注入" class="headerlink" title="dylib注入"></a>dylib注入</h2><p>我们按照上一章（应用重签名）的逻辑，先把程序跑起来。</p>
<h3 id="创建dylib"><a href="#创建dylib" class="headerlink" title="创建dylib"></a>创建dylib</h3><p>然后选择target -&gt; “+” -&gt; “macOs” -&gt; 搜索”library” -&gt; 选择”Library”，命名为”ALHook”。步奏与创建动态库类似。</p>
<h3 id="修改ALHook"><a href="#修改ALHook" class="headerlink" title="修改ALHook"></a>修改ALHook</h3><p>在<code>ALHook</code> -&gt; “Build Setting”中配置</p>
<ol>
<li>base sdk改为 <code>iOS</code></li>
<li>code signing identify 改为 <code>iOS Developer</code></li>
</ol>
<p>然后再文件中添加load方法，注入代码输出一串文本。</p>
<h3 id="添加依赖-Copy-Files"><a href="#添加依赖-Copy-Files" class="headerlink" title="添加依赖 Copy Files"></a>添加依赖 Copy Files</h3><p>在当前工程中拷贝dylib。</p>
<p><img src="add_dylib.jpg" alt=""></p>
<p>这里需要注意的是，<code>run script</code>的顺序一定是在<code>Copy Files</code>上的，因为如果顺序反了，会导致最后才执行脚本。则把copy的dylib文件给重新覆盖掉，因为脚本文件执行的是app替换。</p>
<h3 id="使用脚本执行"><a href="#使用脚本执行" class="headerlink" title="使用脚本执行"></a>使用脚本执行</h3><p>在上方动态库中我们是手动使用<code>/.yololib</code>工具进行链接的，这里我们使用脚本，在原来的<code>appSigh.sh</code>文件末尾添加一句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 链接手动添加的库，做代码注入</span><br><span class="line">.&#x2F;yololib &quot;$TARGET_APP_PATH&#x2F;$APP_BINARY&quot; &quot;Frameworks&#x2F;libALHook.dylib&quot;</span><br></pre></td></tr></table></figure>

<h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p>直接运行代码，可以在Framework中看到<code>libALHook.dylib</code>文件。</p>
<p>运行成功之后，可以看到我们的输出。</p>
<h1 id="代码注入流程总结"><a href="#代码注入流程总结" class="headerlink" title="代码注入流程总结"></a>代码注入流程总结</h1><ul>
<li>Framework手动注入，是为了熟悉原理，真正操作的时候我们使用的都是脚本文件，从繁到简。</li>
<li>Framework流程：<ol>
<li>Xcode新建Framework。</li>
<li>通过yololib工具是Mach-O文件链接Framework文件。<ul>
<li>所有的Framework加载都是由DYLD加载进入内存被执行的</li>
<li>注入成功的库路径会写入到Mach-O文件的<code>LC_LOAD_DYLIB</code>字段中</li>
</ul>
</li>
</ol>
</li>
<li>dylib注入流程：<ol>
<li>Xcode新建<code>dylib</code>库，然后修改”Build Setting”<ol>
<li>base sdk改为 <code>iOS</code></li>
<li>code signing identify 改为 <code>iOS Developer</code></li>
</ol>
</li>
<li>添加依赖，<code>Copy Files</code>将dylib文件拷贝到APP包中</li>
<li>通过yololib工具链接dylib文件。</li>
</ol>
</li>
</ul>
<p>这里需要注意的是，顺序不能错误，如下图：</p>
<p><img src="script_framework.jpg" alt=""></p>
<h1 id="真正的代码注入"><a href="#真正的代码注入" class="headerlink" title="真正的代码注入"></a>真正的代码注入</h1><p>我们使用Framework的形式进行注入。因为比较方便，dylib需要修改一些东西。</p>
<p>这里也直接使用dylib中使用脚本的方式进行注入。</p>
<h2 id="Debug-View-Hierarchy调试"><a href="#Debug-View-Hierarchy调试" class="headerlink" title="Debug View Hierarchy调试"></a>Debug View Hierarchy调试</h2><p><img src="hook_register.jpg" alt=""></p>
<p>我们看一下图片上的内容，通过<code>Debug View Hierarchy</code>的方式，先获取到我们想要的东西。</p>
<p>这里可以看到注册按钮的相关信息：</p>
<ol>
<li>是一个<code>FixTitleColorButton</code>的类，应该是封装的Button</li>
<li>指定的target是<code>WCAccountLoginControlLogic</code>。</li>
<li>相应的action是<code>onFirstViewRegister</code>。</li>
</ol>
<p>能拿到这些信息，就可以直接通过runtime的方法替换就可以直接修改了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method oldRegister &#x3D; class_getInstanceMethod(objc_getClass(&quot;WCAccountLoginControlLogic&quot;), @selector(onFirstViewRegister));</span><br><span class="line">    </span><br><span class="line">    Method newRegister &#x3D; class_getInstanceMethod([self class], @selector(new_register));</span><br><span class="line">    method_exchangeImplementations(oldRegister, newRegister);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)new_register &#123;</span><br><span class="line">    NSLog(@&quot;new register...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就把原来的注册方法给替换掉了，点击注册会输出者一串字符。</p>
<p>接下来我们要在点击登录时，拿到用户密码，并且不影响正常的登录流程。</p>
<h2 id="class-dump工具"><a href="#class-dump工具" class="headerlink" title="class-dump工具"></a>class-dump工具</h2><p>如果我们通过使用上面的方式，可以轻松的拿到用户名和密码，但是这是通过响应链一层层的去找的，所以也就有了这么个工具，可以直接输出OC中的类、方法、属性等内容。</p>
<p>把<code>WeChat</code>的可执行文件拷贝出来，和<code>class-dump</code>工具放在相同目录中(也可以是其他目录)，然后执行下述命令，可以输出所有的header文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;class-dump -H WeChat -o .&#x2F;headers&#x2F;</span><br></pre></td></tr></table></figure>

<p>然后我们通过<code>Debug View Hierarchy</code>找到对应的账号密码登录页面，查看页面的class和文本框的class，进一步在输出的头文件中找。</p>
<p><img src="hook_class_dump.jpg" alt=""></p>
<p>我们用同样的方式继续找<code>WCAccountTextFieldItem</code>。发现在<code>WCBaseTextFieldItem</code>有一个<code>WCUITextField</code>，继承自<code>UITextField</code>也就是我们要找的文本框。</p>
<p>在通过<code>Debug View Hierarchy</code>找到登录的点击事件。为<code>onNext</code>。能拿到这些信息，就可以操作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+(void)load &#123;</span><br><span class="line">    &#x2F;&#x2F;原始的Method</span><br><span class="line">    Method onNext &#x3D; class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(onNext));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加新方法!</span><br><span class="line">    class_addMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(new_onNext), new_onNext, &quot;v@:&quot;);</span><br><span class="line">    &#x2F;&#x2F;交换</span><br><span class="line">    method_exchangeImplementations(onNext, class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(new_onNext)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新的IMP</span><br><span class="line">void new_onNext(id self,SEL _cmd)&#123;</span><br><span class="line">    UITextField * pwd &#x3D; (UITextField *)[[self valueForKey:@&quot;_textFieldUserPwdItem&quot;] valueForKey:@&quot;m_textField&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;密码是:%@&quot;,pwd.text);</span><br><span class="line">    &#x2F;&#x2F;调用回原来的逻辑!!</span><br><span class="line">    &#x2F;&#x2F;调用原来的方法!</span><br><span class="line">    [self performSelector:@selector(new_onNext)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里是在原来的<code>WCAccountMainLoginViewController</code>类中添加方法，而不是用注册时的那种方法，是因为会造成crash，因为使用的是<code>exchange</code>方法交换，在<code>WCAccountMainLoginViewController</code>类执行<code>new_onNext</code>方法时找不到对应的方法。</p>
<p>这种是使用<code>class_addMethod</code>在<code>WCAccountMainLoginViewController</code>中添加了一个方法。接下来我们使用setImp和getImp的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(void)load&#123;</span><br><span class="line">    &#x2F;&#x2F;原始的Method</span><br><span class="line">    old_onNext &#x3D; method_getImplementation(class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(onNext)));</span><br><span class="line">    method_setImplementation(class_getInstanceMethod(objc_getClass(&quot;WCAccountMainLoginViewController&quot;), @selector(onNext)), new_onNext);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义原来的IMP</span><br><span class="line">IMP (*old_onNext)(id self,SEL _cmd);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义新的IMP</span><br><span class="line">void new_onNext(id self,SEL _cmd)&#123;</span><br><span class="line">    UITextField * pwd &#x3D; (UITextField *)[[self valueForKey:@&quot;_textFieldUserPwdItem&quot;] valueForKey:@&quot;m_textField&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;密码是:%@&quot;,pwd.text);</span><br><span class="line">    &#x2F;&#x2F;调用回原来的逻辑!!</span><br><span class="line">    &#x2F;&#x2F;调用原来的方法!</span><br><span class="line">    old_onNext(self,_cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式相对比较清晰，然后重新运行就好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过Framework、Dylib注入</p>
<ul>
<li>Xcode自动打包Framework进入app包</li>
<li>macho中load commands里需要有 LC_LOAD_DYLIB字段</li>
<li>DYLD加载我们创建的Framework</li>
<li>MethodSwizzle - Runtime中也是重点<ul>
<li>exchange函数交换SEL和IMP的对应关系<ul>
<li>这种方案有可能会造成crash。因为没法调用原来的方法。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>添加方法列表，然后exchange或者replace</li>
<li>getImp、setImp配合使用</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
