<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/page/2/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/09/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%985%E5%A4%A7%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%985%E5%A4%A7%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">内存5大分区</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 22:23:17" itemprop="dateCreated datePublished" datetime="2021-05-09T22:23:17+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存主要分为5大区：</p>
<ol>
<li>栈 stack</li>
<li>对 heap</li>
<li>全局区/静态区</li>
<li>常量区</li>
<li>代码区</li>
</ol>
<p><img src="memory.jpg" alt=""></p>
<p>这张图详细的介绍了5大分区的分配情况。</p>
<p>栈是从高地址向低地址开始分配，了解汇编的同学应该知道栈顶和栈底，这两个寄存器，栈顶处与低地址区，栈底处于高地址区。</p>
<p>堆是从低地址向高地址开始分配。在堆中获取数据相对比较麻烦，所以都是在栈中开辟空间指向堆。</p>
<p>当栈和堆有一方不断开辟空间，导致两个处于临界点时，就会发生堆栈溢出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/08/OC%E5%8E%9F%E7%90%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/OC%E5%8E%9F%E7%90%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 08:40:32" itemprop="dateCreated datePublished" datetime="2021-05-08T08:40:32+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2" target="_blank" rel="noopener">官方文档：线程编程指南</a></p>
<blockquote>
<p>线程是在应用程序内部实现多个执行路径的相对轻量的方法。在系统级别，程序并排运行，系统根据每个程序的需求和其他程序的需求为每个程序分配执行时间。但是，每个程序中都存在一个或多个执行线程，这些线程可用于同时或以几乎同时的方式执行不同的任务。系统本身实际上管理着这些执行线程，调度它们在可用内核上运行，并根据需要抢先中断它们以允许其他线程运行。</p>
</blockquote>
<ul>
<li>多个线程可以提高应用程序的感知响应能力。</li>
<li>多线程可以提高应用程序在多核系统上的实时性能。</li>
</ul>
<h2 id="2-什么是进程"><a href="#2-什么是进程" class="headerlink" title="2. 什么是进程"></a>2. 什么是进程</h2><p>进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</p>
<h2 id="3-两者的关系"><a href="#3-两者的关系" class="headerlink" title="3. 两者的关系"></a>3. 两者的关系</h2><ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</li>
<li>进程要想执行任务，必须得有线程，进程至少要有一条线程。</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程。</li>
<li>同一进程的线程共享本进程的地址空间，而进程之间则时独立的。</li>
<li>同一进程内的线程共享进程的资源，如：内存、I/O、CPU等，而进程之间是独立的。</li>
<li>一个进程崩溃后，保护模式下，不会对其他进程产生影响。一个线程崩溃则整个进程死掉。进程比线程健壮。</li>
<li>进程切换时，消耗的资源大，效率低。设计频繁切换时，是哦那个线程好于进程。</li>
<li>线程不能独立执行，必须依存于进程（应用程序）。</li>
<li>线程时处理器调度的基本单位，进程不是。</li>
<li>线程没有地址空间，线程保护在进程地址空间中。</li>
</ul>
<h2 id="4-多线程的优点"><a href="#4-多线程的优点" class="headerlink" title="4. 多线程的优点"></a>4. 多线程的优点</h2><ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源的利用率(CPU，内存)</li>
<li>线程上的任务执行完成后，线程会自动销毁</li>
</ul>
<h2 id="5-多线程的缺点"><a href="#5-多线程的缺点" class="headerlink" title="5. 多线程的缺点"></a>5. 多线程的缺点</h2><ul>
<li>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占512KB) </li>
<li>如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU 在调用线程上的开销就越大</li>
<li>程序设计更加复杂，比如线程间的通信、多线程的数据共享</li>
<li>多线程操作增加代码复杂度</li>
</ul>
<h2 id="6-时间片"><a href="#6-时间片" class="headerlink" title="6. 时间片"></a>6. 时间片</h2><p>CPU在多个任务之间进行快速的切换，这个时间间隔就是时间片。</p>
<ul>
<li>单核CPU同一时间，CPU只能处理1个线程（只能有一个线程执行）</li>
<li>多线程同时执行，是CPU快速在多个线程直接的切换，因为CPU调度线程的时间足够快，就造成了多线程的”同时“执行的效果。</li>
<li>如果线程数非常多，CPU会在N个线程之间切换，消耗大量的CPU资源，线程的执行效率会降低。</li>
</ul>
<h2 id="7-线程的声明周期"><a href="#7-线程的声明周期" class="headerlink" title="7. 线程的声明周期"></a>7. 线程的声明周期</h2><p><img src="thread-life.jpg" alt=""></p>
<h2 id="8-线程池的调度"><a href="#8-线程池的调度" class="headerlink" title="8. 线程池的调度"></a>8. 线程池的调度</h2><p><img src="thread-used.jpg" alt=""></p>
<p>4种饱和策略</p>
<ul>
<li>AbortPolicy 直接抛出RejectedExecutionExeception异常来阻止系统正常运行 </li>
<li>CallerRunsPolicy 将任务回退到调用者</li>
<li>DisOldestPolicy 丢掉等待最久的任务</li>
<li>DisCardPolicy 直接丢弃任务</li>
</ul>
<p>那么这里有一个问题，是不是创建的线程优先级越高，执行的就越快呢？</p>
<p>答案是不一定，需要根据线程要使用的资源，已经线程池的饱和程度来判断。</p>
<ol>
<li>如果这个线程需要很大的资源，比如处理几个G和处理几KB效率肯定是不一样的。</li>
<li>如果线程池处于饱和状态，并且都在执行状态，是没有办法把正在执行的线程取消掉的。</li>
</ol>
<p>这就需要锁来解决，</p>
<h1 id="多线程解决方案："><a href="#多线程解决方案：" class="headerlink" title="多线程解决方案："></a>多线程解决方案：</h1><p>常见的多线程有pthread、NSThread、GCD、NSOperation：</p>
<p><img src="" alt=""></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>两个人买票，同一时间相同的操作，A买的时候有100张，B买的时候也有100张，那AB都买完的时候应该只剩下998张才对，但是如果不处理的情况下，会出现资源抢占的问题。</p>
<p>这就需要锁来解决。</p>
<h2 id="1-atomic与nonatomic"><a href="#1-atomic与nonatomic" class="headerlink" title="1. atomic与nonatomic"></a>1. atomic与nonatomic</h2><p>atomic：原子属性(线程安全)，针对多线程设计的，使用属性时默认是atomic，保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值)。atomic本身就有一把锁(自旋锁) 单写多读:单个线程写入，多个线程可以读取。<br>nonatomic：非原子属性，非线程安全，适合内存小的移动设备。</p>
<blockquote>
<p>iOS开发建议：<br>所有属性都声明为 nonatomic<br>尽量避免多线程抢夺同一块资源，尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</p>
</blockquote>
<p>自旋锁 与 互斥锁的区别</p>
<p>两个都是进行同步操作而产生的。</p>
<p>自旋锁：发现其他线程在执行，当前线程会一直询问（忙等），直到当前线程开始执行。消耗性能比较高。适用于任务复杂度较低的。<br>互斥锁：发现其他线程在执行，当前线程即刻进入休眠（就绪状态），已知等待被唤醒执行。对于任务复杂度较高，资源较大使用互斥锁。</p>
<p>之后会有详细的描述，这里只是引出相关内容。</p>
<h1 id="NSPort通信"><a href="#NSPort通信" class="headerlink" title="NSPort通信"></a>NSPort通信</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 创建主线程的port</span><br><span class="line">&#x2F;&#x2F; 子线程通过此端口发送消息给主线程</span><br><span class="line">self.myPort &#x3D; [NSMachPort port];</span><br><span class="line">&#x2F;&#x2F;2. 设置port的代理回调对象</span><br><span class="line">self.myPort.delegate &#x3D; self;</span><br><span class="line">&#x2F;&#x2F;3. 把port加入runloop，接收port消息</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:self.myPort forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>

<p>创建了NSPort之后，一定要加入到NSRunLoop中包活，否则没有效果。</p>
<ol>
<li>runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心 的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局 的字典里。 </li>
<li>runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休 眠状态，有了任务就会被唤醒去执行任务。 </li>
<li>runloop在第一次获取时被创建，在线程结束时被销毁。 </li>
<li>对于主线程来说，runloop在程序一启动就默认创建好了。 </li>
<li>对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线 程用定时器要注意:确保子线程的runloop被创建，不然定时器不会回调。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/08/OC%E5%8E%9F%E7%90%86/KVO%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/OC%E5%8E%9F%E7%90%86/KVO%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">KVO原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 08:39:59" itemprop="dateCreated datePublished" datetime="2021-05-08T08:39:59+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 19:35:47" itemprop="dateModified" datetime="2021-05-10T19:35:47+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="noopener">Key-Value Observing</a></p>
<blockquote>
<p><b>Important:</b> In order to understand key-value observing, you must first understand key-value coding.</p>
</blockquote>
<p>在官方的文档中，有这么一句话，要理解KVO，必须先知道KVC。</p>
<h1 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h1><p>下面创建一个<code>Person</code>类，并添加几个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void *PersonNameContext &#x3D; &amp;PersonNameContext;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">@property (nonatomic, copy) NSString *fullName;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *mArray;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><p>KVO对实例变量是不起作用的。可以试一下，即使添加了set方法、添加了<code>didChangeValueForKey:</code>方法也不行，即使使用了KVC也监听不到。正常使用来说，还是针对属性。</p>
<h3 id="1-1-添加监听"><a href="#1-1-添加监听" class="headerlink" title="1.1 添加监听"></a>1.1 添加监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure>

<p>被监听者进行调用，添加一个监听对象，监听某一个属性的变化。context是上下文，在官方文档中，推荐使用<code>context</code>，不使用这个，也可以使用<code>NULL</code>代替。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当前对象监听person对象的name属性的变化</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:PersonNameContext]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-监听变化"><a href="#1-2-监听变化" class="headerlink" title="1.2 监听变化"></a>1.2 监听变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    &#x2F;&#x2F;if (context &#x3D;&#x3D; PersonNameContext) &#123;&#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以通过<code>keyPath</code>来判断某一个属性发生变化，如果监听了多个对象，并且有相同的属性，则在这里会添加一堆判断条件，会使代码变得臃肿，所以还是推荐使用context来判断。</p>
<h3 id="1-3-移除KVO"><a href="#1-3-移除KVO" class="headerlink" title="1.3 移除KVO"></a>1.3 移除KVO</h3><p>添加了监听之后，再<code>dealloc</code>时一定要移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<h2 id="2-KVO中属性依赖"><a href="#2-KVO中属性依赖" class="headerlink" title="2. KVO中属性依赖"></a>2. KVO中属性依赖</h2><p>比如我们要监听<code>fullName</code>属性的变化，当<code>name</code>和<code>nickName</code>中的一个发生变化时，都需要改变<code>fullName</code>的值，需要怎么处理？如果同时监听两个属性也不是不行，但是肯定还有其他更简便的方法。这就需要添加依赖。</p>
<p>在<code>Person.m</code>中实现如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line">    </span><br><span class="line">    NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys &#x3D; @[@&quot;name&quot;, @&quot;nickName&quot;];</span><br><span class="line">        keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现依赖监听了，也不用实现重复代码。</p>
<h2 id="3-KVO监听数组"><a href="#3-KVO监听数组" class="headerlink" title="3. KVO监听数组"></a>3. KVO监听数组</h2><p>我们实现对person.mArray的监听，但是当我们执行添加和删除操作时，方法并不会触发监听事件。</p>
<p>这也就时开始的时候所说的，KVO是基于KVC的，这个时候，我们利用KVC的方式获取数组就可以实现了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [self.person.mArray addObject:@&quot;1&quot;];</span><br><span class="line">[[self.person mutableArrayValueForKey:@&quot;mArray&quot;] addObject:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>

<h2 id="4-自动、手动实现监听"><a href="#4-自动、手动实现监听" class="headerlink" title="4. 自动、手动实现监听"></a>4. 自动、手动实现监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动开关</span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</span><br></pre></td></tr></table></figure>
<p>这是一个系统方法，只需要重写即可，默认是YES，如果针对某些key返回了NO，则需要手动实现set方法。没有实现则不会监听到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    _name &#x3D; name;</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="KVO底层原理"><a href="#KVO底层原理" class="headerlink" title="KVO底层原理"></a>KVO底层原理</h1><p>我们通过监听一个中的<code>name</code>属性的变化来判断监听前后会出现什么不同，来查看KVO的底层实现原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.person &#x3D; [Person new];</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br></pre></td></tr></table></figure>

<p>我们在这一行代码添加一个断点，分别通过lldb打印当前person的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self.person</span><br><span class="line">&lt;Person: 0x60000294a010&gt;</span><br><span class="line">(lldb) po self.person-&gt;isa</span><br><span class="line">Person</span><br><span class="line">(lldb) po [self.person class]</span><br><span class="line">Person</span><br><span class="line">(lldb) po [self.person superclass]</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">(lldb) po self.person</span><br><span class="line">&lt;Person: 0x60000294a010&gt;</span><br><span class="line">(lldb) po self.person-&gt;isa</span><br><span class="line">NSKVONotifying_Person</span><br><span class="line">(lldb) po [self.person class]</span><br><span class="line">Person</span><br><span class="line">(lldb) po [self.person superclass]</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>我们发现虽然两次<code>po self.person</code>输出的都是Person类，指向的内存地址也是一样的，两次输出class和superClass确都相同。但是<code>isa</code>的指向却是完全不同，竟然变成了<code>NSKVONotifying_Person</code>。</p>
<p>那<code>NSKVONotifying_Person</code>是什么呢？怎么会创建一个这个东西，难道是<code>Person</code>的子类？<br>猜测应该是Person的子类。</p>
<p>为什么两次输出class和superClass都是一样的？<br>我们猜测可能是改写了class方法。</p>
<p>带着疑问，我们输出一下监听前后的方法列表，已经两个class的superClass。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过使用字符串的方式获取Class</span><br><span class="line">    Class cls1 &#x3D; class_getSuperclass(objc_getClass(&quot;Person&quot;));</span><br><span class="line">    [self printClassAllMethod:objc_getClass(&quot;Person&quot;)];</span><br><span class="line">    NSLog(@&quot;cls1 &#x3D; %@&quot;, cls1);</span><br><span class="line">        </span><br><span class="line">    self.person &#x3D; [[Person alloc] init];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line">        </span><br><span class="line">    [self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_Person&quot;)];</span><br><span class="line">    Class cls2 &#x3D; class_getSuperclass(objc_getClass(&quot;NSKVONotifying_Person&quot;));</span><br><span class="line">    NSLog(@&quot;cls2 &#x3D; %@&quot;, cls2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 遍历方法-ivar-property</span><br><span class="line">- (void)printClassAllMethod:(Class)cls &#123;</span><br><span class="line">    NSLog(@&quot;----%@----&quot;, cls);</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methodList[i];</span><br><span class="line">        SEL sel &#x3D; method_getName(method);</span><br><span class="line">        IMP imp &#x3D; class_getMethodImplementation(cls, sel);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听前</span><br><span class="line">KVODemo[74347:5007124] ----Person----</span><br><span class="line">KVODemo[74347:5007124] name-0x105ec6550</span><br><span class="line">KVODemo[74347:5007124] .cxx_destruct-0x105ec6580</span><br><span class="line">KVODemo[74347:5007124] setName:-0x105ec64f0</span><br><span class="line">KVODemo[74347:5007124] cls1 &#x3D; NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听后</span><br><span class="line">KVODemo[74347:5007124] ----NSKVONotifying_Person----</span><br><span class="line">KVODemo[74347:5007124] setName:-0x7fff207bab57</span><br><span class="line">KVODemo[74347:5007124] class-0x7fff207b9662</span><br><span class="line">KVODemo[74347:5007124] dealloc-0x7fff207b940b</span><br><span class="line">KVODemo[74347:5007124] _isKVOA-0x7fff207b9403</span><br><span class="line">KVODemo[74347:5007124] cls2 &#x3D; Person</span><br></pre></td></tr></table></figure>

<p>我们发现:</p>
<ul>
<li>监听前Person类中有3个方法，super是<code>NSObject</code></li>
<li>监听后Person类中有4个方法，super是<code>Person</code></li>
</ul>
<p>进一步验证了我们之前的猜测，<code>NSKVONotifying_Person</code>是<code>Person</code>的子类，并且重些了<code>setName:, class, dealloc</code>方法，因为地址都已经发生了变化。</p>
<p>打印一下对应的IMP地址，看看所在的调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (IMP)0x105ec64f0</span><br><span class="line">(KVODemo&#96;-[Person setName:] at Person.m:12)</span><br><span class="line"></span><br><span class="line">(lldb) po (IMP)0x7fff207bab57</span><br><span class="line">(Foundation&#96;_NSSetObjectValueAndNotify)</span><br><span class="line">return class_getSuperclass(object_getClass(self));</span><br></pre></td></tr></table></figure>

<p>也说明了，根本不是同一个IMP。当然<code>_NSSetObjectValueAndNotify</code>也不仅仅只有一种，使用<code>~ nm Foundation | grep ValueAndNotify</code>命令可以在iTerm2上查看对应的方法。比如：NSSetBoolValueAndNotify、NSSetIntValueAndNotify等等，根据当前属性的类型来判断的。</p>
<p>也正是因为重写了，<code>setName:</code>才会在外部调用时，person.name也会同时改变。<br>重新<code>class</code>方法，是为了不暴露<code>NSKVONotifying_Person</code>类，在外界调用时防止混淆。</p>
<p><img src="person-isa.jpg" alt=""></p>
<h1 id="自定义KVO"><a href="#自定义KVO" class="headerlink" title="自定义KVO"></a>自定义KVO</h1><p>根据上面的分析，如果自定义KVO的话，我们需要从下面几个方面入手：</p>
<ol>
<li><p>先判断key有没有set方法，有set方法才行。</p>
</li>
<li><p>动态生成子类：</p>
<ol>
<li>判断是否已经存在子类，没有创建新的子类。</li>
<li>注册类</li>
<li>添加class方法，重新class方法</li>
<li>添加setter方法，重新set方法，这里需要处理消息，发送给父类，通知修改值。</li>
</ol>
</li>
<li><p>修改isa指向</p>
</li>
<li><p>保存信息，方便回调。</p>
</li>
<li><p>remove时，重新设置isa指向父类。</p>
</li>
</ol>
<p>代码就不贴了，哪都有~</p>
<h1 id="通过GNU解析"><a href="#通过GNU解析" class="headerlink" title="通过GNU解析"></a>通过GNU解析</h1><p><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">gnu源码</a></p>
<p>gnu源码可以清晰的看到整体的流程，只是读起来可能会稍微费力一点，查看代码中的重要逻辑其实就可以了。</p>
<h1 id="FBKVOController"><a href="#FBKVOController" class="headerlink" title="FBKVOController"></a>FBKVOController</h1><p>稍微说一下这个，内部实现还是很值得学习的。</p>
<p>我们直接看源码实现：</p>
<p>首先创建一个<code>FBKVOController</code>类型的实例变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved</span><br><span class="line">&#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  if (nil !&#x3D; self) &#123;</span><br><span class="line">    _observer &#x3D; observer;</span><br><span class="line">    NSPointerFunctionsOptions keyOptions &#x3D; retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality;</span><br><span class="line">    _objectInfosMap &#x3D; [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0];</span><br><span class="line">    pthread_mutex_init(&amp;_lock, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会生成一个<code>NSMapTable</code>类型的数据，里面存放的是&lt;id, NSMutableSet&lt;_FBKVOInfo *&gt; *&gt;这种格式的数据。</p>
<p>然后走到添加监听的方法，这里也没啥好说的，就是创建了一个<code>_FBKVOInfo</code>，存放系统KVO需要的所有东西，重点再下一句代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">  NSAssert(0 !&#x3D; keyPath.length &amp;&amp; NULL !&#x3D; block, @&quot;missing required parameters observe:%@ keyPath:%@ block:%p&quot;, object, keyPath, block);</span><br><span class="line">  if (nil &#x3D;&#x3D; object || 0 &#x3D;&#x3D; keyPath.length || NULL &#x3D;&#x3D; block) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; create info</span><br><span class="line">  _FBKVOInfo *info &#x3D; [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options block:block];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; observe object with info</span><br><span class="line">  [self _observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，重点来了。会从map表中查找对应的object是否有对应的数据。然后与新创建的info进行比较，没有则添加到map表中。</p>
<p><code>_FBKVOSharedController</code>是一个单利，所有的观察者都通过它来进行监听，内部使用的系统的KVO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)_observe:(id)object info:(_FBKVOInfo *)info</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; lock</span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  NSMutableSet *infos &#x3D; [_objectInfosMap objectForKey:object];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; check for info existence</span><br><span class="line">  _FBKVOInfo *existingInfo &#x3D; [infos member:info];</span><br><span class="line">  if (nil !&#x3D; existingInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F; observation info already exists; do not observe it again</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; unlock and return</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lazilly create set of infos</span><br><span class="line">  if (nil &#x3D;&#x3D; infos) &#123;</span><br><span class="line">    infos &#x3D; [NSMutableSet set];</span><br><span class="line">    [_objectInfosMap setObject:infos forKey:object];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; add info and oberve</span><br><span class="line">  [infos addObject:info];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unlock prior to callout</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  [[_FBKVOSharedController sharedController] observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在系统方法接收到改变时，会通过block、方法或者系统方法来返回数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath</span><br><span class="line">                      ofObject:(nullable id)object</span><br><span class="line">                        change:(nullable NSDictionary&lt;NSString *, id&gt; *)change</span><br><span class="line">                       context:(nullable void *)context</span><br></pre></td></tr></table></figure>

<p>最后就是移除。需要注意的是，添加的时候是新创建了一个info，移除的时候，为啥也是新创建了一个info？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)unobserve:(nullable id)object keyPath:(NSString *)keyPath</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; create representative info</span><br><span class="line">  _FBKVOInfo *info &#x3D; [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unobserve object property</span><br><span class="line">  [self _unobserve:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_unobserve:info:</code>的内部实现与添加的时候有点类似，都是通过map去找对应的<code>_FBKVOInfo</code>。那新创建一个info能起到移除的效果吗？答案是肯定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)_unobserve:(id)object info:(_FBKVOInfo *)info</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; lock</span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; get observation infos</span><br><span class="line">  NSMutableSet *infos &#x3D; [_objectInfosMap objectForKey:object];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lookup registered info instance</span><br><span class="line">  _FBKVOInfo *registeredInfo &#x3D; [infos member:info];</span><br><span class="line"></span><br><span class="line">  if (nil !&#x3D; registeredInfo) &#123;</span><br><span class="line">    [infos removeObject:registeredInfo];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; remove no longer used infos</span><br><span class="line">    if (0 &#x3D;&#x3D; infos.count) &#123;</span><br><span class="line">      [_objectInfosMap removeObjectForKey:object];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unlock</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unobserve</span><br><span class="line">  [[_FBKVOSharedController sharedController] unobserve:object info:registeredInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为创建的临时变量info，是通过NSMutableSet获取<code>member</code>来获取的，是怎么获取到的。</p>
<blockquote>
<p>Each element of the set is checked for equality with object until a match is found or the end of the set is reached. Objects are considered equal if isEqual: returns YES.</p>
</blockquote>
<p><code>member:</code>方法是通过<code>isEqual:</code>来判断是否是对应的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;_FBKVOInfo</span><br><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">  return [_keyPath hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object</span><br><span class="line">&#123;</span><br><span class="line">  if (nil &#x3D;&#x3D; object) &#123;</span><br><span class="line">    return NO;</span><br><span class="line">  &#125;</span><br><span class="line">  if (self &#x3D;&#x3D; object) &#123;</span><br><span class="line">    return YES;</span><br><span class="line">  &#125;</span><br><span class="line">  if (![object isKindOfClass:[self class]]) &#123;</span><br><span class="line">    return NO;</span><br><span class="line">  &#125;</span><br><span class="line">  return [_keyPath isEqualToString:((_FBKVOInfo *)object)-&gt;_keyPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写了<code>hash</code>方法和<code>isEqual:</code>方法，这样就可以直接通过member获取了。这源码的设计思路简直爽的一批<del>~</del>网上找到FBKVO流程图：</p>
<p><img src="FBKVOController.png" alt="网上找到FBKVO流程图"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>KVO的变量依赖</li>
<li>KVO的原理：<ol>
<li>动态生成子类<code>NSKVONotifying_A</code></li>
<li>注册类</li>
<li>动态添加class方法，返回父类</li>
<li>动态添加set方法，消息回传给父类，通知修改值</li>
<li>修改isa指向子类</li>
<li>移除KVO，修改isa执行父类</li>
</ol>
</li>
<li>GNU源码</li>
<li>FBKVOController源码设计思路。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/08/OC%E5%8E%9F%E7%90%86/KVC%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/OC%E5%8E%9F%E7%90%86/KVC%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">KVC原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 08:39:49" itemprop="dateCreated datePublished" datetime="2021-05-08T08:39:49+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">About Key-Value Coding</a></p>
<blockquote>
<p>Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to provide indirect access to their properties. When an object is key-value coding compliant, its properties are addressable via string parameters through a concise, uniform messaging interface. This indirect access mechanism supplements the direct access afforded by instance variables and their associated accessor methods.</p>
</blockquote>
<p>键值编码是由<code>NSKeyValueCoding</code>非正式协议启用的一种机制，对象采用这种机制来提供对其属性的间接访问。当对象是键值编码兼容的对象时，可以通过简洁，统一的消息传递接口通过字符串参数来访问其属性。这种间接访问机制补充了实例变量及其关联的访问器方法提供的直接访问。</p>
<h1 id="KVC-API"><a href="#KVC-API" class="headerlink" title="KVC - API"></a>KVC - API</h1><h2 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1. 常用方法"></a>1. 常用方法</h2><ul>
<li><p>获取key对应的value：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过key来设置value：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过路径取值，一般情况下是model1中有一个model2，获取model2的属性值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取对应路径的值，一般情况下是model1中有一个model2，设置model2的属性值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个可变类型：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认返回YES，如果当前没有设置key对应的属性（没有找到set<key>方法），会按照_key, _iskey, key, iskey的顺序搜索变量。如果返回NO，则不查询。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你在SetValue方法时面给Value传nil，则会调用这个方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Key不存在，且KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="2-set、get流程"><a href="#2-set、get流程" class="headerlink" title="2. set、get流程"></a>2. set、get流程</h2><p>声明一个Person类，声明4个变量。注意这里没有添加属性（添加属性默认会生成set、get方法），就是为了验证set、get流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_name;    &#x2F;&#x2F; 1.</span><br><span class="line">    NSString *_isName;  &#x2F;&#x2F; 2.</span><br><span class="line">    NSString *name;     &#x2F;&#x2F; 3.</span><br><span class="line">    NSString *isName;   &#x2F;&#x2F; 4.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>调用<code>setValue:forKey</code>方法，然后打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">&#x2F;&#x2F; KVC - 设置值的过程 setValue 分析调用过程</span><br><span class="line">[person setValue:@&quot;kvc&quot; forKey:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1.</span><br><span class="line">NSLog(@&quot;%@-%@-%@-%@&quot;,person-&gt;_name,person-&gt;_isName,person-&gt;name,person-&gt;isName);</span><br><span class="line">&#x2F;&#x2F; 2.</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;%@-%@-%@&quot;,person-&gt;_isName,person-&gt;name,person-&gt;isName);</span><br><span class="line">&#x2F;&#x2F; 3.</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;%@-%@&quot;,person-&gt;name,person-&gt;isName);</span><br><span class="line">&#x2F;&#x2F; 4.</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;%@&quot;,person-&gt;isName);</span><br></pre></td></tr></table></figure>

<p>分别按照顺序1-2-3-4，每次注释一个变量，每次只执行一句<code>NSLog</code>，看看打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.</span><br><span class="line">kvc-(nill)-(nill)-(nill)</span><br><span class="line">&#x2F;&#x2F; 2.</span><br><span class="line">kvc-(nill)-(nill)</span><br><span class="line">&#x2F;&#x2F; 3.</span><br><span class="line">kvc-(nill)</span><br><span class="line">&#x2F;&#x2F; 4.</span><br><span class="line">kvc</span><br></pre></td></tr></table></figure>

<p>为了进一步验证，可以在<code>Person.m</code>中，实现对应的set和get方法，分别打断点，按照1-2-3-4的顺序分别注释，可以进一步验证，set、get的流程。</p>
<p><code>setValue:forKey:</code>：按照<code>set&lt;key&gt;, _set&lt;key&gt;, setIs&lt;key&gt;</code>进行设置。有一个执行，其他的不执行。</p>
<blockquote>
<p>注意：<code>_setIs&lt;key&gt;</code>这个方法不会执行。</p>
</blockquote>
<p><code>valueForKey</code>：按照<code>get&lt;key&gt;, &lt;key&gt;, is&lt;key&gt;, _&lt;key&gt;</code>顺序进行查找。有一个执行，不执行其他的。</p>
<p>这里有官方的设置key-value的流程：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">Accessor Search Patterns</a>，写的很详细。</p>
<h3 id="2-1-Get-流程"><a href="#2-1-Get-流程" class="headerlink" title="2.1 Get 流程"></a>2.1 Get 流程</h3><ol>
<li>按照访问方法<code>-get&lt;Key&gt;，-&lt;key&gt;，-is&lt;Key&gt;，-_&lt;key&gt;</code>的顺序进行查找，如果找到执行步奏【5】。否则执行步奏【2】。</li>
<li>在实例中搜索①<code>countOf&lt;Key&gt;</code>，②<code>objectIn&lt;Key&gt;AtIndex:</code>（与<code>NSArray</code>类定义的原始方法<code>&lt;key&gt;AtIndexes:</code>相对应）或③<code>objectsAtIndexes:</code>（与NSArray方法相对应）。如果找到①，再找到②或③中的一个，则创建一个响应所有NSArray方法的集合代理对象并将其返回。否则，请继续执行步骤【3】。</li>
<li>如果找到了①<code>countOf&lt;Key&gt;</code>，没有找到②或③，那么会去找<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf&lt;Key&gt;:</code>（对应NSSet类）。如果找到了所有三个方法，则创建一个响应所有NSSet方法的集合代理对象并将其返回。否则，请继续执行步骤【4】。</li>
<li>如果接收器的类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，则按照<code>_&lt;key&gt;，_is&lt;Key&gt;，&lt;key&gt;，is&lt;Key&gt;</code>的顺序搜索实例变量。如果找到，直接获取实例变量的值，然后继续执行步骤【5】。否则，继续执行步骤【6】。</li>
<li>如果获取到的变量是对象指针，则只需返回结果。<br> 如果该值是可以转换位<code>NSNumber</code>类型，则将其存储在NSNumber实例中并返回该实例。<br> 如果结果是<code>NSNumber</code>不支持的类型，请转换为<code>NSValue</code>对象并返回该对象。</li>
<li>如果其他所有方法均失败，则调用<code>valueForUndefinedKey:</code>。默认情况下会引发异常。</li>
</ol>
<h3 id="2-2-Set流程"><a href="#2-2-Set流程" class="headerlink" title="2.2 Set流程"></a>2.2 Set流程</h3><ol>
<li>按此顺序查找第一个名为<code>set&lt;Key&gt;:, _set&lt;Key&gt;:, setIsName:</code>的set方法。如果找到，调用它并完成。</li>
<li>如果没有找到，如果类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，则按照顺序<code>_&lt;key&gt;，_is&lt;Key&gt;，&lt;key&gt;，is&lt;Key&gt;</code>查找实例变量。如果找到，则直接对变量进行赋值。</li>
<li>如果步奏【1】和【2】都失败了，则调用<code>setValue:forUndefinedKey:</code>。默认情况下会引发异常。</li>
</ol>
<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><h2 id="1-集合类型"><a href="#1-集合类型" class="headerlink" title="1. 集合类型"></a>1. 集合类型</h2><p>在<code>Person</code>类中，声明一个不可变数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSArray *array;</span><br></pre></td></tr></table></figure>

<p>对不可变类型进行赋值时，可以使用<code>mutableArrayValueForKey</code>先获取一个可变数组，然后直接赋值就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person.array &#x3D; @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">&#x2F;&#x2F; 修改数组</span><br><span class="line">&#x2F;&#x2F; person.array[0] &#x3D; @&quot;100&quot;;&#x2F;&#x2F; 这种方式不可用</span><br><span class="line">&#x2F;&#x2F; 1. 获取一个新的数组 - KVC 赋值</span><br><span class="line">NSArray *array &#x3D; [person valueForKey:@&quot;array&quot;];</span><br><span class="line">array &#x3D; @[@&quot;100&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">[person setValue:array forKey:@&quot;array&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;array&quot;]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 使用mutableArrayValueForKey</span><br><span class="line">NSMutableArray *mArray &#x3D; [person mutableArrayValueForKey:@&quot;array&quot;];</span><br><span class="line">mArray[0] &#x3D; @&quot;200&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;array&quot;]);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-05-09 10:17:58.004460+0800 KVCDemo[70852:4744247] (</span><br><span class="line">    100,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br><span class="line">2021-05-09 10:17:58.005523+0800 KVCDemo[70852:4744247] (</span><br><span class="line">    200,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果声明的是一个可变数组，那通过<code>[person valueForKey:@&quot;mArray&quot;];</code>获取到的就是一个可变数组。</p>
<h2 id="2-集合类型set、get流程补充"><a href="#2-集合类型set、get流程补充" class="headerlink" title="2. 集合类型set、get流程补充"></a>2. 集合类型set、get流程补充</h2><p>直接上代码：这里使用的key是一个没有在类中声明的变量/属性<code>pens</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person.arr &#x3D; @[@&quot;pen0&quot;, @&quot;pen1&quot;, @&quot;pen2&quot;, @&quot;pen3&quot;];</span><br><span class="line">&#x2F;&#x2F; 直接运行，在这里会发生crash</span><br><span class="line">NSArray *array &#x3D; [person valueForKey:@&quot;pens&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[array objectAtIndex:1]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[array containsObject:@&quot;pen1&quot;]);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; set 集合</span><br><span class="line">person.set &#x3D; [NSSet setWithArray:person.arr];</span><br><span class="line">NSSet *set &#x3D; [person valueForKey:@&quot;books&quot;];</span><br><span class="line">[set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    NSLog(@&quot;set遍历 %@&quot;,obj);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>直接运行，会发生crash。</p>
<blockquote>
<p>*** Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[&lt;LGPerson 0x6000024610c0&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key pens.’</p>
</blockquote>
<p>按照上面的流程分析，我们需要对NSArray和NSSet类型提供方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MARK: - NSArray</span><br><span class="line">&#x2F;&#x2F; 个数</span><br><span class="line">- (NSUInteger)countOfPens&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.arr count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取值</span><br><span class="line">- (id)objectInPensAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [NSString stringWithFormat:@&quot;pens %lu&quot;, index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK: - set</span><br><span class="line">&#x2F;&#x2F; 个数</span><br><span class="line">- (NSUInteger)countOfBooks&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.set count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否包含这个成员对象</span><br><span class="line">- (id)memberOfBooks:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.set containsObject:object] ? object : nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 迭代器</span><br><span class="line">- (id)enumeratorOfBooks &#123;</span><br><span class="line">    &#x2F;&#x2F; objectEnumerator</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.arr reverseObjectEnumerator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充完整上述方法，即可正常运行，对数组进行操作。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>声明一个结构体类型的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    float x, y, z;</span><br><span class="line">&#125; ThreeFloats;</span><br><span class="line"></span><br><span class="line">@property (nonatomic) ThreeFloats threeFloats;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreeFloats floats &#x3D; &#123;1.,2.,3.&#125;;</span><br><span class="line">NSValue *value     &#x3D; [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</span><br><span class="line">[person setValue:value forKey:@&quot;threeFloats&quot;];</span><br><span class="line">NSValue *value1    &#x3D; [person valueForKey:@&quot;threeFloats&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,value1);</span><br><span class="line">    </span><br><span class="line">ThreeFloats th;</span><br><span class="line">[value1 getValue:&amp;th];</span><br><span class="line">NSLog(@&quot;%f-%f-%f&quot;,th.x,th.y,th.z);</span><br></pre></td></tr></table></figure>

<p>对于结构体类型的数据，需要先转化成<code>NSValue</code>类型。常量类型会先转化成<code>NSNumber</code>类型</p>
<h1 id="自定义KVC"><a href="#自定义KVC" class="headerlink" title="自定义KVC"></a>自定义KVC</h1><p>根据set、get流程分析，自定义主要分为以下几个流程，需要注意的是要做安全判断，防止发生异常。</p>
<h2 id="1-kvc自定义set"><a href="#1-kvc自定义set" class="headerlink" title="1. kvc自定义set"></a>1. kvc自定义set</h2><ol>
<li>判断key，value的情况</li>
<li>通过传进来的key生成对应的set方法。</li>
<li>判断生成的3种set方法是否可以被响应，可以被响应直接return。</li>
<li>判断accessInstanceVariablesDirectly是否返回YES。</li>
<li>判断4种实例变量是否存在，存在则赋值，否则crash异常处理。</li>
</ol>
<h2 id="2-KVC-自定义Get"><a href="#2-KVC-自定义Get" class="headerlink" title="2. KVC 自定义Get"></a>2. KVC 自定义Get</h2><ol>
<li>判断key的值。</li>
<li>生成对应的<code>-get&lt;Key&gt;，-&lt;key&gt;，-is&lt;Key&gt;，-_&lt;key&gt;</code>方法。判断是否可以响应。</li>
<li>不响应判断get流程种NSArray的处理。</li>
<li>不想要判断get流程种NSSet的处理。</li>
<li>判断accessInstanceVariablesDirectly是否返回YES。</li>
<li>判断变量是否存在，存在直接返回。</li>
<li>异常处理。</li>
</ol>
<p>自定义set、get完全是按照set和get的流程处理的。代码就不上了，太占地方。</p>
<h1 id="补充，KVC的高级使用"><a href="#补充，KVC的高级使用" class="headerlink" title="补充，KVC的高级使用"></a>补充，KVC的高级使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arrStr &#x3D; @[@&quot;1&quot;, @&quot;10&quot;, @&quot;100&quot;];</span><br><span class="line">NSArray *arrCapStr &#x3D; [arrStr valueForKey:@&quot;capitalizedString&quot;];</span><br><span class="line">    </span><br><span class="line">for (NSString *str in arrCapStr) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSArray *arrCapStrLength &#x3D; [arrCapStr valueForKeyPath:@&quot;capitalizedString.length&quot;];</span><br><span class="line">for (NSNumber *length in arrCapStrLength) &#123;</span><br><span class="line">    NSLog(@&quot;%ld&quot;, (long)length.integerValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br><span class="line">100</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>还有关于model中嵌套model的也差不多类似，大家探索一下吧。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>KVC可以间接访问私有变量。</li>
<li><code>valueForKey</code>返回key对应的类型数据。如果是不可变数组，通过<code>mutableArrayValueForKey</code>获取的也会是可变类型。</li>
<li><code>setValue:forKey:, valueForKey:</code>的流程。</li>
<li>自定义KVC。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/28/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-5/" class="post-title-link" itemprop="url">ARM汇编-5 OC反汇编</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-28 14:30:30" itemprop="dateCreated datePublished" datetime="2021-04-28T14:30:30+08:00">2021-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OC代码的精髓其实就是<code>objc_msgSend</code>。而OC的反汇编其实就是查看其中的方法调用。</p>
<p>objc_msgSend有两个参数，第一个是id类型，第二个是SEL类型。id、SEL其实都是一个结构体，内部有isa指针，所以这两个在内存中占有8个字节。</p>
<h1 id="1-OC汇编"><a href="#1-OC汇编" class="headerlink" title="1. OC汇编"></a>1. OC汇编</h1><p>声明一个Person类，并添加两个属性，一个类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic, copy) NSString * name;</span><br><span class="line">@property(nonatomic, assign) int age;</span><br><span class="line"></span><br><span class="line">+(instancetype)person;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (instancetype)person &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    Person * p &#x3D; [Person person];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放在main函数里，直接调用类方法，生成一个临时变量。<br>打上断点，直接在汇编模式下进行debug。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;main:</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    0x10405a16c &lt;+24&gt;:  adrp   x8, 3</span><br><span class="line">    0x10405a170 &lt;+28&gt;:  add    x8, x8, #0x648            ; &#x3D;0x648 </span><br><span class="line">-&gt;  0x10405a174 &lt;+32&gt;:  ldr    x0, [x8]</span><br><span class="line"></span><br><span class="line">    0x10405a178 &lt;+36&gt;:  adrp   x8, 3</span><br><span class="line">    0x10405a17c &lt;+40&gt;:  add    x8, x8, #0x638            ; &#x3D;0x638 </span><br><span class="line">    0x10405a180 &lt;+44&gt;:  ldr    x1, [x8]</span><br><span class="line">    0x10405a184 &lt;+48&gt;:  bl     0x10405a4d4               ; symbol stub for: objc_msgSend</span><br><span class="line">    0x10405a188 &lt;+52&gt;:  mov    x29, x29</span><br><span class="line">    0x10405a18c &lt;+56&gt;:  bl     0x10405a4f8               ; symbol stub for: objc_retainAutoreleasedReturnValue</span><br><span class="line">    0x10405a190 &lt;+60&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 </span><br><span class="line">    0x10405a194 &lt;+64&gt;:  str    x0, [sp, #0x8]</span><br><span class="line">    0x10405a198 &lt;+68&gt;:  stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x10405a19c &lt;+72&gt;:  mov    x0, x8</span><br><span class="line">    0x10405a1a0 &lt;+76&gt;:  mov    x8, #0x0</span><br><span class="line">    0x10405a1a4 &lt;+80&gt;:  mov    x1, x8</span><br><span class="line">    0x10405a1a8 &lt;+84&gt;:  bl     0x10405a510               ; symbol stub for: objc_storeStrong</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这里隐藏了开辟栈空间和回收相关的代码。</p>
<p><code>objc_msgSend</code>需要两个参数id和SEL，从上面的代码可以初步判断两个参数的值分别在x0、x1寄存器中。</p>
<p>首先我们看一下x0寄存器中的数据。按照老方法，adrp计算x8的地址是<code>0x010405d648</code>。x0的值存放在<code>0x010405d648</code>所指向的内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x010405d648</span><br><span class="line">&lt;Person: 0x10405d648&gt;</span><br><span class="line">(lldb) x 0x010405d648</span><br><span class="line">0x10405d648: 30 d7 05 04 01 00 00 00 68 d6 05 04 01 00 00 00  0.......h.......</span><br><span class="line">0x10405d658: 08 00 00 00 08 00 00 00 10 00 00 00 08 00 00 00  ................</span><br><span class="line"></span><br><span class="line">(lldb) po 0x010405d730</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>我们确定了第一个参数是Person类。在看第二个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x 0x10405d638</span><br><span class="line">0x10405d638: 05 3d 42 8f 01 00 00 00 00 00 00 00 00 00 00 00  .&#x3D;B.............</span><br><span class="line">0x10405d648: 30 d7 05 04 01 00 00 00 68 d6 05 04 01 00 00 00  0.......h.......</span><br><span class="line">(lldb) po (SEL)0x018f423d05</span><br><span class="line">&quot;person&quot;</span><br></pre></td></tr></table></figure>

<p>没有毛病，就是一个方法<code>person</code>。</p>
<p>不同的系统版本，实现的汇编是不一样，iOS11下，汇编对objc_alloc进行了优化，但是没有对init处理。</p>
<p>iOS14 ：没有消息发送，直接objc_alloc_init<br>iOS11 ： 一次消息发送，objc_alloc, objc_msgSend(self, init)<br>iOS9  ： 两次消息发送，objc_msgSend(alloc),objc_msgSend(self, init)</p>
<h2 id="1-1-objc-storeStrong"><a href="#1-1-objc-storeStrong" class="headerlink" title="1.1 objc_storeStrong"></a>1.1 objc_storeStrong</h2><p>这里还看到一个这个东西，这个设计到oc源码的逻辑，我们稍微看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev &#x3D; *location;</span><br><span class="line">    if (obj &#x3D;&#x3D; prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location &#x3D; obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数需要两个参数，第一个是id *类型，这就是一个地址，第二个是id类型。我们反过来看汇编代码，看这两个变量，正常来说还是在x0、x1寄存器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x8中存地址</span><br><span class="line">0x10405a190 &lt;+60&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 </span><br><span class="line">&#x2F;&#x2F; 把x0寄存器的值放在x8中。</span><br><span class="line">0x10405a194 &lt;+64&gt;:  str    x0, [sp, #0x8]</span><br><span class="line">&#x2F;&#x2F; 把0存起来</span><br><span class="line">0x10405a198 &lt;+68&gt;:  stur   wzr, [x29, #-0x4]</span><br><span class="line">&#x2F;&#x2F; x0 &#x3D; x8，是一个地址。</span><br><span class="line">0x10405a19c &lt;+72&gt;:  mov    x0, x8</span><br><span class="line">&#x2F;&#x2F; x8置空</span><br><span class="line">0x10405a1a0 &lt;+76&gt;:  mov    x8, #0x0</span><br><span class="line">&#x2F;&#x2F; x1 &#x3D; 0</span><br><span class="line">0x10405a1a4 &lt;+80&gt;:  mov    x1, x8</span><br><span class="line">&#x2F;&#x2F; 这里x0是一个地址， x1是个nil，两个变量</span><br><span class="line">0x10405a1a8 &lt;+84&gt;:  bl     0x10405a510  ; symbol stub for: objc_storeStrong</span><br></pre></td></tr></table></figure>

<p>通过分析汇编，objc_storeStrong两个变量分别是一个地址，一个是nil。然后看一些源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; location有值， obj &#x3D; nil</span><br><span class="line">    id prev &#x3D; *location;</span><br><span class="line">    &#x2F;&#x2F; 不相等</span><br><span class="line">    if (obj &#x3D;&#x3D; prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对nil进行retain</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    &#x2F;&#x2F; 寻址之后置空，也就是把id对象置空</span><br><span class="line">    *location &#x3D; obj;</span><br><span class="line">    &#x2F;&#x2F; 释放</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个函数不仅仅只是用来强引用的，还可以进行释放操作，在这里就是一个很明显的例子。</p>
<h1 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2 属性"></a>1.2 属性</h1><p>我们在mian函数中，对实例对象p的两个属性进行赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    Person * p &#x3D; [Person person];</span><br><span class="line">    p.name &#x3D; @&quot;name&quot;;</span><br><span class="line">    p.age &#x3D; 18;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在真机上执行一下，然后我们使用之前的Hopper工具进行看一下。</p>
<p><img src="arm-5-property.jpg" alt=""></p>
<p>这里就很详细的标注了整个内容，看起来比读汇编代码省事很多。</p>
<h1 id="3-block的汇编"><a href="#3-block的汇编" class="headerlink" title="3. block的汇编"></a>3. block的汇编</h1><p>在main函数中直接声明一个栈区的block，全局区的也是一样的道理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^() &#123;</span><br><span class="line">    NSLog(@&quot;block--%d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>然后真机上运行。这里省去了很大一部分的代码，只拿了关键部分的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;main:</span><br><span class="line">    0x10052a0cc &lt;+36&gt;:  adrp   x10, 2</span><br><span class="line">    0x10052a0d0 &lt;+40&gt;:  ldr    x10, [x10]</span><br><span class="line">-&gt;  0x10052a0d4 &lt;+44&gt;:  str    x10, [sp, #0x8]</span><br></pre></td></tr></table></figure>

<p>先获取x10寄存器的值，也就是<code>0x10052c000</code>,lldb调试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x 0x10052c000</span><br><span class="line">0x10052c000: 20 9a 44 29 02 00 00 00 0c c8 66 ef 01 00 00 00   .D)......f.....</span><br><span class="line">0x10052c010: 18 a5 52 00 01 00 00 00 24 a5 52 00 01 00 00 00  ..R.....$.R.....</span><br><span class="line">&#x2F;&#x2F; 这是一个栈block</span><br><span class="line">(lldb) po 0x10052c000</span><br><span class="line">&lt;__NSStackBlock__: 0x10052c000&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里拿到的是0x10052c010地址指向的内存区域，这个就是block的invoke。</span><br><span class="line">(lldb) dis -s 0x010052a518</span><br><span class="line">    0x10052a518: ldr    w16, 0x10052a520</span><br><span class="line">    0x10052a51c: b      0x10052a500</span><br><span class="line">    0x10052a520: udf    #0x0</span><br><span class="line">    0x10052a524: ldr    w16, 0x10052a52c</span><br><span class="line">    0x10052a528: b      0x10052a500</span><br><span class="line">    0x10052a52c: udf    #0xd</span><br><span class="line">    0x10052a530: ldr    w16, 0x10052a538</span><br><span class="line">    0x10052a534: b      0x10052a500</span><br></pre></td></tr></table></figure>

<p>这里看一下block的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;      &#x2F;&#x2F; 8个字节</span><br><span class="line">    volatile int32_t flags; &#x2F;&#x2F; contains ref count   &#x2F;&#x2F;4个字节</span><br><span class="line">    int32_t reserved;   &#x2F;&#x2F; 4个字节</span><br><span class="line">    BlockInvokeFunction invoke;</span><br><span class="line">    struct Block_descriptor_1 *descriptor;</span><br><span class="line">    &#x2F;&#x2F; imported variables</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>block也是一个结构体，invoke所在的位置，就是isa之后的16个字节。所以我在内存中取的invoke的实现就是偏移了0x10。</p>
<p>接下来，我们用hopper看一下:</p>
<p><img src="arm-5-block.jpg" alt=""></p>
<p><img src="arm-5-block-invoke.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/25/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-4/" class="post-title-link" itemprop="url">ARM汇编-4 指针</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 23:34:37" itemprop="dateCreated datePublished" datetime="2021-04-25T23:34:37+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h1><blockquote>
<p>指针也就是内存地址，指针变量是用来存放内存地址的变量。不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。<br>可使用 &amp; 运算符访问地址。</p>
</blockquote>
<p>之前的文章中有过说明，指针在内存中占8个字节。<br>可以是用sizeof来打印指针的size。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    a ++;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义一个int类型的指针a，然后赋值位100，我们知道指针的size是8个字节，a++之后打印多少？</p>
<p>答案是104。是的，没有看错，这里是因为指针的自增和自减操作，与执行的数据类型的宽度有关。</p>
<p>如果<code>a = (char *)100</code>,则打印的就是101。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    a &#x3D; a + 1;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个不是指针的自增、自减了，这个时候就跟指针的size有关了，打印108。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func_add() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    </span><br><span class="line">    int *b;</span><br><span class="line">    b &#x3D; (int *)200;</span><br><span class="line">    </span><br><span class="line">    int x &#x3D; a - b;</span><br><span class="line">    printf(&quot;x &#x3D; %d&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先说答案，打印的结果是<code>x = -25</code>。</p>
<p>a - b = -100, 然后除以4就得到了这个结果。</p>
<blockquote>
<p>指针的运算单位是执行的数据类型的宽度。</p>
</blockquote>
<h2 id="1-1-二级指针"><a href="#1-1-二级指针" class="headerlink" title="1.1 二级指针"></a>1.1 二级指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int **a;</span><br><span class="line">    a &#x3D; (int **)100;</span><br><span class="line">    a &#x3D; a + 1;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候a运算时，执行的类型就是 <code>char *</code>类型，这是一个指针，8个字节。所以结果就是108。</p>
<h1 id="2-指针的汇编"><a href="#2-指针的汇编" class="headerlink" title="2. 指针的汇编"></a>2. 指针的汇编</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    int b &#x3D; 10;</span><br><span class="line">    a &#x3D; &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我们正常的理解，上述代码的意思就是把b的地址给到a，这个时候<code>*a=10</code>。</p>
<p>看一下上面的代码汇编之后是什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">    0x100206130 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. x8 &#x3D; sp + 0x4，x8指向这个位置</span><br><span class="line">    0x100206134 &lt;+4&gt;:  add    x8, sp, #0x4              ; &#x3D;0x4 </span><br><span class="line">    &#x2F;&#x2F; 2. 局部变量，w9&#x3D;10</span><br><span class="line">    0x100206138 &lt;+8&gt;:  mov    w9, #0xa</span><br><span class="line">    &#x2F;&#x2F; 3. 把w9的值放在x8所在的地址上。</span><br><span class="line">    0x10020613c &lt;+12&gt;: str    w9, [sp, #0x4]</span><br><span class="line">    &#x2F;&#x2F; 4. 把x8存储的地址放在sp + 0x8的位置上。</span><br><span class="line">-&gt;  0x100206140 &lt;+16&gt;: str    x8, [sp, #0x8]</span><br><span class="line">    0x100206144 &lt;+20&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100206148 &lt;+24&gt;: ret</span><br></pre></td></tr></table></figure>

<p>通过lldb打印一下相关数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read sp</span><br><span class="line">      sp &#x3D; 0x000000016fbff880</span><br><span class="line"></span><br><span class="line">(lldb) register read x8</span><br><span class="line">      x8 &#x3D; 0x000000016fbff884</span><br><span class="line">   </span><br><span class="line">(lldb) register read x9</span><br><span class="line">      x9 &#x3D; 0x000000000000000a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印一下x8寄存器里的内存地址情况，里头存的值是0xa</span><br><span class="line">(lldb) x 0x000000016fbff884</span><br><span class="line">0x16fbff884: 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x16fbff894: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x8的地址放在了sp+0x8的位置，打印一下内存，就是x8存储的地址。</span><br><span class="line">(lldb) x 0x000000016fbff888</span><br><span class="line">0x16fbff888: 84 f8 bf 6f 01 00 00 00 00 00 00 00 00 00 00 00  ...o............</span><br><span class="line">0x16fbff898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>


<h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int arr[5] &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, *(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    char *p;</span><br><span class="line">    char a &#x3D; *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码，我们知道，只是把*p的值给了a<br>为什么会发生野指针呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">    0x100812134 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. 因为p是指针。把sp + 0x8的地址中的值给x8</span><br><span class="line">-&gt;  0x100812138 &lt;+4&gt;:  ldr    x8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 2. 把x8寄存器中存的地址的值给w9</span><br><span class="line">    0x10081213c &lt;+8&gt;:  ldrb   w9, [x8]</span><br><span class="line">    0x100812140 &lt;+12&gt;: strb   w9, [sp, #0x7]</span><br><span class="line">    0x100812144 &lt;+16&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100812148 &lt;+20&gt;: ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步寻址操作，获取x8寄存器的值的地址</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read sp</span><br><span class="line">      sp &#x3D; 0x000000016f5f3880</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sp + 0x8 &#x3D; 0x000000016f5f3888</span><br><span class="line">(lldb) x 0x000000016f5f3888</span><br><span class="line">0x16f5f3888: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x16f5f3898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br><span class="line">(lldb) register read x8</span><br><span class="line">  x8 &#x3D; 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p> 这里发现 x8寄存器中存的地址是空，全是0。</p>
</li>
<li><p>把x8寄存器中地址所在的值给w9。寻址操作<br> 这里寻址是从0x00000000上找值，从空地址上找值，就会发生crash。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/18/OC%E5%8E%9F%E7%90%86/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/OC%E5%8E%9F%E7%90%86/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">4.类的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 19:40:55" itemprop="dateCreated datePublished" datetime="2021-04-18T19:40:55+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象、类对象、元类"><a href="#1-对象、类对象、元类" class="headerlink" title="1. 对象、类对象、元类"></a>1. 对象、类对象、元类</h1><h2 id="1-1-isa指向、superClass指向"><a href="#1-1-isa指向、superClass指向" class="headerlink" title="1.1 isa指向、superClass指向"></a>1.1 isa指向、superClass指向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后执行</span><br><span class="line">Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">Teacher *t &#x3D; [[Teacher alloc] init];</span><br></pre></td></tr></table></figure>

<p>我们根据上诉代码进行分析，isa指针的指向。</p>
<blockquote>
<p>注意，这里是用的是真机，而非Mac/模拟器</p>
</blockquote>
<h2 id="1-2-实例对象的isa"><a href="#1-2-实例对象的isa" class="headerlink" title="1.2 实例对象的isa"></a>1.2 实例对象的isa</h2><p>首先我们先看Person的实例p的isa指向情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先打印一下p的内存情况</span><br><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x1d0016620&gt;</span><br><span class="line">&#x2F;&#x2F; 输出p指针的情况</span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x1d0016620: 0x000001a10018d0c5 0x0000000000000000</span><br><span class="line">0x1d0016630: 0x00000001d0091b70 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br></pre></td></tr></table></figure>

<p>这里拿到p指针指向的内存情况，我们知道第一块内存区域存放的是isa指针，直接打印的话，发现就是一串数字，啥也看不出来。还记得上一章中object_getClass反向验证isa指向最后的”&amp;”运算吗？<code>0x000001a10018d0c5</code>这个值就是isa-&gt;bits，我们用它与<code>ISA_MASK</code>进行&amp;运算。因为这里是用的真机，所以<code>ISA_MASK = 0x0000000ffffffff8ULL</code>，如果是用Mac或者模拟器，根据芯片类型判断是否是ARM64架构还是x86，然后使用对应的值进行换算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; p&#x2F;x输出内存的16进制</span><br><span class="line">(lldb) p&#x2F;x 0x000001a10018d0c5 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $3 &#x3D; 0x000000010018d0c0</span><br><span class="line"></span><br><span class="line">(lldb) po 0x000000010018d0c0</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>打印出来是Person。所以isa指向的就是Person类。那我们做一下验证，直接通过<code>object_getClass</code>方法来找一下Person这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x object_getClass(p)</span><br><span class="line">(Class _Nullable) $0 &#x3D; 0x000000010018d0c0 Person</span><br></pre></td></tr></table></figure>

<p>是不是发现，Person类的内存地址是一样的。如果再实例化一个p1，看p1-&gt;isa指向的和p-&gt;isa指向的是否是同一个Person类的内存地址。</p>
<p>答案是肯定的，Person类在内存中只有一份，也就是说所有的类对象在内存中都只有一份。</p>
<h2 id="1-3-类对象的isa"><a href="#1-3-类对象的isa" class="headerlink" title="1.3 类对象的isa"></a>1.3 类对象的isa</h2><p>接下来，我们继续寻找Person类对象的isa指向情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 &#x3D; 1791002988741</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x000000010018d0c0</span><br><span class="line">0x10018d0c0: 0x000001a10018d099 0x00000001b5b12ea0</span><br><span class="line">0x10018d0d0: 0x00000001c00edd00 0x0000000400000007</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000001a10018d099 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $7 &#x3D; 0x000000010018d098</span><br><span class="line">(lldb) po 0x000000010018d098</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>发现Person类对象的isa指向的还是Person，但是这个Person所在的内存地址与Person类对象不一样。</p>
<p>这里就出现了元类的概念（Meta Class）。</p>
<h2 id="1-4-元类的isa"><a href="#1-4-元类的isa" class="headerlink" title="1.4 元类的isa"></a>1.4 元类的isa</h2><p>我们继续寻找元类的isa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx 0x000000010018d098</span><br><span class="line">0x10018d098: 0x000001a1b5b12ec9 0x00000001b5b12ec8</span><br><span class="line">0x10018d0a8: 0x00000001c00edc80 0x0000000100000007</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000001a1b5b12ec9 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $9 &#x3D; 0x00000001b5b12ec8</span><br><span class="line">(lldb) po 0x00000001b5b12ec8</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>使用相同的方法找到元类的isa指向的是NSObject，这个NSObject是类对象吗？</p>
<p>我们通过object_getClass([[NSObject alloc] init])来看看NSObject类对象的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x object_getClass([[NSObject alloc] init])</span><br><span class="line">(Class _Nullable) $11 &#x3D; 0x00000001b5b12ea0 NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x00000001b5b12ea0</span><br><span class="line">0x1b5b12ea0: 0x000001a1b5b12ec9 0x0000000000000000</span><br><span class="line">0x1b5b12eb0: 0x00000001d41fbb00 0x0000000a0000000f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从这里开始，就已经跟上面的内存地址重复了</span><br><span class="line">(lldb) p&#x2F;x 0x000001a1b5b12ec9 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $12 &#x3D; 0x00000001b5b12ec8</span><br><span class="line">(lldb) po 0x00000001b5b12ec8</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>到这里，是不是看明白了点啥？</p>
<p>Person的元类的isa指向的是NSObjec的元类。</p>
<h3 id="1-5-使用相同的办法查看Teache实例的isa"><a href="#1-5-使用相同的办法查看Teache实例的isa" class="headerlink" title="1.5 使用相同的办法查看Teache实例的isa"></a>1.5 使用相同的办法查看Teache实例的isa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx t</span><br><span class="line">0x1d022dee0: 0x000001a102680fd5 0x0000000000000000</span><br><span class="line">0x1d022def0: 0x0000000000000000 0x0000000000000000</span><br><span class="line">(lldb) po 0x000001a102680fd5 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000001a102680fd5 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $18 &#x3D; 0x0000000102680fd0</span><br><span class="line">(lldb) po 0x0000000102680fd0</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x0000000102680fd0</span><br><span class="line">0x102680fd0: 0x000001a102680fa9 0x00000001026810c0</span><br><span class="line">0x102680fe0: 0x00000001c00e6700 0x0000000400000007</span><br><span class="line">(lldb) po 0x000001a102680fa9</span><br><span class="line">1791041736617</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000001a102680fa9 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $21 &#x3D; 0x0000000102680fa8</span><br><span class="line">(lldb) po 0x0000000102680fa8</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx 0x0000000102680fa8</span><br><span class="line">0x102680fa8: 0x000001a1b5b12ec9 0x0000000102681098</span><br><span class="line">0x102680fb8: 0x00000001c00e6a80 0x0000000300000007</span><br><span class="line">(lldb) p&#x2F;x 0x000001a1b5b12ec9 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $23 &#x3D; 0x00000001b5b12ec8</span><br><span class="line">(lldb) po 0x00000001b5b12ec8</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h2><p><img src="isa_metaclass.png" alt=""></p>
<ul>
<li>每个实例对象的isa指针指向与之对应的类对象(Class)。</li>
<li>每个类对象(Class)都有一个isa指针指向一个唯一的元类(Meta Class)。</li>
<li>每一个元类(Meta Class)的isa指针都指向最上层的元类(Meta Class)（图中的NSObject的Meta Class）。最上层的元类(Meta Class)的isa指针指向自己，形成一个回路。</li>
<li>每一个元类(Meta Class)的Super Class指向它原本Class的Super Class的Meta Class。最上层的Meta Class的Super Class指向NSObject Class本身。</li>
<li>最上层的NSObject Class的Super Class指向nil。</li>
<li>只有Class才有继承关系，实例对象与实例对象不存在继承关系。</li>
<li>每一个类对象(Class)在内存中都只有一份。</li>
</ul>
<h1 id="2-通过源码分析"><a href="#2-通过源码分析" class="headerlink" title="2. 通过源码分析"></a>2. 通过源码分析</h1><p>接下来我们从runtime的源码上分析这些都是什么东西。</p>
<h2 id="2-1-实例对象-id（Instance）"><a href="#2-1-实例对象-id（Instance）" class="headerlink" title="2.1 实例对象 id（Instance）"></a>2.1 实例对象 id（Instance）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>id 这个struct的定义本身就带了 个 ＊, 所以我们在使用其他NSObject类型的实例时需要在前加上 ＊, 使 id 时却不用 。</p>
<p>什么是objc_object?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class. </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体, 在这个struct中有 个 isa 指针,指向它的类别 Class。 </p>
<h2 id="2-2-类对象-Class"><a href="#2-2-类对象-Class" class="headerlink" title="2.2 类对象 Class"></a>2.2 类对象 Class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>Class的本质就是一个<code>objc_class</code>的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意，这个源码是被简化之后的。</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    Class getSuperclass() const &#123;</span><br><span class="line">        return superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setSuperclass(Class newSuperclass) &#123;</span><br><span class="line">        superclass &#x3D; newSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isRootClass() &#123;</span><br><span class="line">        return getSuperclass() &#x3D;&#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isRootMetaclass() &#123;</span><br><span class="line">        return ISA() &#x3D;&#x3D; (Class)this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体，大家可能会觉得不对，这个源码是错的，不是我们经常看到的，里头没有那些我们常说的变量，methodLists、ivars等等。<br>大家看仔细了哦，下面这个实现基本都是大家常看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;  </span><br><span class="line">    ...</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE</span><br></pre></td></tr></table></figure>
<p>里头确实有ivars、methodLists等，但是这个是<code>OBJC2_UNAVAILABLE</code>。其内部确实有这些东西的，我们一步步去探究。</p>
<p>继续回到上面的结构体，发现ISA变量被注释掉了，其实也没有影响的，因为<code>objc_class</code> 继承自 <code>objc_object</code>（内部有isa变量）。那我们的属性、方法是存放在哪了呢？</p>
<p>通过查看源码，我们看到有这么一个属性<code>class_data_bits_t</code>，这个东西里可能存放着我们需要的东西。稍后我们做验证。</p>
<h2 id="2-3-元类-Meta-Class"><a href="#2-3-元类-Meta-Class" class="headerlink" title="2.3 元类 Meta Class"></a>2.3 元类 Meta Class</h2><p>OC中一切皆为对象<br>Class在设计中本身也是一个对象,也有superclass。而这个Class对应的类我们叫“元类”（Meta Class）。也就是说Class中有一个isa指向的是Meta Class。</p>
<h2 id="2-4-验证属性的存在位置"><a href="#2-4-验证属性的存在位置" class="headerlink" title="2.4 验证属性的存在位置"></a>2.4 验证属性的存在位置</h2><p>在2.2小结我们说了属性、方法、等可能存在于<code>class_data_bits_t</code>这个结构体内部，我们查看它的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData)</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        &#x2F;&#x2F; Set during realization or construction only. No locking needed.</span><br><span class="line">        &#x2F;&#x2F; Use a store-release fence because there may be concurrent</span><br><span class="line">        &#x2F;&#x2F; readers of data and data&#39;s contents.</span><br><span class="line">        uintptr_t newBits &#x3D; (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;</span><br><span class="line">        atomic_thread_fence(memory_order_release);</span><br><span class="line">        bits &#x3D; newBits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在public的方法中有<code>class_rw_t* data()</code>这个方法，我们进一步探索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t witness;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint16_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v &#x3D; get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实如我们所说的，这里确实存在着我们想要的东西：methods、properties、protocols等。</p>
<p>那我们该怎么获取到这些数据，来证明这些就是我们想要的东西呢？</p>
<p>我们知道在c语言中，一个数组，获取数组中的某个元素的值有多种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">printf(&quot;index 1 &#x3D; %d - %d&quot;, a[1], *(a+1));</span><br></pre></td></tr></table></figure>

<p>比如上面的代码，我们可以直接输出某个元素的下标，也可以通过内存地址来偏移进行读取，同样，我们也可以采取地址偏移来获取<code>objc_class-&gt;bits</code>的值。</p>
<p>需要偏移多少呢？</p>
<p>第一个变量是Class，这是一个结构体，内部有一个isa指针，所以这是8个字节。<br>第二个变量是cache_t，我们进源码看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">private:</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;    &#x2F;&#x2F; 8</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask;      &#x2F;&#x2F; 4</span><br><span class="line">#if __LP64__</span><br><span class="line">            uint16_t                   _flags;          &#x2F;&#x2F; 2</span><br><span class="line">#endif</span><br><span class="line">            uint16_t                   _occupied;       &#x2F;&#x2F; 2</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache; &#x2F;&#x2F; 8</span><br><span class="line">    &#125;;</span><br><span class="line">...   </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实这些就能算出来我们需要多少字节，我已经标好了。静态变量和方法是没有算在结构体内部的哈。</p>
<p>所以8+24 = 32个字节。</p>
<p>也就是我们获取到的<code>objc_class</code>的isa指针，然后偏移32个字节，也就是<code>0x20</code>。</p>
<p>我们做一下验证。</p>
<h3 id="2-4-1-llvm-验证属性存放的位置"><a href="#2-4-1-llvm-验证属性存放的位置" class="headerlink" title="2.4.1 llvm 验证属性存放的位置"></a>2.4.1 llvm 验证属性存放的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x10060e160&gt;</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x10060e160: 0x021d8001000081cd 0x0000000000000000</span><br><span class="line">0x10060e170: 0x0000000000000000 0x86c8f7c495bce30f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 地址0x10060e160+0x20(偏移32个字节)</span><br><span class="line">(lldb) p&#x2F;x (class_data_bits_t *)0x10060e180</span><br><span class="line">(class_data_bits_t *) $3 &#x3D; 0x000000010060e180</span><br><span class="line"></span><br><span class="line">(lldb) p $3-&gt;data()</span><br><span class="line">(class_rw_t *) $4 &#x3D; 0x0000000100605fd0</span><br><span class="line"></span><br><span class="line">(lldb) p *$4</span><br><span class="line">(class_rw_t) $5 &#x3D; &#123;</span><br><span class="line">  flags &#x3D; 3592064</span><br><span class="line">  witness &#x3D; 1</span><br><span class="line">  ro_or_rw_ext &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4301317328</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass &#x3D; 0x000000010060e4d8</span><br><span class="line">  nextSiblingClass &#x3D; 0x000000010060e4d8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $4-&gt;properties()</span><br><span class="line">(const property_array_t) $8 &#x3D; &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      list &#x3D; &#123;</span><br><span class="line">        ptr &#x3D; 0x0000000100606a50</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag &#x3D; 4301285968</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的验证还有待去探索，先到这里，之后补充。</p>
<h1 id="2-属性和成员变量"><a href="#2-属性和成员变量" class="headerlink" title="2. 属性和成员变量"></a>2. 属性和成员变量</h1><p>我们在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">+ (void)sayHello;</span><br><span class="line">- (void)sayHi;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>通过clang，将main.m生成cpp文件查看类中两者的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Person;</span><br><span class="line"></span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *hobby;</span><br><span class="line">  &#x2F;&#x2F; 声明的属性name</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @property (nonatomic, copy) NSString *name;</span><br><span class="line">&#x2F;&#x2F; + (void)sayHello;</span><br><span class="line">&#x2F;&#x2F; - (void)sayHi;</span><br><span class="line"></span><br><span class="line">&#x2F;* @end *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @implementation Person</span><br><span class="line">static void _C_Person_sayHello(Class self, SEL _cmd) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void _I_Person_sayHi(Person * self, SEL _cmd) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Person_name(Person * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Person$_name)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Person_setName_(Person * self, SEL _cmd, NSString *name) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _name), (id)name, 0, 1); &#125;</span><br><span class="line">&#x2F;&#x2F; @end</span><br></pre></td></tr></table></figure>

<p>我们发现，声明的属性name，被直接转化成了带有下划线的成员变量。同时在实现中，多了set、get方法。</p>
<ol>
<li>属性： 在cpp文件中属性有下划线，并且自动生成set和get方法</li>
<li>成员变量：没有下划线，没有set、get方法</li>
<li>实例变量：特殊的的成员变量（类的实例化）</li>
</ol>
<h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><p>我们在类中声明的方法都在<code>method_list_t</code>中，发现这里并没有我们的类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">	unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[5];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	5,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;sayHi&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_sayHi&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setName:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setName_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setName:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setName_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为类方法在元类里头。<br>类方法的声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">	unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CLASS_METHODS_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	1,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;sayHello&quot;, &quot;v16@0:8&quot;, (void *)_C_Person_sayHello&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们以name的get方法为例子，说明一下这都是什么意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;</span><br></pre></td></tr></table></figure>

<p><img src="function_table.png" alt=""></p>
<blockquote>
<p>@16@0:8</p>
</blockquote>
<ul>
<li>‘@’：第一个@表示返回值，对象</li>
<li>‘16’：16个字节</li>
<li>‘@’：第二个@表示对象类型(id)</li>
<li>‘0’：我们知道@表示对象，0表示从0开始，占8个字节</li>
<li>‘:’：SEL，方法明</li>
<li>‘8’：表示从8开始，占8个字节，满足一共16个字节</li>
</ul>
<p>sel 和 imp<br>sel：方法名<br>imp：方法实现。函数指针地址</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>sel、imp的区别</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/18/OC%E5%8E%9F%E7%90%86/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/OC%E5%8E%9F%E7%90%86/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">3.对象的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 13:39:47" itemprop="dateCreated datePublished" datetime="2021-04-18T13:39:47+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本篇使用的objc源码版本位818.2</p>
</blockquote>
<h1 id="1-clang介绍"><a href="#1-clang介绍" class="headerlink" title="1. clang介绍"></a>1. clang介绍</h1><p>Clang是一个由Apple主导的使用C++编写、基于LLVM、发布于LLVM BSD许可证下的C/C++/Objective-C/Objective-C++编译器。它与GNU C语言规范几乎完全兼容(当然，也有部分不兼容的内容， 包括编译命令选项也会有点差异)，并在此基础上增加了额外的语法特性，比如C函数重载 (通过<strong>attribute</strong>((overloadable))来修饰函数)，其目标(之一)就是超越GCC。</p>
<p>2013年4月,Clang已经全面支持C++11标准，并开始实现C++1y特性(也就是C++14，这是 C++的下一个小更新版本)。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。 </p>
<h2 id="1-1-clang的简单使用"><a href="#1-1-clang的简单使用" class="headerlink" title="1.1 clang的简单使用"></a>1.1 clang的简单使用</h2><p>我们通常想看代码的内部实现逻辑，通常会把源文件转换成cpp文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li>main.m 目标文件</li>
<li>main.cpp 转换后的文件</li>
</ul>
<h2 id="1-2-UIKit报错问题"><a href="#1-2-UIKit报错问题" class="headerlink" title="1.2 UIKit报错问题"></a>1.2 UIKit报错问题</h2><p>当我们想转化带有UIKit相关的的东西时，上面的命令就会报错了。使用如下命令即可</p>
<p>clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.3.sdk ViewController.m</p>
<p>如果还会报错，多数是因为<code>iPhoneSimulator14.3.sdk</code>没有找到，则通过xcode-contents找到对应的sdk即可。 </p>
<h2 id="1-3-xcrun"><a href="#1-3-xcrun" class="headerlink" title="1.3 xcrun"></a>1.3 xcrun</h2><p>xcode安装的时候顺带安装了<code>xcrun</code>命令，<code>xcrun</code>命令在<code>clang</code>的基础上进行了一些封装，要更好用一些。</p>
<ul>
<li><p>模拟器 - 使用如下命令<br>xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp </p>
</li>
<li><p>真机<br>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp</p>
</li>
</ul>
<h1 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h1><p>在main.m下创建一个Person类，然后通过上面的clang命令，找到我们需要的cpp文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface APerson : NSObject</span><br><span class="line">&#x2F;&#x2F; 添加一个属性，方便确认这就是我们要找的类</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation APerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>转化之后，在cpp文件里，我们找到了如下的结构体。</p>
<h2 id="2-1-类的声明"><a href="#2-1-类的声明" class="headerlink" title="2.1 类的声明"></a>2.1 类的声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @interface APerson : NSObject。声明</span><br><span class="line">struct APerson_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现，一个对象，它本身就是一个结构体，因为是继承自NSObject，他内部的第一个变量就是NSObject。而<code>NSObject_IVARS</code>就是我们经常说的isa指针。</p>
<h2 id="2-2-类的实现"><a href="#2-2-类的实现" class="headerlink" title="2.2 类的实现"></a>2.2 类的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @implementation APerson</span><br><span class="line"></span><br><span class="line">static NSString * _I_APerson_name(APerson * self, SEL _cmd) </span><br><span class="line">&#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_APerson$_name)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_APerson_setName_(APerson * self, SEL _cmd, NSString *name) </span><br><span class="line">&#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct APerson, _name), (id)name, 0, 1); &#125;</span><br><span class="line">&#x2F;&#x2F; @end</span><br></pre></td></tr></table></figure>

<p>我们在上面的代码里，看到了两个方法</p>
<ol>
<li><code>_I_APerson_name</code>：这是一个get方法，直接做了一个return操作。</li>
<li><code>_I_APerson_setName_</code>：这是一个set方法，调用了<code>objc_setProperty</code>。</li>
</ol>
<h3 id="2-2-1-set方法"><a href="#2-2-1-set方法" class="headerlink" title="2.2.1 set方法"></a>2.2.1 set方法</h3><p>通过objc的源码，我们查找<code>objc_setProperty</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) </span><br><span class="line">&#123;</span><br><span class="line">    bool copy &#x3D; (shouldCopy &amp;&amp; shouldCopy !&#x3D; MUTABLE_COPY);</span><br><span class="line">    bool mutableCopy &#x3D; (shouldCopy &#x3D;&#x3D; MUTABLE_COPY);</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部判断是通过copy还是mutableCopy，然后调用<code>reallySetProperty</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot &#x3D;&#x3D; newValue) return;</span><br><span class="line">        newValue &#x3D; objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最主要的操作，就是对oldvalue进行release操作，新值进行retain操作。</p>
<p>这也是经常在面试时，经常会问的，声明一个@property内部有哪些操作的的答案。以及内部实现。</p>
<h1 id="3-isa"><a href="#3-isa" class="headerlink" title="3. isa"></a>3. isa</h1><p>我们应该还记得在【alloc、init、new】这一节中有<code>callAlloc</code>这个方法，这个方法有一步操作是进行对象关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    ASSERT(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就看看这里是怎么搞的。对代码进行了简化，如果有需要请自行查看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    &#x2F;&#x2F; 这个是重点，创建一个isa_t，这个isa_t是啥呢？我们点进去看一下。</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下代码可以等先看我isa_t之后再回过头来看。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对bits内容赋默认值</span><br><span class="line">    newisa.bits &#x3D; ISA_MAGIC_VALUE;      </span><br><span class="line">    &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">    &#x2F;&#x2F; 这里是关联对象，就是本节的重点内容，我们进去看这个setClass是怎么实现的。</span><br><span class="line">    newisa.setClass(cls, this);</span><br><span class="line">    newisa.extra_rc &#x3D; 1;</span><br><span class="line">    isa &#x3D; newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先看下isa_t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">private: &#x2F;&#x2F;这是个私有的，不会主动赋值，而是通过赋值别的变量时给的。</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    void setClass(Class cls, objc_object *obj);</span><br><span class="line">    Class getClass(bool authenticated);</span><br><span class="line">    Class getDecodedClass(bool authenticated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码做了精简处理，看起来会容易点，这个其实就是一个<b>【联合位域】</b>。<br>union是联合体。里面有一个struct。这种方式就是为了优化内存空间，在极少的内存情况下，来使用。举个例子来看一下：</p>
<p>如果我们需要声明一个car的类，定义4个属性，前后左右行驶。如果是int类型的数据，那就是需要4 * 4 = 16个字节的空间，也就是128位。但是如果使用联合位域的话，就可以极大的减少空间。只需要4位就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union car &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        char forward;   &#x2F;&#x2F;1</span><br><span class="line">        char back;      &#x2F;&#x2F;1</span><br><span class="line">        char left;      &#x2F;&#x2F;1</span><br><span class="line">        char right;     &#x2F;&#x2F;1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是<code>0000</code>，第一个0代表的是前，第二个0代表后，依次类推。</p>
<p>知道了联合位域的大概情况，我们就看一下这个<code>ISA_BITFIELD</code>是个什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">        uintptr_t magic             : 6;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t unused            : 1;                                       \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">#     define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#     define RC_HALF  (1ULL&lt;&lt;18)</span><br></pre></td></tr></table></figure>

<p><img src="isa_t.png" alt=""></p>
<p>注意：这个是ARM64下的存储，而使用（非M1芯片）电脑本地运行的的都是基于x86_64的，所以这里面的值存储的位置是有些变化的。</p>
<p>特别提一下shiftcls，在ARM64下是33位，在x86下是44位，导致magic开始的位置分别是36和47，这个位置一会有用到。</p>
<ul>
<li>nonpointer:表示是否对 isa 指针开启指针优化 0:纯isa指针，1:不止是类对象地址,isa 中包含了类信息、对象的引用计数等</li>
<li>has_assoc:关联对象标志位，0没有，1存在</li>
<li>has_cxx_dtor:该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象。oc中的<code>dealloc</code></li>
<li>shiftcls:存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li>
<li>magic:用于调试器判断当前对象是真的对象还是没有初始化的空</li>
<li>weakly_referenced:志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。 </li>
<li>unsed:不同版本的是<code>deallocating</code>，标志对象是否正在释放内存</li>
<li>has_sidetable_rc:当对象引用技术大于 10 时，则需要借用该变量存储进位</li>
<li>extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li>
</ul>
<p>我们了解了isa是啥东西了之后，在回过头看看是怎么进行管理对象的。了解上面的代码之后，我们继续看setCalss是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对代码进行了简化，</span><br><span class="line">inline void</span><br><span class="line">isa_t::setClass(Class newCls, UNUSED_WITHOUT_PTRAUTH objc_object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    shiftcls &#x3D; (uintptr_t)newCls &gt;&gt; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很不可思议，只是通过newCls向右偏移了3位。为啥偏移3位？<br>我们知道isa-&gt;shiftcls存储类指针的值。是从isa的内存里面第3位开始的。就这么简单。因为在内存里没有办法直接存储类名，所以通过存储数字替带。</p>
<h2 id="3-1-验证isa指针的关联过程"><a href="#3-1-验证isa指针的关联过程" class="headerlink" title="3.1 验证isa指针的关联过程"></a>3.1 验证isa指针的关联过程</h2><p><code>Person *p = [[Person alloc] init];</code> 运行objc源码工程。<br>断点进入<code>objc_object::initIsa</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    &#x2F;&#x2F; ① 创建newisa</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ② 对bits内容赋默认值</span><br><span class="line">    newisa.bits &#x3D; ISA_MAGIC_VALUE;      </span><br><span class="line">    &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; ③ </span><br><span class="line">    newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">    &#x2F;&#x2F; ④ 这里是关联对象，就是本节的重点内容，我们进去看这个setClass是怎么实现的。</span><br><span class="line">    newisa.setClass(cls, this);</span><br><span class="line">    newisa.extra_rc &#x3D; 1;</span><br><span class="line">    isa &#x3D; newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当断点走到②的时候。我们输出一些newisa的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p newisa</span><br><span class="line">(isa_t) $1 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 0</span><br><span class="line">  cls &#x3D; nil</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 0</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 0</span><br><span class="line">    magic &#x3D; 0</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续执行下一步，仍然输出newisa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p newisa</span><br><span class="line">(isa_t) $5 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 8303511812964353</span><br><span class="line">  cls &#x3D; 0x001d800000000001</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 1</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 0</span><br><span class="line">    magic &#x3D; 59</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有了变化，bits有初值了，cls也被赋值了，而且magic也被赋值了。这些都是默认值，我们上面说了isa的内部是64位的数据。我们把cls的值，放在二进制的计算器里，看看是什么内容。第一位1对应的是nonpointer=1</p>
<p><img src="magic_47.png" alt=""></p>
<p>看这个图，第47位开始的6位数据是110111，这个二进制数是什么？正好是59。</p>
<p>之后，继续断点下一步。走到④。然后进到setClass方法内部，我们执行语句，看看cls偏移后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (uintptr_t)newCls</span><br><span class="line">(uintptr_t) $15 &#x3D; 4295000320</span><br><span class="line">(lldb) po (uintptr_t)newCls &gt;&gt; 3</span><br><span class="line">536875040</span><br></pre></td></tr></table></figure>

<p>然后继续下一步，打印newisa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lldb) p newisa</span><br><span class="line">(isa_t) $11 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 8303516107964673</span><br><span class="line">  cls &#x3D; Person</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 1</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 536875040</span><br><span class="line">    magic &#x3D; 59</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯哼。。。。。是不是，就是这么牛。shiftcls是啥，存储类指针的值。也验证了我们上面说的，是从isa的内存里面第3位开始的。就这么简单。因为在内存里没有办法直接存储类名，所以通过存储数字替带。</p>
<p>我们继续执行，返回到<code>_class_createInstanceFromZone</code>这个函数里，<br>然后先停一停哈，不要走断点了哈~我们来通过<code>object_getClass</code>在来验证一下。</p>
<h2 id="3-2-反向验证"><a href="#3-2-反向验证" class="headerlink" title="3.2 反向验证"></a>3.2 反向验证</h2><p>我们通过object_getClass来反向验证isa指向。这里全部对代码进行了简化。如有需要请自行查看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">objc_object::getIsa() </span><br><span class="line">&#123;</span><br><span class="line">    if (fastpath(!isTaggedPointer())) return ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">objc_object::ISA(bool authenticated)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return isa.getDecodedClass(authenticated);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">isa_t::getClass(MAYBE_UNUSED_AUTHENTICATED_PARAM bool authenticated) &#123;</span><br><span class="line">    uintptr_t clsbits &#x3D; bits;</span><br><span class="line">    clsbits &amp;&#x3D; ISA_MASK;</span><br><span class="line">    return (Class)clsbits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到了结果了，最后就是通过<code>bits &amp; ISA_MASK</code>来返回当前class的。还记得bits是啥吗？往上翻一下，bits是isa指针内部的第一个元素。所以我们按照这个&amp;运算来验证一些，返回的数据是不是person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx obj</span><br><span class="line">0x10060d9b0: 0x011d800100008101 0x0000000000000000</span><br><span class="line">0x10060d9c0: 0x0000000000000000 0x86c8f7c495bce30f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿第一位的地址进行&amp;运算，注意这里是在mac上，所以使用x86下的ISA_MASK值</span><br><span class="line">(lldb) po 0x011d800100008101 &amp; 0x00007ffffffffff8ULL</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>以上就是isa的全部内容了。但是isa里面的这些东西是真的有用吗？肯定是有用的啊，我们从dealloc的函数实现去找到蛛丝马迹。</p>
<h1 id="4-dealloc"><a href="#4-dealloc" class="headerlink" title="4. dealloc"></a>4. dealloc</h1><p>在objc源码中找到dealloc的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，见证奇迹的时候到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  &#x2F;&#x2F; fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer                     &amp;&amp;</span><br><span class="line">         !isa.weakly_referenced             &amp;&amp;</span><br><span class="line">         !isa.has_assoc                     &amp;&amp;</span><br><span class="line">#if ISA_HAS_CXX_DTOR_BIT</span><br><span class="line">         !isa.has_cxx_dtor                  &amp;&amp;</span><br><span class="line">#else</span><br><span class="line">         !isa.getClass(false)-&gt;hasCxxDtor() &amp;&amp;</span><br><span class="line">#endif</span><br><span class="line">         !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>objc_object::rootDealloc</code>中对isa的各个属性的值来判断是执行<code>free</code>操作或者<code>object_dispose</code>。free函数就不用多说了，来看看dispose操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是整个的dealloc的流程。通过源码只是来加深对这些流程的印象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">2.内存对齐</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 18:34:07" itemprop="dateCreated datePublished" datetime="2021-04-17T18:34:07+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象的内存对齐"><a href="#1-对象的内存对齐" class="headerlink" title="1. 对象的内存对齐"></a>1. 对象的内存对齐</h1><p>先看代码哈~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int score;</span><br><span class="line">@property (nonatomic, assign) long height;</span><br><span class="line">@property (nonatomic) char c1;</span><br><span class="line">@property (nonatomic) char c2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">Person *person &#x3D; [Person alloc];</span><br><span class="line">person.name &#x3D; @&quot;name&quot;;</span><br><span class="line">person.age &#x3D; 18;</span><br><span class="line">person.score &#x3D; 20;</span><br><span class="line">person.height &#x3D; 180;</span><br><span class="line">person.c1 &#x3D; &#39;a&#39;;</span><br><span class="line">person.c2 &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,person,sizeof(person),class_getInstanceSize([Person class]),malloc_size((__bridge const void *)(person)));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在NSLog上打个断点。有时间的话，可以把属性先注释掉，从0开始，一个属性一个属性的加起来看输出的是什么结果。</p>
<ol>
<li><p>po 这里直接输出person指向的对象的内存地址。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po person</span><br><span class="line">&lt;Person: 0x600002adbcf0&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里有一个需要介绍的点，上一章中有用到x person命令，输出的内容与<code>View Memory</code>中显示的是一致的。而<code>x/8gx</code>就是进行排序。8代表的是输出8组内存。如果是4那就是输出4组内容。每一块都是8个字节。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8gx person</span><br><span class="line">0x600002adbcf0: 0x0000000103930808 0x0000001200006261</span><br><span class="line">0x600002adbd00: 0x0000000000000014 0x000000010392b038</span><br><span class="line">0x600002adbd10: 0x00000000000000b4 0x0000000000000000</span><br><span class="line">0x600002adbd20: 0x0000c1c5c19bbd20 0x00000000000007fb</span><br></pre></td></tr></table></figure>
<p> 0x600002adbcf0：是person指向的首地址。后面存放的都是属性的值。内存都是连续的。</p>
</li>
<li><p>我们分别输出内存里的内容。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0000000103930808</span><br><span class="line">Person  &#x2F;&#x2F; isa指针</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000012</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">(lldb) po 61</span><br><span class="line">61</span><br><span class="line"></span><br><span class="line">(lldb) po 0x0000000000000014</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">(lldb) po 0x000000010392b038</span><br><span class="line">name</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000000000000b4</span><br><span class="line">180</span><br></pre></td></tr></table></figure>

<p> 0x0000001200006261：这一块地址上内容是被拆开的。我们知道int是4个字节，char是1个字节，所以前面的几位是int的值，后面的再进行拆分，分别是两个char类型的数据。</p>
<p> 苹果在内存上也是做了足够多的优化，虽然在内存上是16个字节对齐的，但是在内部实现上，还是进行了大量的优化，但是一定要注意的是，属性是按8个字节对齐的。</p>
<p> 但是为啥两个int类型的数据没有放在一起呢？可能是系统内部做的优化，可以试一下，把所有的char类型注释掉，两个int类型的数据就会存放在一起。可能是会将char类型的数据优先进行填充吧。另外可以多试一下，3个char类型的会怎么样？</p>
</li>
<li><p>最后输出的结果是</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600002adbcf0&gt; - 8 - 40 - 48</span><br></pre></td></tr></table></figure>
<p> 我们分析一下输出的内容：</p>
<ul>
<li>person：当前的类对象，存放的指针，指向的内存地址。</li>
<li>sizeof(person)：person存放的就是一个指针，8个字节。</li>
<li>class_getInstanceSize([Person class])：这个类真正需要的空间。属性是8个字节对齐的。</li>
<li>malloc_size((__bridge const void *)(person))：内存中需要开辟的空间。内存空间是16个字节对齐的。</li>
</ul>
</li>
</ol>
<h1 id="1-1-float、double"><a href="#1-1-float、double" class="headerlink" title="1.1 float、double"></a>1.1 float、double</h1><p>加如改变其中的一个属性位double类型的，又会是什么情况呢？我这里把上面的height改为了double类型。看一下输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8gx person</span><br><span class="line">0x600000045530: 0x000000010626d808 0x0000001200006261</span><br><span class="line">0x600000045540: 0x0000000000000014 0x0000000106268038</span><br><span class="line">0x600000045550: 0x4066800000000000 0x0000000000000000</span><br><span class="line">0x600000045560: 0x0000000000000000 0x0000000000000000</span><br><span class="line">(lldb) po 0x4066800000000000</span><br><span class="line">4640537203540230144</span><br></pre></td></tr></table></figure>

<p>诶<del>~</del> 怎么没有输出180呢？是因为对于float、double类型的数据，系统会做一次特殊的转换处理。我们没有办法直接从内存中读出double类型的值。（也有可能是我没有找到方法，有知道的小伙伴请告知，谢谢！）</p>
<p>但是我们可以通过转化double类型的数据来看是否位上面对应的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x (double)180.0</span><br><span class="line">(double) $4 &#x3D; 0x4066800000000000</span><br></pre></td></tr></table></figure>
<p>转换后，发现正好是对应的数据。</p>
<h1 id="2-结构体的内存对齐"><a href="#2-结构体的内存对齐" class="headerlink" title="2. 结构体的内存对齐"></a>2. 结构体的内存对齐</h1><blockquote>
<ol>
<li>数据成员对⻬规则：结构体(struct)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始(比如int为4字节,则要从4的整数倍地址开始存储。</li>
<li>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a里存有struct b，b里有char，int, double等元素，那b应该从8的整数倍开始存储)</li>
<li>收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍。不足的要补⻬。</li>
</ol>
</blockquote>
<p>上代码，看看结构体的内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   </span><br><span class="line">    char b;     </span><br><span class="line">    int c;      </span><br><span class="line">    short d;    </span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a; </span><br><span class="line">    int b;    </span><br><span class="line">    char c;   </span><br><span class="line">    short d;  </span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str1 &#x3D; %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>输出的结果很明白的哈。<code>str1 = 24, str2-16</code></p>
<p>我们分析一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F; 8 (0-7)</span><br><span class="line">    char b;     &#x2F;&#x2F; 1 [8 1] (8)</span><br><span class="line">    int c;      &#x2F;&#x2F; 4 [9 10 11 12] 9不是4的整数倍(12 13 14 15)</span><br><span class="line">    short d;    &#x2F;&#x2F; 2 [16 17]</span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部需要的大小为: 17</span><br><span class="line">&#x2F;&#x2F; 最大属性 : 8</span><br><span class="line">&#x2F;&#x2F; 结构体整数倍: 24</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F;8 (0-7)</span><br><span class="line">    int b;      &#x2F;&#x2F;4 (8 9 10 11)</span><br><span class="line">    char c;     &#x2F;&#x2F;1 (12)</span><br><span class="line">    short d;    &#x2F;&#x2F;2 (13 14) 13不是2的整数倍，从14开始(14 15)</span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部需要的大小为: 15</span><br><span class="line">&#x2F;&#x2F; 最大属性 : 8</span><br><span class="line">&#x2F;&#x2F; 结构体整数倍: 16</span><br><span class="line">NSLog(@&quot;str1 &#x3D; %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>这就是内存补齐的内容</p>
<h1 id="3-总结："><a href="#3-总结：" class="headerlink" title="3. 总结："></a>3. 总结：</h1><ul>
<li>类对象的属性是8个字节对齐的，但是在内存空间是16个字节对齐。</li>
<li>x/4gx的使用</li>
<li>结构体的对齐规则。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/alloc-init-new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/alloc-init-new/" class="post-title-link" itemprop="url">1.alloc、init、new</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 09:20:25" itemprop="dateCreated datePublished" datetime="2021-04-17T09:20:25+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-先看一个问题"><a href="#1-先看一个问题" class="headerlink" title="1. 先看一个问题"></a>1. 先看一个问题</h1><p>我们先看一段代码，打印一下输出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 &#x3D; [Person alloc];</span><br><span class="line">Person *p2 &#x3D; [p1 init];</span><br><span class="line">Person *p3 &#x3D; [p1 init];</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p1,p1,&amp;p1);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p2,p2,&amp;p2);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p3,p3,&amp;p3);</span><br></pre></td></tr></table></figure>

<p>看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114068</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114060</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114058</span><br></pre></td></tr></table></figure>

<p>前两个打印的都是当前对象的指针地址，而最后一个为啥会不一样？<br>首先需要明白p和&amp;p的区别：p是当前变量指向的地址。&amp;p是存放当前变量所在的地址。<br>这里第一个%p打印就是[Person alloc]生成的地址。第二个%p是存放的是指向【生成的对象】的地址。</p>
<p>也就是当前alloc生成一个对象开辟了一块内存空间。p1、p2、p3分别开辟一块地址指向alloc开辟的空间。</p>
<p><img src="oc-address.png" alt=""></p>
<h1 id="2-alloc的执行过程"><a href="#2-alloc的执行过程" class="headerlink" title="2. alloc的执行过程"></a>2. alloc的执行过程</h1><p>那我们接下来要看alloc是怎么执行的。需要看objc的源码。<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4源码</a>是可以直接下载的。我们这里用的是最新的818.2版本的。</p>
<p>通过一系列风骚的操作，我们让源码可以运行起来。通过断点和源码我们分析一下alloc的执行过程。</p>
<h2 id="2-1-objc-rootAlloc"><a href="#2-1-objc-rootAlloc" class="headerlink" title="2.1 _objc_rootAlloc"></a>2.1 _objc_rootAlloc</h2><p>在main.m中，创建一个对象，打上断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p &#x3D; [Person alloc];</span><br><span class="line">Person *p1 &#x3D; [p init];</span><br></pre></td></tr></table></figure>

<p>这里只是alloc的最基本的方法。没有什么代码量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-callAlloc"><a href="#2-2-callAlloc" class="headerlink" title="2.2 callAlloc"></a>2.2 callAlloc</h2><p>这里是核心代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);   &#x2F;&#x2F; 1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;                            &#x2F;&#x2F; 2. </span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); &#x2F;&#x2F; 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>该处内容是现阶段alloc执行的代码</li>
<li>该处已经不执行了，allocWithZone已经在iOS8以后使用的范围教小。</li>
<li>通过消息发送，执行alloc</li>
</ol>
<h2 id="2-3-objc-rootAllocWithZone"><a href="#2-3-objc-rootAllocWithZone" class="headerlink" title="2.3 _objc_rootAllocWithZone"></a>2.3 _objc_rootAllocWithZone</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-class-createInstanceFromZone"><a href="#2-4-class-createInstanceFromZone" class="headerlink" title="2.4 _class_createInstanceFromZone"></a>2.4 _class_createInstanceFromZone</h2><p>这里是重中之重。alloc的流程都在这里完美的展示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 既然要生成一个对象，首先要做的就是开辟空间，但是要开辟多少？就是这里说了算。</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 2. 算出来需要多少空间，这里进行开辟</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3. 空间有了，这里进行对象关联</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-cls-gt-instanceSize"><a href="#2-4-1-cls-gt-instanceSize" class="headerlink" title="2.4.1 cls-&gt;instanceSize"></a>2.4.1 cls-&gt;instanceSize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是在ARM64下，内存开辟都是16个字节进行对齐的。所以计算的大小的都是16的倍数。</p>
<h3 id="2-4-2-calloc"><a href="#2-4-2-calloc" class="headerlink" title="2.4.2 calloc"></a>2.4.2 calloc</h3><p>calloc申请开辟内存，返回地址指针。</p>
<h3 id="2-4-3-obj-gt-initInstanceIsa"><a href="#2-4-3-obj-gt-initInstanceIsa" class="headerlink" title="2.4.3 obj-&gt;initInstanceIsa"></a>2.4.3 obj-&gt;initInstanceIsa</h3><p>生成的对象与class进行关联。通过isa指针。（isa之后会有说明，每一个类都有一个isa指针）。</p>
<h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p><img src="oc-alloc.png" alt=""></p>
<p>这个图很好的说明了alloc的流程。</p>
<h1 id="3-init"><a href="#3-init" class="headerlink" title="3. init"></a>3. init</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span><br><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init其实是工厂方法，从上面的代码可以看到，只是<code>return self</code>。这里有一个重要的点，就是大部分的实现都会交给子类去重新，自定义init方法。</p>
<h1 id="4-new"><a href="#4-new" class="headerlink" title="4. new"></a>4. new</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false&#x2F;*checkNil*&#x2F;) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到new的实现就是执行了，callAlloc()，然后执行了init操作。与实际上的<code>[[Person alloc] init]</code>并没有什么区别。</p>
<p>但是看到有一些博客上说，还是有区别，因为init被重写之后，调用new可能会造成少些东西。这里不能苟同哈，所有的方法调用，在OC中都是objc_msgSend，会去寻找方法列表的。所以不会存在什么不同。</p>
<h1 id="5-扩展知识"><a href="#5-扩展知识" class="headerlink" title="5. 扩展知识"></a>5. 扩展知识</h1><p>我们已经知道了，本身写一个Person类，需要开辟16个字节的空间，那需要申请多大内存空间是由什么因素决定的？<br>我们可以试一下分别添加一个属性，两个属性，试一下。自己动手试一下哈，看看2.4.1小结处返回的size是多少。这里不细说了哦~</p>
<p>我这里添加了两个NSString属性，分别赋值A和B。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x600002f86cc0&gt;</span><br><span class="line">(lldb) x p</span><br><span class="line">0x600002f86cc0: 60 76 e3 06 01 00 00 00 40 20 e3 06 01 00 00 00  &#96;v......@ ......</span><br><span class="line">0x600002f86cd0: 60 20 e3 06 01 00 00 00 00 00 00 00 00 00 00 00  &#96; ..............</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x600002f86cc0: 0x0000000106e37660 0x0000000106e32040</span><br><span class="line">0x600002f86cd0: 0x0000000106e32060 0x0000000000000000</span><br><span class="line">(lldb) po 0x0000000106e37660    &#x2F;&#x2F; isa指针，指向class</span><br><span class="line">Person</span><br><span class="line">(lldb) po 0x0000000106e32040</span><br><span class="line">A</span><br><span class="line">(lldb) po 0x0000000106e32060</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<p>通过<code>x p</code>命令我们可以打印出<code>p</code>的内存地址。从<code>0x600002f86cc0 --- 0x600002f86cd0</code>公占用0x20个自己的空间，也就是32个字节。</p>
<h1 id="6-真正的alloc流程"><a href="#6-真正的alloc流程" class="headerlink" title="6. 真正的alloc流程"></a>6. 真正的alloc流程</h1><p>当我们执行<code>[Person alloc]</code>的时候，系统内部会通过llvm的函数方法把alloc 指向到<code>objc_alloc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先执行一次<code>callAlloc(cls, true, false)</code>，注意这里的参数。然后执行到calAlloc中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil); &#x2F;&#x2F;1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#x2F;&#x2F; 2.</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); &#x2F;&#x2F; 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行，我们发现会先执行第3个return。所执行的还是<code>alloc</code>，这时候执行的才是真正的alloc。然后就可以顺着第2节的内容继续了。</p>
<p>如图，是完整的alloc会执行两次的流程图：</p>
<p><img src="oc-alloc-2.png" alt=""></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>alloc的流程</li>
<li>alloc的两次执行过程</li>
<li>init</li>
<li>new</li>
</ul>
<p>有什么不对的欢迎指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
