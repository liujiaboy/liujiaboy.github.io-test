<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/page/3/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/14/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/14/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-3/" class="post-title-link" itemprop="url">ARM汇编-3 状态寄存器 if、loop、switch</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 22:05:25" itemprop="dateCreated datePublished" datetime="2021-04-14T22:05:25+08:00">2021-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-状态寄存器"><a href="#1-状态寄存器" class="headerlink" title="1. 状态寄存器"></a>1. 状态寄存器</h1><p>CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同)。这种寄存器在ARM中，被称为状态寄存器就是CPSR(current program status register)寄存器。</p>
<p>CPSR和其他寄存器不一样,其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<blockquote>
<p>CPSR寄存器是32位的。</p>
</blockquote>
<ul>
<li>CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!</li>
<li>N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行！</li>
</ul>
<p><img src=".jpg" alt=""></p>
<h2 id="1-1-N-（Negative）"><a href="#1-1-N-（Negative）" class="headerlink" title="1.1 N （Negative）"></a>1.1 N （Negative）</h2><p>cpsr的第31位是N，它记录相关指令执行后的结果，结果是负数，则N=1，非负数则N=0。</p>
<blockquote>
<p>在ARM64的指令集中，逻辑运算或者算数运算（add、sub、or等）指令的执行会影响状态寄存器的值。</p>
</blockquote>
<p>n=1：结果是负数<br>n=0：结果位非负数，包括0</p>
<h2 id="1-2-Z（Zero）"><a href="#1-2-Z（Zero）" class="headerlink" title="1.2 Z（Zero）"></a>1.2 Z（Zero）</h2><p>cpsr的第30位是Z，0标志位。它记录相关指令执行后其结果是否为。如果结果为0，那么Z = 1；如果结果不为0，那么Z = 0.</p>
<p>z=1：结果为0<br>z=0：结果不为0</p>
<h2 id="1-3-C（Carry）"><a href="#1-3-C（Carry）" class="headerlink" title="1.3 C（Carry）"></a>1.3 C（Carry）</h2><p>cpsr第29位是c进位标志位，一般情况进行下无符号述的运算。</p>
<p>加法运算：当运算结果产生了进位时（无符号数溢出）c=1，没有溢出c=0<br>减法运算：包括（CPM）当运算时产生了借位（无符号数溢出），c=0，没有溢出c=1</p>
<h3 id="1-3-1-进位"><a href="#1-3-1-进位" class="headerlink" title="1.3.1 进位"></a>1.3.1 进位</h3><p>两个数据相加，比如正常的十进制运算，5+5=10，向十位数进1，个位数为0。但是超过其最大的位数时，发生溢出，导致进位的值无法保存，也就是说进位的值丢失了。但是CPU在运算的时候，并不会丢弃这个进位的值，二手放在寄存器里了，也就是cpsr的c位。</p>
<h3 id="1-3-2-借位"><a href="#1-3-2-借位" class="headerlink" title="1.3.2 借位"></a>1.3.2 借位</h3><p>两个数据做减法操作，有可能向更高位借位。比如：10-5=5，各位不够减，需要向十位去借。这时候会用c位来标记借位。</p>
<h2 id="1-4-V（Overflow）"><a href="#1-4-V（Overflow）" class="headerlink" title="1.4 V（Overflow）"></a>1.4 V（Overflow）</h2><p>cpsr的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。</p>
<ul>
<li>正数 + 正数 = 负数。溢出</li>
<li>负数 + 负数 = 正数。溢出</li>
<li>正数 + 负数 不可能发生溢出</li>
</ul>
<h1 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h1><p>NZ：是否为0，判断正负<br>CV：无符号，有符号判断是否溢出 </p>
<h1 id="2-全局变量、常量"><a href="#2-全局变量、常量" class="headerlink" title="2. 全局变量、常量"></a>2. 全局变量、常量</h1><p>开始这一节之前，先知道我们的内存分区划分：</p>
<p>代码区：存放代码，可读，可执行<br>栈区：参数、局部变量、临时数据，可读可写<br>堆区：动态申请，可读可写</p>
<p>全局变量：可读可写<br>常量区：只读</p>
<p>接下来，我们分析代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个全局变量</span><br><span class="line">int g &#x3D; 12;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个方法</span><br><span class="line">int func(int a,int b)&#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;haha&#39;就是一个常量，在常量区</span><br><span class="line">    printf(&quot;haha&quot;);</span><br><span class="line">    &#x2F;&#x2F; 局部变量c</span><br><span class="line">    int c &#x3D; a + g + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">   </span><br><span class="line">    func(10, 20);</span><br><span class="line">    </span><br><span class="line">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，走汇编流程，进行查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">-&gt;  0x100bc211c &lt;+0&gt;:  sub    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x100bc2120 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100bc2124 &lt;+8&gt;:  add    x29, sp, #0x10            ; &#x3D;0x10 </span><br><span class="line">    0x100bc2128 &lt;+12&gt;: stur   w0, [x29, #-0x4]</span><br><span class="line">    0x100bc212c &lt;+16&gt;: str    w1, [sp, #0x8]</span><br><span class="line">    0x100bc2130 &lt;+20&gt;: adrp   x0, 1</span><br><span class="line">    0x100bc2134 &lt;+24&gt;: add    x0, x0, #0xf9f            ; &#x3D;0xf9f </span><br><span class="line">    &#x2F;&#x2F; ① 这里执行了printf操作，大致可以判断，x0中存的就是&#39;haha&#39;</span><br><span class="line">    0x100bc2138 &lt;+28&gt;: bl     0x100bc25b0               ; symbol stub for: printf</span><br><span class="line">    0x100bc213c &lt;+32&gt;: ldur   w8, [x29, #-0x4]</span><br><span class="line">    &#x2F;&#x2F; ② 这里获取的是全局变量</span><br><span class="line">    0x100bc2140 &lt;+36&gt;: adrp   x9, 3</span><br><span class="line">    0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; &#x3D;0x648 </span><br><span class="line">    0x100bc2148 &lt;+44&gt;: ldr    w10, [x9]</span><br><span class="line">    0x100bc214c &lt;+48&gt;: add    w8, w8, w10</span><br><span class="line">    0x100bc2150 &lt;+52&gt;: ldr    w10, [sp, #0x8]</span><br><span class="line">    0x100bc2154 &lt;+56&gt;: add    w8, w8, w10</span><br><span class="line">    0x100bc2158 &lt;+60&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x100bc215c &lt;+64&gt;: ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bc2160 &lt;+68&gt;: mov    x0, x8</span><br><span class="line">    0x100bc2164 &lt;+72&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100bc2168 &lt;+76&gt;: add    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x100bc216c &lt;+80&gt;: ret</span><br></pre></td></tr></table></figure>

<p>①这里执行了printf操作，这里看一些是否真的打印了’haha’。我们追一下x0寄存器的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x100bc2130 &lt;+20&gt;: adrp   x0, 1</span><br></pre></td></tr></table></figure>
<p>这里有一个关键字需要注意一下：<br>adrp: 针对address page操作<br>这一行代码有三个操作：</p>
<ol>
<li>将1左移12位（即在1后加3个0变成1000）</li>
<li>将当前寄存器的地址的低12位清0，即当前行的地址的后3位清0。0x1002b2184 -&gt; 0x100bc2130</li>
<li>把0x1000+0x100bc2000赋值给x0，x0=0x100bc3000，即当前行地址的倒数第4位与x0后面的数字相加</li>
</ol>
<p>说白了，这句代码的意思就是找到某一页地址的开始。我们走断点，打印一下x0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read x0</span><br><span class="line">x0 &#x3D; 0x0000000100bc3000</span><br></pre></td></tr></table></figure>

<p>下一句的代码是，<code>add x0, x0, #0xf9f</code>，就x0的地址+0x0xf9f<br>获取x0的值位0x100bc3f9f</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read x0</span><br><span class="line">x0 &#x3D; 0x0000000100bc3f9f  &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">(lldb) x 0x0000000100bc3f9f</span><br><span class="line">0x100bc3f9f: 68 61 68 61 00 01 00 00 00 1c 00 00 00 02 00 00  haha............</span><br><span class="line">0x100bc3faf: 00 24 00 00 00 00 00 00 00 24 00 00 00 02 00 00  .$.......$......</span><br></pre></td></tr></table></figure>

<p>我们知道’h’的ASCII码是97，对应的16进制就行0x61，’a’是0x68。就是我们的常量’haha’。</p>
<p>这样也就拿到了常量的值。<br>需要注意的是，我们的常量是在编译的时候就已经确定了地址。这里通过当前寄存器的地址为参照，偏移一定的值来获取常量所在的页数。</p>
<p>那继续看一下全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x100bc2140 &lt;+36&gt;: adrp   x9, 3</span><br><span class="line">0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; &#x3D;0x648</span><br></pre></td></tr></table></figure>

<p>我们使用相同的方式，打印一下x9的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; adrp的断点</span><br><span class="line">(lldb) register read x9</span><br><span class="line">x9 &#x3D; 0x0000000100bc5000  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add 的断点</span><br><span class="line">lldb) register read x9</span><br><span class="line">x9 &#x3D; 0x0000000100bc5648  g  &#x2F;&#x2F; 这里拿到的是变量g，而g在内存中的值是0c</span><br><span class="line">(lldb) x 0x0000000100bc5648</span><br><span class="line">0x100bc5648: 0c 00 00 00 0c 00 00 00 38 5e 44 29 02 00 00 00  ........8^D)....</span><br><span class="line">0x100bc5658: f0 33 bc 00 01 00 00 00 d0 4f bc 00 01 00 00 00  .3.......O......</span><br></pre></td></tr></table></figure>

<p>我们可以通过相同的方式获取全局变量的值，g=12。</p>
<p>所以局部变量和全局变量都是通过adrp以当前寄存器的地址为参照来查找address来获取值的。</p>
<h2 id="2-1-汇编还原高级语言"><a href="#2-1-汇编还原高级语言" class="headerlink" title="2.1 汇编还原高级语言"></a>2.1 汇编还原高级语言</h2><p>这里使用一个牛逼的工具Hopper，可以查看对应的方法转化成汇编之后的代码。</p>
<ol>
<li>build成功之后，在我们的工程里有一个’Products’文件，里头有对应的<code>xxx.app</code>。</li>
<li>点击show in finder，找到对应的app，右键显示包内容。</li>
<li>找到与项目同名的黑乎乎的东西（可执行文件），直接拖到Hopper里头就可以了。</li>
</ol>
<p>我们找到对应的方法func</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_func:</span><br><span class="line">000000010000611c         sub        sp, sp, #0x20    ; CODE XREF&#x3D;_main+32</span><br><span class="line">0000000100006120         stp        x29, x30, [sp, #0x10]</span><br><span class="line">0000000100006124         add        x29, sp, #0x10</span><br><span class="line">&#x2F;&#x2F; 这里我们可以知道有两个变量，w0、w1分别存起来</span><br><span class="line">0000000100006128         stur       w0, [x29, #-0x4]</span><br><span class="line">000000010000612c         str        w1, [sp, #0x8]</span><br><span class="line">&#x2F;&#x2F; adrp操作，获取页数</span><br><span class="line">0000000100006130         adrp       x0, #0x100007000 ; argument #1 for method imp___stubs__printf</span><br><span class="line">&#x2F;&#x2F; 这里直接把结果给出来了。haha存放在x0</span><br><span class="line">0000000100006134         add        x0, x0, #0xf9f   ; &quot;haha&quot;</span><br><span class="line">&#x2F;&#x2F; 执行printf</span><br><span class="line">0000000100006138         bl         imp___stubs__printf</span><br><span class="line">&#x2F;&#x2F; 取值，这个位置的值就是w0</span><br><span class="line">000000010000613c         ldur       w8, [x29, #-0x4]</span><br><span class="line">&#x2F;&#x2F; adrp操作，根据页数获取值</span><br><span class="line">0000000100006140         adrp       x9, #0x100009000</span><br><span class="line">&#x2F;&#x2F; 获取变量_g。我们可以通过地址去找对应的值。可以在Hopper中找到对应的值</span><br><span class="line">0000000100006144         add        x9, x9, #0x648   ; _g</span><br><span class="line">&#x2F;&#x2F; 赋值w10 &#x3D; _g </span><br><span class="line">0000000100006148         ldr        w10, x9</span><br><span class="line">&#x2F;&#x2F; 执行加法操作 w8 +&#x3D; w10</span><br><span class="line">000000010000614c         add        w8, w8, w10</span><br><span class="line">&#x2F;&#x2F; 取值。也就是获取第二个参数的值w1</span><br><span class="line">0000000100006150         ldr        w10, [sp, #0x8]</span><br><span class="line">&#x2F;&#x2F; 执行加法操作 w8 +&#x3D; w10</span><br><span class="line">0000000100006154         add        w8, w8, w10</span><br><span class="line">&#x2F;&#x2F; 把w8的值存起来</span><br><span class="line">0000000100006158         str        w8, [sp, #0x4]</span><br><span class="line">&#x2F;&#x2F; 取值w8</span><br><span class="line">000000010000615c         ldr        w8, [sp, #0x4]</span><br><span class="line">&#x2F;&#x2F; 把w8的值给x0（x0存放返回值）</span><br><span class="line">0000000100006160         mov        x0, x8</span><br><span class="line">&#x2F;&#x2F; 释放内存，return</span><br><span class="line">0000000100006164         ldp        x29, x30, [sp, #0x10]</span><br><span class="line">0000000100006168         add        sp, sp, #0x20</span><br><span class="line">000000010000616c         ret</span><br></pre></td></tr></table></figure>

<p>汇编的代码逻辑已经直接表示出来了。最终可以得出一个函数的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int w1, int w2) &#123;</span><br><span class="line">    printf(&quot;haha&quot;);</span><br><span class="line">    return w1 + _g + w2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h1><h2 id="2-1-cmp（Compare）比较指令"><a href="#2-1-cmp（Compare）比较指令" class="headerlink" title="2.1 cmp（Compare）比较指令"></a>2.1 cmp（Compare）比较指令</h2><p>cmp把一个寄存器的内容和另一个寄存器的内容（或立即数）进行比较。但不存储结果，只是更改标志。</p>
<p>一般cmp做完判断后会进行跳转，后面通常会跟上b指令。</p>
<p>cmp比较，其实是一个减法操作，但是不会改变两个比较的值。通过减法的结果去比较。</p>
<ul>
<li>BL 标号：跳转到标号处执行</li>
<li>B.LT 标号：比价结果是<strong>小于（less than）</strong>，执行标号，否则不跳转</li>
<li>B.LE 标号：比较结果是<strong>小于等于（less than or qeual to）</strong>，执行标号，否则不跳转</li>
<li>B.GT  标号：比较结果是<strong>大于（greater than）</strong>，执行标号，否则不跳转</li>
<li>B.GE  标号：比较结果是<strong>大于等于（greater than or equal to）</strong>，执行标号，否则不跳转</li>
<li>B.EQ  标号：比较结果是<strong>等于(equal to)</strong>，执行标号，否则不跳转</li>
<li>B.NE 标号：比较结果是<strong>不等于（not equal to）</strong>，执行标号，否则不跳转</li>
<li>B.LS  标号：比较结果是<strong>无符号小于等于</strong>，执行标号，否则不跳转</li>
<li>B.LO  标号：比较结果是<strong>无符号小于</strong>，执行标号，否则不跳转</li>
<li>B.HI  标号：比较结果是<strong>无符号大于</strong>，执行标号，否则不跳转</li>
<li>B.HS  标号：比较结果是<strong>无符号大于等于</strong>，执行标号，否则不跳转</li>
</ul>
<p>b.gt #0x10000f8d:这个地址是else的跳转地址</p>
<h1 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h1><blockquote>
<p>使用汇编的时候一定是在真机上运行。或者直接选中真机，直接<code>Command+B</code>buid之后，找到对应的可执行文件，直接放在Hopper里就行。</p>
</blockquote>
<h1 id="3-1-do-while"><a href="#3-1-do-while" class="headerlink" title="3.1 do-while"></a>3.1 do-while</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void loopFunc() &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        nsum +&#x3D; 10;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125; while (i &lt; 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下汇编下是什么代码逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FunctionDemo&#96;loopFunc:</span><br><span class="line">-&gt;  0x102c2a764 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 这里是把0放在sp+0xc里头，w：低32位，zr&#x3D;&#x3D;zero</span><br><span class="line">    0x102c2a768 &lt;+4&gt;:  str    wzr, [sp, #0xc]   &#x2F;&#x2F; 假设#0xc存的是a</span><br><span class="line">    0x102c2a76c &lt;+8&gt;:  str    wzr, [sp, #0x8]   &#x2F;&#x2F; 假设#0x8存的是b,之后用的都是w8，会比较乱</span><br><span class="line">    &#x2F;&#x2F; ① 读取a的值</span><br><span class="line">    0x102c2a770 &lt;+12&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    &#x2F;&#x2F; 执行a +&#x3D; 10的操作。</span><br><span class="line">    0x102c2a774 &lt;+16&gt;: add    w8, w8, #0xa              ; &#x3D;0x1 </span><br><span class="line">    &#x2F;&#x2F; 然后把a的值存起来。</span><br><span class="line">    0x102c2a778 &lt;+20&gt;: str    w8, [sp, #0xc]</span><br><span class="line">    &#x2F;&#x2F; 取值b</span><br><span class="line">    0x102c2a77c &lt;+24&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; b +&#x3D; 1</span><br><span class="line">    0x102c2a780 &lt;+28&gt;: add    w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    &#x2F;&#x2F; 把b存起来</span><br><span class="line">    0x102c2a784 &lt;+32&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x102c2a788 &lt;+36&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 比较b的值，b与100比较</span><br><span class="line">    0x102c2a78c &lt;+40&gt;: cmp    w8, #0x64                 ; &#x3D;0x64 </span><br><span class="line">    &#x2F;&#x2F; 如果 lt（小于）if b &lt; 100 跳转到0x102c2a770继续执行。执行①</span><br><span class="line">    0x102c2a790 &lt;+44&gt;: b.lt   0x102c2a770               ; &lt;+12&gt; at main.m:22:14</span><br><span class="line">    0x102c2a794 &lt;+48&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x102c2a798 &lt;+52&gt;: ret</span><br></pre></td></tr></table></figure>

<p>我们直接使用Hopper工具查看汇编，其实比在Xcode中更方便。</p>
<p><img src="do-while.png" alt=""></p>
<h2 id="3-2-while"><a href="#3-2-while" class="headerlink" title="3.2 while"></a>3.2 while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void whileFunc() &#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    while (i &lt; 10) &#123;</span><br><span class="line">        nsum +&#x3D; 10;</span><br><span class="line">        i +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Hopper里查看源码：</p>
<p><img src="while.jpg" alt=""></p>
<p>①处是一个比较，判断w8的值和10的大小，如果<code>b.ge</code>则执行<code>loc_100006128</code>的代码。b.ge是大于等于。<br>②是直接跳转到<code>loc_10000610c</code>的代码。</p>
<h2 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a>3.3 for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void forFunc() &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        nsum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Hopper里查看源码：</p>
<p><img src="for.jpg" alt=""></p>
<p>for循环与while循环区别不大。</p>
<h1 id="4-switch"><a href="#4-switch" class="headerlink" title="4. switch"></a>4. switch</h1><h2 id="4-1-三个case的switch"><a href="#4-1-三个case的switch" class="headerlink" title="4.1 三个case的switch"></a>4.1 三个case的switch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是运行xCode，查看汇编源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;switchFunc:</span><br><span class="line">-&gt;  0x100bea0e8 &lt;+0&gt;:   sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100bea0ec &lt;+4&gt;:   str    w0, [sp, #0xc]</span><br><span class="line">    0x100bea0f0 &lt;+8&gt;:   str    wzr, [sp, #0x8]</span><br><span class="line">    0x100bea0f4 &lt;+12&gt;:  ldr    w8, [sp, #0xc]</span><br><span class="line">    0x100bea0f8 &lt;+16&gt;:  cmp    w8, #0x1                  ; &#x3D;0x1 </span><br><span class="line">    0x100bea0fc &lt;+20&gt;:  str    w8, [sp, #0x4]</span><br><span class="line">    0x100bea100 &lt;+24&gt;:  b.eq   0x100bea128               ; &lt;+64&gt; at main.m:48:18</span><br><span class="line">    0x100bea104 &lt;+28&gt;:  b      0x100bea108               ; &lt;+32&gt; at main.m</span><br><span class="line">    0x100bea108 &lt;+32&gt;:  ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bea10c &lt;+36&gt;:  cmp    w8, #0x2                  ; &#x3D;0x2 </span><br><span class="line">    0x100bea110 &lt;+40&gt;:  b.eq   0x100bea138               ; &lt;+80&gt; at main.m:51:18</span><br><span class="line">    0x100bea114 &lt;+44&gt;:  b      0x100bea118               ; &lt;+48&gt; at main.m</span><br><span class="line">    0x100bea118 &lt;+48&gt;:  ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bea11c &lt;+52&gt;:  cmp    w8, #0x3                  ; &#x3D;0x3 </span><br><span class="line">    0x100bea120 &lt;+56&gt;:  b.eq   0x100bea148               ; &lt;+96&gt; at main.m:54:18</span><br><span class="line">    0x100bea124 &lt;+60&gt;:  b      0x100bea158               ; &lt;+112&gt; at main.m:60:18</span><br><span class="line">    0x100bea128 &lt;+64&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea12c &lt;+68&gt;:  add    w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    0x100bea130 &lt;+72&gt;:  str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea134 &lt;+76&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea138 &lt;+80&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea13c &lt;+84&gt;:  add    w8, w8, #0xa              ; &#x3D;0xa </span><br><span class="line">    0x100bea140 &lt;+88&gt;:  str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea144 &lt;+92&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea148 &lt;+96&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea14c &lt;+100&gt;: add    w8, w8, #0x14             ; &#x3D;0x14 </span><br><span class="line">    0x100bea150 &lt;+104&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea154 &lt;+108&gt;: b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea158 &lt;+112&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea15c &lt;+116&gt;: subs   w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    0x100bea160 &lt;+120&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea164 &lt;+124&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100bea168 &lt;+128&gt;: ret</span><br></pre></td></tr></table></figure>

<p>看汇编源码，其实就是简单的if-else比较，只不过这里换成了b.eq(等于)，然后跳转到对应的代码块。</p>
<h2 id="4-2-4个case的switch"><a href="#4-2-4个case的switch" class="headerlink" title="4.2 4个case的switch"></a>4.2 4个case的switch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    switchFunc(4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们改变一下代码，再加一个case，运行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;switchFunc:</span><br><span class="line">    0x1005460ac &lt;+0&gt;:   sub    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x1005460b0 &lt;+4&gt;:   stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x1005460b4 &lt;+8&gt;:   add    x29, sp, #0x10            ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. 把w0的值存起来，w0 &#x3D; 4</span><br><span class="line">    0x1005460b8 &lt;+12&gt;:  stur   w0, [x29, #-0x4]</span><br><span class="line">    &#x2F;&#x2F; 2. 把0存起来</span><br><span class="line">    0x1005460bc &lt;+16&gt;:  str    wzr, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 3. 取值w8 &#x3D; 4</span><br><span class="line">    0x1005460c0 &lt;+20&gt;:  ldur   w8, [x29, #-0x4]</span><br><span class="line">    &#x2F;&#x2F; 4. 这里是第一个case 1. w8 &#x3D; w8 - 1 &#x3D; 3</span><br><span class="line">    0x1005460c4 &lt;+24&gt;:  subs   w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    &#x2F;&#x2F; 5. 把x8的值给x9，x9 &#x3D; 0x0000000000000003</span><br><span class="line">    0x1005460c8 &lt;+28&gt;:  mov    x9, x8</span><br><span class="line">    &#x2F;&#x2F; 6. 这个ubfx语法，往下翻有详细解释。把x9的高32位清零，x9 &#x3D; 0x0000000000000003</span><br><span class="line">    0x1005460cc &lt;+32&gt;:  ubfx   x9, x9, #0, #32</span><br><span class="line">    &#x2F;&#x2F; 7. x9的值和3进行比较</span><br><span class="line">    0x1005460d0 &lt;+36&gt;:  cmp    x9, #0x3                  ; &#x3D;0x3 </span><br><span class="line">    &#x2F;&#x2F; 8. 把x9的值放在sp对应的内存地址中</span><br><span class="line">    0x1005460d4 &lt;+40&gt;:  str    x9, [sp]</span><br><span class="line">    &#x2F;&#x2F; 9. 如果7中比较的结果是一个【无符号大于】，则执行0x100546134，其实就是执行了default操作</span><br><span class="line">-&gt;  0x1005460d8 &lt;+44&gt;:  b.hi   0x100546134               ; &lt;+136&gt; at main.m</span><br><span class="line">    &#x2F;&#x2F; 10. adrp:地址操作，x8&#x3D;0x100546000，左边的地址标号后12位清零，然后加上0x0000</span><br><span class="line">    0x1005460dc &lt;+48&gt;:  adrp   x8, 0</span><br><span class="line">    &#x2F;&#x2F; 11. x8 &#x3D; 0x10054614c，然后通过view memory，看里头的值。</span><br><span class="line">    0x1005460e0 &lt;+52&gt;:  add    x8, x8, #0x14c            ; &#x3D;0x14c </span><br><span class="line">    &#x2F;&#x2F; 12. 取值x11 &#x3D; 3</span><br><span class="line">    0x1005460e4 &lt;+56&gt;:  ldr    x11, [sp]</span><br><span class="line">    &#x2F;&#x2F; 13. ldrsw：取值，先计算中括号内部x11, lsl #2:意思是x11左移2位，</span><br><span class="line">    &#x2F;&#x2F;     然后加上x8获取一个地址，把地址里的值给x10</span><br><span class="line">    &#x2F;&#x2F; 3&lt;&lt;2 &#x3D; 二进制数3：11&lt;&lt;2 &#x3D; 1100，也就是十进制12，</span><br><span class="line">    &#x2F;&#x2F; x8+12 &#x3D; 0x10054614c+0xc &#x3D; 0x100546158</span><br><span class="line">    &#x2F;&#x2F; 这是一个寻址操作，把0x100546158地址的值给x10，</span><br><span class="line">    &#x2F;&#x2F; 通过view memory查看x10 &#x3D; 0xffffffd8 &#x3D; -40,是一个负值</span><br><span class="line">    0x1005460e8 &lt;+60&gt;:  ldrsw  x10, [x8, x11, lsl #2]</span><br><span class="line">    &#x2F;&#x2F; x9 &#x3D; 0x10054614c + (-40) &#x3D; 0x100546124</span><br><span class="line">    0x1005460ec &lt;+64&gt;:  add    x9, x8, x10</span><br><span class="line">    &#x2F;&#x2F; 执行跳转到 0x100546124</span><br><span class="line">    0x1005460f0 &lt;+68&gt;:  br     x9</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从这里开始就是case的位置了。</span><br><span class="line">    0x1005460f4 &lt;+72&gt;:  adrp   x0, 1</span><br><span class="line">    0x1005460f8 &lt;+76&gt;:  add    x0, x0, #0xf8c            ; &#x3D;0xf8c </span><br><span class="line">    0x1005460fc &lt;+80&gt;:  bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546100 &lt;+84&gt;:  b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546104 &lt;+88&gt;:  adrp   x0, 1</span><br><span class="line">    0x100546108 &lt;+92&gt;:  add    x0, x0, #0xf8e            ; &#x3D;0xf8e </span><br><span class="line">    0x10054610c &lt;+96&gt;:  bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546110 &lt;+100&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546114 &lt;+104&gt;: adrp   x0, 1</span><br><span class="line">    0x100546118 &lt;+108&gt;: add    x0, x0, #0xf90            ; &#x3D;0xf90 </span><br><span class="line">    0x10054611c &lt;+112&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546120 &lt;+116&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    &#x2F;&#x2F; 直接跳转到这里，执行adrp操作，获取x0</span><br><span class="line">    0x100546124 &lt;+120&gt;: adrp   x0, 1</span><br><span class="line">    0x100546128 &lt;+124&gt;: add    x0, x0, #0xf92            ; &#x3D;0xf92 </span><br><span class="line">    &#x2F;&#x2F; 执行printf操作。</span><br><span class="line">    0x10054612c &lt;+128&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546130 &lt;+132&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546134 &lt;+136&gt;: adrp   x0, 1</span><br><span class="line">    0x100546138 &lt;+140&gt;: add    x0, x0, #0xf94            ; &#x3D;0xf94 </span><br><span class="line">    0x10054613c &lt;+144&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546140 &lt;+148&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100546144 &lt;+152&gt;: add    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x100546148 &lt;+156&gt;: ret</span><br></pre></td></tr></table></figure>

<p>发现不一样了啊，不是if-else判断了。</p>
<p>0x10092e0e0 &lt;+24&gt;:  ubfx   x9, x9, #0, #32<br>x9寄存器是64位，w8是32位，相当于x9的低32位。<br>这里的目的就是x9从0位开始到32位清零，也就x9的高32位清零然后赋值给x9</p>
<p><code>b.hi</code> 无符号大于</p>
<p><code>br x9</code>：b是跳转，br是不影响lr寄存器的跳转。直接跳到x9（x9是一个地址标号）</p>
<p><code>ldrsw  x10, [x8, x11, lsl #2]</code>： 这里先计算中括号内部。而在中括号内部先计算x11。</p>
<ol>
<li>lsl表示左移，<code>x11, lsl #2</code>表示x11左移2位。</li>
<li>加上x8的值。生成一个新的地址。</li>
<li>[]表示寻址，也就是说把生成的地址中的值给x10。</li>
</ol>
<p>看一下我们获取参数是否正确。看一下view memory</p>
<p><img src="switch-viewmemory.jpg" alt=""></p>
<p>偏移表中为什么存储的是地址的偏移量？为什么不直接存对应的地址？</p>
<blockquote>
<p>是因为地址只有在运行的时候才会开辟的，每次运行的值都不一样，所以直接存偏移量，然后通过偏移表的起始位置进行计算就可以直接定位了。</p>
</blockquote>
<h3 id="4-2-1-switch-case-偏移表"><a href="#4-2-1-switch-case-偏移表" class="headerlink" title="4.2.1 switch case 偏移表"></a>4.2.1 switch case 偏移表</h3><p>我们看第11. x8 = 0x10054614c，这个地址正好是当前汇编函数的末尾0x100546148+0x4。所以，这个函数栈空间后有一堆数据，存放一些值，这一堆数据就是case创建的偏移表。而这些值就是我们要偏移的值。</p>
<p>偏移表中的个数是由 (case的最大值 - case的最小值) + 1。看一下上面的图<code>0x10054614c</code>的位置存放的4个值，分别是0xffffffa8=-88, 0xffffffb8=-72, 0xffffffc8=-56, 0xffffffd8=-40</p>
<p>偏移值是一个负数，是因为是以<code>x8 = 0x10054614c</code>寄存器中存的地址为基数，偏移一个负数得到一个地址，这个地址就是在函数开辟的栈空间内。</p>
<p>我们通过一张图重新看一下这个过程：</p>
<p><img src="switch-2.jpg" alt=""></p>
<h2 id="4-3-4个不连续case的switch"><a href="#4-3-4个不连续case的switch" class="headerlink" title="4.3 4个不连续case的switch"></a>4.3 4个不连续case的switch</h2><p>我们知道了，3个连续的case是if-else比较，4个连续的case就不是if-else了，而是会生成一个表。那么4个不连续的case呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 200:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 30:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不在放汇编源码了，4个不连续的case，与3个case一样，也是通过if-else比较来执行代码块的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。</li>
<li>各个case分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。</li>
<li>在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/13/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/13/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-2/" class="post-title-link" itemprop="url">ARM汇编-2 函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-13 21:52:51" itemprop="dateCreated datePublished" datetime="2021-04-13T21:52:51+08:00">2021-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-关于CPU的补充"><a href="#1-关于CPU的补充" class="headerlink" title="1. 关于CPU的补充"></a>1. 关于CPU的补充</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h2><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<blockquote>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
</blockquote>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<h2 id="1-2-高速缓存"><a href="#1-2-高速缓存" class="headerlink" title="1.2 高速缓存"></a>1.2 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<blockquote>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
</blockquote>
<h2 id="1-3-寄存器"><a href="#1-3-寄存器" class="headerlink" title="1.3 寄存器"></a>1.3 寄存器</h2><h3 id="1-3-1-数据地址寄存器"><a href="#1-3-1-数据地址寄存器" class="headerlink" title="1.3.1 数据地址寄存器"></a>1.3.1 数据地址寄存器</h3><p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br>ARM64中：</p>
<ul>
<li>64位 x0-x30，XZR（零寄存器）</li>
<li>32位 w0-w30，WZR（零寄存器）</li>
</ul>
<h3 id="1-3-2-浮点和向量寄存器"><a href="#1-3-2-浮点和向量寄存器" class="headerlink" title="1.3.2. 浮点和向量寄存器"></a>1.3.2. 浮点和向量寄存器</h3><p>因为浮点数的存储以及其运算的特殊性，CPU中专门提供浮点数寄存器来处理浮点数。</p>
<ul>
<li>64位: d0-d31 </li>
<li>32位: d0-d31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<p>向量寄存器 128位:V0-V31</p>
<h3 id="1-3-3-SP、FP寄存器"><a href="#1-3-3-SP、FP寄存器" class="headerlink" title="1.3.3 SP、FP寄存器"></a>1.3.3 SP、FP寄存器</h3><p>说这两个，需要先说一下栈。</p>
<p><img src="stack.jpg" alt=""></p>
<p>栈是一种具有特殊的访问方式的存储空间，先进后处，后进先出。（Last In Out First）</p>
<ul>
<li>sp寄存器在任意时刻会保存栈顶的地址。</li>
<li>fp寄存器也成为x29寄存器。属于通用寄存器，在默写时刻我们利用它保存栈底的地址。</li>
</ul>
<blockquote>
<p>需要注意的是，ARM64里面对栈的操作是16个字节对齐的。</p>
</blockquote>
<p><img src="stack_1.jpg" alt=""></p>
<p>这个图很好的说明了栈是从高地址往低地址开始读写操作的，堆是从低地址向高地址开始的，当栈不断的开辟空间，堆也不断的开辟空间，导致两个区域重叠，就会导致崩溃。也就是常说的堆栈溢出。（堆、栈上的空间是不固定的）</p>
<p>这里我们说个题外话，是不是所有的死循环都会导致崩溃？答案是否定的，只有不断的开辟空间的死循环才会导致崩溃，上一章我们最后的例子就是很好的说明，因为没有开辟空间。</p>
<h1 id="2-函数调用栈"><a href="#2-函数调用栈" class="headerlink" title="2. 函数调用栈"></a>2. 函数调用栈</h1><p>以下代码是常见的函数调用开辟和恢复栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, sp, #0x40             ; 拉伸0x40（64字节）空间</span><br><span class="line">stp    x29, x30, [sp, #0x30]     ; x29, x30 寄存器入栈保护</span><br><span class="line">add    x29, sp, #0x30            ; x29指向栈帧的底部</span><br><span class="line">... </span><br><span class="line">ldp    x29, x30, [sp, #0x30]     ; 恢复x29&#x2F;x30 寄存器的值</span><br><span class="line">add    sp, sp, #0x40             ; 栈平衡</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是： 读、写数据都是往高地址读、写。</p>
</blockquote>
<h2 id="2-1-内存读写指令"><a href="#2-1-内存读写指令" class="headerlink" title="2.1 内存读写指令"></a>2.1 内存读写指令</h2><ul>
<li>str指令：store register，将数据从寄存器中读出来，存在内存中。每次操作8个字节</li>
<li>ldr指令：load register，将数据从内存中读出来，存在寄存器中。每次操作8个字节</li>
<li>stp指令：str指令的变种，每次操作16个字节。</li>
<li>ldp指令：ldr指令的变种，每次操作16个字节。</li>
</ul>
<h2 id="2-2-堆栈操作"><a href="#2-2-堆栈操作" class="headerlink" title="2.2 堆栈操作"></a>2.2 堆栈操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_ABTest:</span><br><span class="line">    sub sp, sp, #0x20       ; 开辟栈空间，在当前sp所在的位置减去32个字节。</span><br><span class="line">    stp x0, x1, [sp, #0x10] ; 之所以用[],是因为sp存的是一个地址,这里的操作是寻址，把x0，x1的值放在对应的位置，但是栈的读写都是在高位，所以这里还需要加上一个值，写在高位</span><br><span class="line">    ldp x1, x0, [sp, #0x10] ; 这里是交换x0，x1的值。注意，当前的操作不会改变sp的值，寄存器中的值进行交换</span><br><span class="line">    add sp, sp, #0x20       ; 这里恢复栈空间。</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li>我们将上面的代码放在“.s”文件中，在ViewControler中声明<code>int ABTest();</code>方法.</li>
<li>在viewDidLoad中调用<code>ABTest();</code>，并在这一行打上断点。运行触发断点之后，按住ctrl键的同时点击小箭头，进入汇编，（按住ctrl是为了不让程序执行下一步）</li>
<li>在右下命令行中输入<code>register read sp</code>查看当前sp所在的位置，是<code>sp = 0x000000016fbf1290</code></li>
<li>点击下一步，开辟栈空间，重复第3步的操作，查看<code>sp = 0x000000016fbf1270</code></li>
<li>进入View Memory，定位到sp所在的位置，查看在<code>0x000000016fbf1280</code>位置的值是什么。</li>
<li>这个时候，分别执行<code>register write x0 0x0a</code>， <code>register write x1 0x0b</code>，修改x0，x1的值，执行下一步。</li>
<li>发现在左边通用寄存器中x0，x1的值已经发生变化。这时候重复第5步操作。查看是否已经发生变化。（需要切换页）</li>
<li>执行下一步，交换x0，x1的值。我们发现左边，通用寄存器中x0，x1的值已经发生了变化，这时候重复第5步，查看内存中的值是否有变化？是没有发生变化的哈~</li>
<li>销毁当前栈空间。重复第3步，查看当前sp的地址。是<code>sp = 0x000000016fbf1290</code></li>
</ol>
<p>如图：</p>
<p><img src="ABTest.jpg" alt=""></p>
<h1 id="3-bl和ret指令"><a href="#3-bl和ret指令" class="headerlink" title="3. bl和ret指令"></a>3. bl和ret指令</h1><h2 id="3-1-bl"><a href="#3-1-bl" class="headerlink" title="3.1 bl"></a>3.1 bl</h2><p>bl其实存在两个操作：</p>
<ol>
<li>将下一条指令的地址放入lr（x30）寄存器。也就是保存回家的路。</li>
<li>转到对应的跳转中执行指令，当指令执行完成后，会根据lr中的地址，返回继续执行。</li>
</ol>
<p>通俗的讲就是离家出走了，执行ret的时候，根据lr中的地址，找到回家的路。</p>
<h2 id="3-2-ret"><a href="#3-2-ret" class="headerlink" title="3.2 ret"></a>3.2 ret</h2><p>默认使用lr（x30）寄存器的值，通过底层指令提示CPU此处作为下条指令地址。这是ARM64平台的特色指令，它面向硬件方面做了优化处理。</p>
<h2 id="3-3-x30寄存器（lr寄存器）"><a href="#3-3-x30寄存器（lr寄存器）" class="headerlink" title="3.3 x30寄存器（lr寄存器）"></a>3.3 x30寄存器（lr寄存器）</h2><p>x30寄存器存放的是函数的返回地址，当ret指令执行时，会寻找x30寄存器保存的地址值。</p>
<p>这也就是，为啥上一章，最后的代码会造成循环引用的原因，因为x30寄存器的地址指向的就是当前bl的下一行代码。</p>
<h2 id="3-4-操作"><a href="#3-4-操作" class="headerlink" title="3.4 操作"></a>3.4 操作</h2><p>我们简写一下上一章的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在ViewDidLoad中执行A()，并打断点。执行上面的代码。按住ctrl键点击小剪头，进入A的汇编。查看当前lr寄存器中存放的地址是谁。然后按照下图所示进行操作，进入ViewDidLoad的汇编。</p>
<p> <img src="viewdidload.jpg" alt=""></p>
</li>
<li><p>我们看到了19行执行了 bl A的操作，也就是在ViewDidLoad中执行A()操作。而lr寄存器所存储的地址就是第20行所在的位置，也就是存储了执行A之后返回ViewDidLoad的地址。0x1003ce56c</p>
</li>
<li><p>点击继续执行，修改x0寄存器的值，继续下一步。执行bl B</p>
</li>
<li><p>这时候我们发现lr寄存器中存储的值已经被修改了，变成了A汇编代码中bl B下一行的地址。<code>lr = 0x1003ce904</code>，这里修改了x0的值。</p>
</li>
<li><p>下一步。继续执行B中的ret操作，发现回到了A，回到了<code>0x1003ce904</code>，继续执行发现修改了x0的值。</p>
</li>
<li><p>下一步，执行ret，发现又回到了A中的<code>0x1003ce904</code>，不断的执行，发现压根回不去ViewDidLoad了。</p>
</li>
</ol>
<p>这就是上一章中说的问题，lr寄存器的值被修改了，导致回不去了。那我们应该怎么处理呢？</p>
<p>最合理的方案是在执行bl操作之前，将bl的下一行地址存放在栈中。如果将值存放在其他寄存器中是绝对不安全的，因为你不知道什么时候就会被系统覆盖。</p>
<h3 id="3-4-1-解决死循环"><a href="#3-4-1-解决死循环" class="headerlink" title="3.4.1 解决死循环"></a>3.4.1 解决死循环</h3><p>我们为了解决上面的问题，我们查看系统是怎么处理这个问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void c() &#123;</span><br><span class="line">    d();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void d() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，在ViewDidLoad中执行<code>c()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;c:</span><br><span class="line">-&gt;  0x1005464e0 &lt;+0&gt;:  stp    x29, x30, [sp, #-0x10]!</span><br><span class="line">    0x1005464e4 &lt;+4&gt;:  mov    x29, sp</span><br><span class="line">    0x1005464e8 &lt;+8&gt;:  bl     0x1005464f4               ; d at ViewController.m:38:1</span><br><span class="line">    0x1005464ec &lt;+12&gt;: ldp    x29, x30, [sp], #0x10</span><br><span class="line">    0x1005464f0 &lt;+16&gt;: ret</span><br></pre></td></tr></table></figure>
<p>在c的汇编里头，我们仔细看下系统是什么处理lr寄存器的。<br>我们看到了x29和x30两个寄存器。x29是fp寄存器，指向栈底；x30寄存器就是lr寄存器。</p>
<ol>
<li><code>stp x29, x30, [sp, #-0x10]!</code> 这是汇编代码简写的形式的。这句话的意思是sp -= 0x10开辟空间，把x29和x30寄存器的值存放在开辟的空间里。“!”的操作是针对sp的，“[]”的操作是针对x29，x30寻址的。需要注意的是，先存值，在改变sp。</li>
<li><code>mov x29, sp</code> 将sp的值赋给x29寄存器。啥意思，fp跟sp指向相同的位置。栈顶栈底指向同一位置，啥情况？之后说哈~</li>
<li>bl操作，执行d()</li>
<li><code>ldp x29, x30, [sp], #0x10</code> 跟第一句差不多，“[]”就是寻址，将sp对应的两个地址的值赋值给x29，x30。第一步是存，这一步是取。然后执行 sp += 0x10的操作，释放栈空间。</li>
<li>执行ret操作，我们就能轻松的回到ViewDidLoad了。因为lr寄存器中的地址正是我们一开始存的值。</li>
</ol>
<p>在执行的过程中，我们一步步查看lr寄存器的值看是怎么变化的。就能清晰明了了。</p>
<p>这个时候，我们就可以修改上面的代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    str x30, [sp, #-0x10]!  ;仿造系统方法，因为x29寄存器暂时没有用处，所以只使用x30。</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    ldr x30, [sp], #0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>执行该代码，我们按照栈操作3.4的流程，查看整体流程，看x30寄存器存放读取的过程，配合View Memory使用会更爽哈~</p>
<p>这里把代码做一下修改，在A中<code>str x30, [sp, #-0x8]!</code>将16个字节改成8个字节会怎样？跑一遍试试看</p>
<p>会发生crash对不对。<b>因为在ARM64里面，对栈的操作是16个字节对齐的。所以开辟空间操作一定是16字节的倍数来进行的。</b></p>
<h1 id="4-函数的参数和返回值"><a href="#4-函数的参数和返回值" class="headerlink" title="4. 函数的参数和返回值"></a>4. 函数的参数和返回值</h1><p>ARM64下，函数的参数是存放在x0-x7(32位w0-w7)这个8个寄存器里面的。如果超过8个参数，就会入栈。<br>函数的返回值是放在x0(32位是w0)寄存器里的。</p>
<p>这里有一个点，在OC中，一般情况下，定义函数最多可以有几个参数？这里有一个小坑哈~<br>在runtime里，我们知道，函数调用都是通过objc_msgsend来处理的，而这里个里头已经存在了两个默认参数，一个是self，一个obj</p>
<p>当我们不知道怎么处理带参数的函数时，就看系统是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 我们定义一个函数，在viewDidLoad中执行。</span><br><span class="line">int sumA(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，按住control点击进汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">首先我们来到viewDidLoad中，</span><br><span class="line">&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    ; 这里我们有看到赋值，sumA(10+20)，我们看到w0&#x3D;10，w1&#x3D;20</span><br><span class="line">    0x104d125d4 &lt;+68&gt;: mov    w0, #0xa          </span><br><span class="line">    0x104d125d8 &lt;+72&gt;: mov    w1, #0x14</span><br><span class="line">-&gt;  0x104d125dc &lt;+76&gt;: bl     0x104d12570               ; sumA at ViewController.m:16  ; 这里有bl指令，继续执行跳转到sumA操作。</span><br><span class="line">    0x104d125e0 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x104d125e4 &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30 </span><br><span class="line">    0x104d125e8 &lt;+88&gt;: ret    </span><br><span class="line">    </span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">FunctionDemo&#96;sumA:</span><br><span class="line">-&gt;  0x100d3a4dc &lt;+0&gt;:  sub    sp, sp, #0x10     ; 开辟16个字节的空间</span><br><span class="line">    0x100d3a4e0 &lt;+4&gt;:  str    w0, [sp, #0xc]    ; 寻址把w0存放在sp+0xC的位置</span><br><span class="line">    0x100d3a4e4 &lt;+8&gt;:  str    w1, [sp, #0x8]    ; 寻址把w1存放在sp+0x8的位置</span><br><span class="line">    0x100d3a4e8 &lt;+12&gt;: ldr    w8, [sp, #0xc]    ; 把sp+0xC位置的值给w8</span><br><span class="line">    0x100d3a4ec &lt;+16&gt;: ldr    w9, [sp, #0x8]    ; 把sp+0x8位置的值给w9</span><br><span class="line">    0x100d3a4f0 &lt;+20&gt;: add    w0, w8, w9        ; 执行加法操作，并赋值给w0</span><br><span class="line">    0x100d3a4f4 &lt;+24&gt;: add    sp, sp, #0x10     ; 释放栈空间</span><br><span class="line">    0x100d3a4f8 &lt;+28&gt;: ret                      ; ret</span><br></pre></td></tr></table></figure>

<p>通过上面汇编之后的代码，我们可以看到整个的流程，相当于生成了两个临时量变去存储传进来的值，然后把返回值存储在w0寄存器里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 我们定义一个函数，在viewDidLoad中执行。</span><br><span class="line">int sumA(int a, int b) &#123;</span><br><span class="line">    int a1 &#x3D; 1;     &#x2F;&#x2F; 生成局部变量a1，b1</span><br><span class="line">    int b1 &#x3D; b;</span><br><span class="line">    return a1 + b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面系统的实现方案，我们就可以自己写一个带有参数，返回值的方法。在“.s”文件中实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global _sumB</span><br><span class="line"></span><br><span class="line">_sumB:</span><br><span class="line">    add x0, x0, x1</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h2 id="4-2-验证超过8个参数的情况"><a href="#4-2-验证超过8个参数的情况" class="headerlink" title="4.2 验证超过8个参数的情况"></a>4.2 验证超过8个参数的情况</h2><p>多余的参数会存放在调用方法所在的栈空间里，然后在调用的方法里去取别人的栈中存放的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，我们看汇编之后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#96;-[ViewController viewDidLoad]:</span><br><span class="line">...</span><br><span class="line">... 这中间省略了一大部分代码，我们直接从这里看</span><br><span class="line">    ; 这里打印 sp &#x3D; 0x000000016f4c53c0</span><br><span class="line">    0x10093e594 &lt;+64&gt;:  bl     0x10093e9b4               ; symbol stub for: objc_msgSendSuper2  </span><br><span class="line">    ; 这个是调用super viewDidLoad</span><br><span class="line">    0x10093e598 &lt;+68&gt;:  mov    w0, #0x1     ; 将1存到w0寄存器中</span><br><span class="line">    0x10093e59c &lt;+72&gt;:  mov    w1, #0x2</span><br><span class="line">    0x10093e5a0 &lt;+76&gt;:  mov    w2, #0x3</span><br><span class="line">    0x10093e5a4 &lt;+80&gt;:  mov    w3, #0x4</span><br><span class="line">    0x10093e5a8 &lt;+84&gt;:  mov    w4, #0x5</span><br><span class="line">    0x10093e5ac &lt;+88&gt;:  mov    w5, #0x6</span><br><span class="line">    0x10093e5b0 &lt;+92&gt;:  mov    w6, #0x7     ; 这些值我们是可以在通用寄存器里看到的</span><br><span class="line">    0x10093e5b4 &lt;+96&gt;:  mov    w7, #0x8     ; 将8存到w7寄存器中</span><br><span class="line">    ; x8 &#x3D; 0x0000000100940ce8  &quot;viewDidLoad&quot;</span><br><span class="line">    0x10093e5b8 &lt;+100&gt;: mov    x8, sp       ; 这里是把sp栈顶的位置放在x8寄存器中。</span><br><span class="line">    ; x8 &#x3D; 0x000000016f4c53c0</span><br><span class="line">    0x10093e5bc &lt;+104&gt;: mov    w10, #0x9    ; 把9放在w10寄存器</span><br><span class="line">    0x10093e5c0 &lt;+108&gt;: str    w10, [x8]    ; 把w10寄存器中的值，放在x8寄存器所在的地址里</span><br><span class="line">    ; 也就是在sp的位置，存放了9这个变量。</span><br><span class="line">-&gt;  0x10093e5c4 &lt;+112&gt;: bl     0x10093e4dc               ; sumA at ViewController.m:16      ; 这里执行 sumA</span><br><span class="line">    0x10093e5c8 &lt;+116&gt;: ldp    x29, x30, [sp, #0x30]    ; x29,x30取值，是为了函数返回</span><br><span class="line">    0x10093e5cc &lt;+120&gt;: add    sp, sp, #0x40             ; &#x3D;0x40 ; 释放栈空间</span><br><span class="line">    0x10093e5d0 &lt;+124&gt;: ret</span><br></pre></td></tr></table></figure>

<p>接下来，我们看test的汇编代码情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#96;test:</span><br><span class="line">    ; 开辟空间之前 sp &#x3D; 0x000000016f4c53c0</span><br><span class="line">-&gt;  0x10093e4dc &lt;+0&gt;:   sub    sp, sp, #0x30 ; &#x3D;0x30</span><br><span class="line">    ; 开辟栈空间后，sp&#x3D;0x000000016f4c5390</span><br><span class="line">    0x10093e4e0 &lt;+4&gt;:   ldr    w8, [sp, #0x30]  ; 这是从sp+0x30的位置取值，放在w8寄存器里。</span><br><span class="line">    ; sp+0x30就是开辟当前栈空间之前的位置，也就是viewDidLoad开辟空间的栈顶位置，这个位置是x8寄存器指向的位置，存放的是变量9</span><br><span class="line">    0x10093e4e4 &lt;+8&gt;:   str    w0, [sp, #0x2c]  ; 把w0寄存器的值存放在栈sp+0x2c里头，也就是sp偏移4个字节，正好存放一个int类型的数据。</span><br><span class="line">    0x10093e4e8 &lt;+12&gt;:  str    w1, [sp, #0x28]</span><br><span class="line">    0x10093e4ec &lt;+16&gt;:  str    w2, [sp, #0x24]</span><br><span class="line">    0x10093e4f0 &lt;+20&gt;:  str    w3, [sp, #0x20]</span><br><span class="line">    0x10093e4f4 &lt;+24&gt;:  str    w4, [sp, #0x1c]</span><br><span class="line">    0x10093e4f8 &lt;+28&gt;:  str    w5, [sp, #0x18]</span><br><span class="line">    0x10093e4fc &lt;+32&gt;:  str    w6, [sp, #0x14]</span><br><span class="line">    0x10093e500 &lt;+36&gt;:  str    w7, [sp, #0x10]</span><br><span class="line">    0x10093e504 &lt;+40&gt;:  str    w8, [sp, #0xc]   ; w8寄存器的值放在sp+0xc里，w8&#x3D;9</span><br><span class="line">    0x10093e508 &lt;+44&gt;:  ldr    w8, [sp, #0x2c]  ; 赋值操作 w8&#x3D;1</span><br><span class="line">    0x10093e50c &lt;+48&gt;:  ldr    w9, [sp, #0x28]  ; w9 &#x3D; 2</span><br><span class="line">    0x10093e510 &lt;+52&gt;:  add    w8, w8, w9       ; w8 &#x3D; w8+w9 &#x3D; 1+2 &#x3D; 3</span><br><span class="line">    0x10093e514 &lt;+56&gt;:  ldr    w9, [sp, #0x24]  ; w9 &#x3D; 3</span><br><span class="line">    0x10093e518 &lt;+60&gt;:  add    w8, w8, w9       ; w8 +&#x3D; w9 &#x3D; 3 + 3</span><br><span class="line">    0x10093e51c &lt;+64&gt;:  ldr    w9, [sp, #0x20]</span><br><span class="line">    0x10093e520 &lt;+68&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e524 &lt;+72&gt;:  ldr    w9, [sp, #0x1c]</span><br><span class="line">    0x10093e528 &lt;+76&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e52c &lt;+80&gt;:  ldr    w9, [sp, #0x18]</span><br><span class="line">    0x10093e530 &lt;+84&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e534 &lt;+88&gt;:  ldr    w9, [sp, #0x14]</span><br><span class="line">    0x10093e538 &lt;+92&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e53c &lt;+96&gt;:  ldr    w9, [sp, #0x10]</span><br><span class="line">    0x10093e540 &lt;+100&gt;: add    w8, w8, w9</span><br><span class="line">    0x10093e544 &lt;+104&gt;: ldr    w9, [sp, #0xc]</span><br><span class="line">    0x10093e548 &lt;+108&gt;: add    w0, w8, w9       ; 计算完成</span><br><span class="line">    0x10093e54c &lt;+112&gt;: add    sp, sp, #0x30    ; &#x3D;0x30 ，释放栈空间</span><br><span class="line">    0x10093e550 &lt;+116&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这里会把9这个参数存放在<code>viewDidLoad</code>所开辟的栈空间里。执行test后，1-8会存放在<code>test</code>函数所开辟的空间中，然后把9这个参数从<code>viewDidLoad</code>所开辟的栈空间里拿回来，是通过x8寄存器来定位地址获取9这个参数的。相当于从别人家借东西，会存在sp计算的问题，会影响效率。</p>
<p>我们一定要知道的一点是，栈的读写都是从高位往低位进行读写，栈空间的读写都是基于上述原则进行操作的。<br>以上操作，配合View Memory查看内存中的数据会更清晰。</p>
<h3 id="4-2-1-release下操作"><a href="#4-2-1-release下操作" class="headerlink" title="4.2.1 release下操作"></a>4.2.1 release下操作</h3><p>我们的这一系列操作都是在debug模式下进行的，加法的计算产生的汇编代码竟然是如此繁杂。如果我们切换到release下运行，会有什么情况发生？</p>
<p>在release下，编译器会进行优化，我们的test方法，只是做了调用，没有任何实际意义，所以在release下根本不会有bl指令。</p>
<p>如果我们执行<code>printf(&quot;%d&quot;, sumA(1,2,3,4,5,6,7,8,9));</code>呢？</p>
<p>其实差别不大，经过系统优化之后，就只剩下<code>mov    w8, #0x2d</code>这一句代码了，0x2d = 45。就是这么简单直接。</p>
<h2 id="4-3-验证返回值"><a href="#4-3-验证返回值" class="headerlink" title="4.3 验证返回值"></a>4.3 验证返回值</h2><p>如果返回值超过8个字节，x0寄存器存不下的时候，会通过栈空间来返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;</span><br><span class="line">    struct NumA num;</span><br><span class="line">    num.a &#x3D; a;</span><br><span class="line">    num.b &#x3D; b;</span><br><span class="line">    num.c &#x3D; c;</span><br><span class="line">    num.d &#x3D; d;</span><br><span class="line">    num.e &#x3D; e;</span><br><span class="line">    num.f &#x3D; f;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    struct NumA num &#x3D; getStructA(1,2,3,4,5,6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里呢，我们返回一个结构体，正常来说，结构体的大小是根据结构体中的变量决定的。这里有6个int类型的变量也就是24个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#96;getStructA:</span><br><span class="line">-&gt;  0x1025424a0 &lt;+0&gt;:  sub    sp, sp, #0x20    ; &#x3D;0x20 开辟栈空间</span><br><span class="line">    0x1025424a4 &lt;+4&gt;:  str    w0, [sp, #0x1c]</span><br><span class="line">    0x1025424a8 &lt;+8&gt;:  str    w1, [sp, #0x18]</span><br><span class="line">    0x1025424ac &lt;+12&gt;: str    w2, [sp, #0x14]</span><br><span class="line">    0x1025424b0 &lt;+16&gt;: str    w3, [sp, #0x10]</span><br><span class="line">    0x1025424b4 &lt;+20&gt;: str    w4, [sp, #0xc]</span><br><span class="line">    0x1025424b8 &lt;+24&gt;: str    w5, [sp, #0x8]</span><br><span class="line">    0x1025424bc &lt;+28&gt;: ldr    w9, [sp, #0x1c]</span><br><span class="line">    0x1025424c0 &lt;+32&gt;: str    w9, [x8]</span><br><span class="line">    0x1025424c4 &lt;+36&gt;: ldr    w9, [sp, #0x18]</span><br><span class="line">    0x1025424c8 &lt;+40&gt;: str    w9, [x8, #0x4]</span><br><span class="line">    0x1025424cc &lt;+44&gt;: ldr    w9, [sp, #0x14]</span><br><span class="line">    0x1025424d0 &lt;+48&gt;: str    w9, [x8, #0x8]</span><br><span class="line">    0x1025424d4 &lt;+52&gt;: ldr    w9, [sp, #0x10]</span><br><span class="line">    0x1025424d8 &lt;+56&gt;: str    w9, [x8, #0xc]</span><br><span class="line">    0x1025424dc &lt;+60&gt;: ldr    w9, [sp, #0xc]</span><br><span class="line">    0x1025424e0 &lt;+64&gt;: str    w9, [x8, #0x10]</span><br><span class="line">    0x1025424e4 &lt;+68&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1025424e8 &lt;+72&gt;: str    w9, [x8, #0x14]</span><br><span class="line">    0x1025424ec &lt;+76&gt;: add    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x1025424f0 &lt;+80&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这里我们又看到了一个熟悉的x8寄存器。然后通过w9寄存器，不断的赋值给x8寄存器对应的空间里。那这个x8寄存器是怎么个情况呢，我们返回<code>viewDidLoad</code>对应的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#96;-[ViewController viewDidLoad]:</span><br><span class="line">...</span><br><span class="line">... ;这里也是截取部分代码</span><br><span class="line">0x1025425ac &lt;+64&gt;:  bl     0x1025429b4               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    0x1025425b0 &lt;+68&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 </span><br><span class="line">    0x1025425b4 &lt;+72&gt;:  mov    w0, #0x1</span><br><span class="line">    0x1025425b8 &lt;+76&gt;:  mov    w1, #0x2</span><br><span class="line">    0x1025425bc &lt;+80&gt;:  mov    w2, #0x3</span><br><span class="line">    0x1025425c0 &lt;+84&gt;:  mov    w3, #0x4</span><br><span class="line">    0x1025425c4 &lt;+88&gt;:  mov    w4, #0x5</span><br><span class="line">    0x1025425c8 &lt;+92&gt;:  mov    w5, #0x6</span><br><span class="line">    0x1025425cc &lt;+96&gt;:  bl     0x1025424a0               ; getStructB at ViewController.m:46</span><br><span class="line">-&gt;  0x1025425d0 &lt;+100&gt;: ldp    x29, x30, [sp, #0x40]</span><br><span class="line">    0x1025425d4 &lt;+104&gt;: add    sp, sp, #0x50             ; &#x3D;0x50 </span><br><span class="line">    0x1025425d8 &lt;+108&gt;: ret</span><br></pre></td></tr></table></figure>

<p>我们看到x8寄存器的位置是sp偏移8个字节。也就是返回值所在的空间是在<code>viewDidLoad</code>开辟的栈空间里。</p>
<p>这里会当前返回值存放在<code>viewDidLoad</code>所开辟的栈空间里，因为知道返回的是什么类型的数据，在<code>viewDidLoad</code>开辟空间时，就已经把返回值所需要的空间给预留出来了。通过x8寄存器来定位返回值所在的空间。</p>
<p>那么，这里为什么要偏移8个字节？</p>
<p>我们知道，ARM64对栈的操作是16个字节进行对齐的。而结构体占有24个字节，我们只能通过补齐来确保是16个字节的倍数来开辟空间。</p>
<p>执行对应的方法，对返回值的变量进行存储（根据x8寄存器来定位相应的地址存储变量的值）。</p>
<h1 id="5-函数的局部变量"><a href="#5-函数的局部变量" class="headerlink" title="5. 函数的局部变量"></a>5. 函数的局部变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sumC(int a, int b) &#123;</span><br><span class="line">    int c &#x3D; 10;</span><br><span class="line">    return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    sumC(1,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，进入汇编模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    0x1026ae45c &lt;+68&gt;: mov    w0, #0x1</span><br><span class="line">    0x1026ae460 &lt;+72&gt;: mov    w1, #0x2</span><br><span class="line">-&gt;  0x1026ae464 &lt;+76&gt;: bl     0x1026ae3e8               ; sumC at ViewController.m:75</span><br><span class="line">    0x1026ae468 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x1026ae46c &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30 </span><br><span class="line">    0x1026ae470 &lt;+88&gt;: ret</span><br></pre></td></tr></table></figure>

<p>sumC(1, 2)：1和2分别放在了w0、w1寄存器中。然后执行bl，进入函数sumC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;sumC:</span><br><span class="line">-&gt;  0x1026ae3e8 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x1026ae3ec &lt;+4&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    0x1026ae3f0 &lt;+8&gt;:  str    w1, [sp, #0x8]</span><br><span class="line">    0x1026ae3f4 &lt;+12&gt;: mov    w8, #0xa</span><br><span class="line">    0x1026ae3f8 &lt;+16&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x1026ae3fc &lt;+20&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    0x1026ae400 &lt;+24&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1026ae404 &lt;+28&gt;: add    w8, w8, w9</span><br><span class="line">    0x1026ae408 &lt;+32&gt;: ldr    w9, [sp, #0x4]</span><br><span class="line">    0x1026ae40c &lt;+36&gt;: add    w0, w8, w9</span><br><span class="line">    0x1026ae410 &lt;+40&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x1026ae414 &lt;+44&gt;: ret</span><br></pre></td></tr></table></figure>

<ol>
<li>开辟16个字节的内存空间</li>
<li>把w0放在[sp+0xc]，w1放在[sp+0x8]</li>
<li>w8赋值等于0xa，这里就是我们的局部变量c=10</li>
<li>然后把w8放在[sp+0x4]里头</li>
<li>一堆操作，ret</li>
</ol>
<p>看到了吧，函数的参数和局部变量都是放在栈里的。</p>
<h1 id="6-函数嵌套"><a href="#6-函数嵌套" class="headerlink" title="6. 函数嵌套"></a>6. 函数嵌套</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int funcSum(int a, int b, int c) &#123;</span><br><span class="line">    int d &#x3D; a + b + c;</span><br><span class="line">    printf(&quot;%d&quot;, d);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int totalSum(int a, int b) &#123;</span><br><span class="line">    int c &#x3D; 10;</span><br><span class="line">    int d &#x3D; funcSum(a, b, c);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    totalSum(1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行上面的含有局部变量的嵌套函数，看是怎么在汇编下执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    0x1002fa43c &lt;+64&gt;: bl     0x1002fa8d0               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    &#x2F;&#x2F; totalSum(1, 2)</span><br><span class="line">    0x1002fa440 &lt;+68&gt;: mov    w0, #0x1  &#x2F;&#x2F; 将1存在w0寄存器里</span><br><span class="line">    0x1002fa444 &lt;+72&gt;: mov    w1, #0x2  &#x2F;&#x2F; 2存放在w1寄存器里</span><br><span class="line">-&gt;  0x1002fa448 &lt;+76&gt;: bl     0x1002fa3bc               ; totalSum at ViewController.m:86</span><br><span class="line">    0x1002fa44c &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]     ; x29、x30寄存器取值（lr寄存器获取回家的路）</span><br><span class="line">    0x1002fa450 &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30 </span><br><span class="line">    0x1002fa454 &lt;+88&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这一坨汇编代码，已经看过无数次了，这里不细说了，直接走totalSum看看是怎么处理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;totalSum:</span><br><span class="line">-&gt;  0x1002fa3bc &lt;+0&gt;:  sub    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x1002fa3c0 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x1002fa3c4 &lt;+8&gt;:  add    x29, sp, #0x10            ; &#x3D;0x10 </span><br><span class="line">    0x1002fa3c8 &lt;+12&gt;: stur   w0, [x29, #-0x4]  ; 把totalSum的参数w0存放在栈底的位置</span><br><span class="line">    0x1002fa3cc &lt;+16&gt;: str    w1, [sp, #0x8]    ; 把w1的值放在栈顶+8个字节的位置</span><br><span class="line">    0x1002fa3d0 &lt;+20&gt;: mov    w8, #0xa          ; 获取局部变量10，放在w8寄存器</span><br><span class="line">    0x1002fa3d4 &lt;+24&gt;: str    w8, [sp, #0x4]    ; w8的值放在sp+4个字节的位置</span><br><span class="line">    0x1002fa3d8 &lt;+28&gt;: ldur   w0, [x29, #-0x4]  ; 重新对w0赋值，取值的位置就是之前w0存放的位置 w0&#x3D;1</span><br><span class="line">    0x1002fa3dc &lt;+32&gt;: ldr    w1, [sp, #0x8]    ; w1取值w1&#x3D;2</span><br><span class="line">    0x1002fa3e0 &lt;+36&gt;: ldr    w2, [sp, #0x4]    ; w2 &#x3D; 10</span><br><span class="line">    0x1002fa3e4 &lt;+40&gt;: bl     0x1002fa35c       ; funcSum at ViewController.m:80 ;执行嵌套函数 funcSum。</span><br><span class="line">    0x1002fa3e8 &lt;+44&gt;: str    w0, [sp]          ; 把w0的值存在sp对应的位置。</span><br><span class="line">    0x1002fa3ec &lt;+48&gt;: ldr    w0, [sp]          ; 获取w0</span><br><span class="line">    0x1002fa3f0 &lt;+52&gt;: ldp    x29, x30, [sp, #0x10] ; 找到回家的路</span><br><span class="line">    0x1002fa3f4 &lt;+56&gt;: add    sp, sp, #0x20     ; &#x3D;0x20 释放</span><br><span class="line">    0x1002fa3f8 &lt;+60&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>stur</code>和<code>ldur</code>。这两个的本质与<code>str</code>和<code>ldr</code>没有区别，只是带<code>u</code>的偏移的是一个负值。</p>
<p>这里也有用到x29寄存器，还有印象吗？x29寄存器就是fp寄存器，指向的是栈底的位置。从栈的存储空间来看，栈底的地址比栈顶大，所以sp栈顶开辟空间都是减去一个值，而用栈底fp做关键值时，要想获取数据都必须在sp-fp之间拿值，所以基于fp的操作都是【减】。</p>
<p>这里为什么把局部变量的值存在w8里面，就是因为w0-w7是存放函数参数的参数，之前说过，w8用来获取局部变量。</p>
<p>funcSum函数的汇编就不说了，与之前的没什么区别。</p>
<p>这里需要提一句的是，为啥要把参数先存放在内存里，然后再取出来，难道就不嫌麻烦吗？其主要目的就是为了保护参数，防止被改变。</p>
<p>到最后w0/x0寄存器还是用来存放返回值。</p>
<h1 id="7-补充内容"><a href="#7-补充内容" class="headerlink" title="7. 补充内容"></a>7. 补充内容</h1><ol>
<li><p>一个函数的参数，在函数执行完毕之后，是否能拿到这个参数的值？我们用4.2小结的代码来解释一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个test函数有9个参数，我们知道，x0-x7（w0-w7）这个8个寄存器是存放函数变量的，如果超过8个参数，则会存放在viewDidLoad函数开辟的栈空间内，也就是说1-8这8个参数是在test函数开辟的栈空间。这8个参数在test函数执行完毕之后，随着空间的释放就拿不到了，而9这个参数存放在<code>viewDidLoad</code>的栈空间，我们还可以拿到。</p>
</li>
<li><p>在4.3小结，我们返回的是一个结构体，而不是一个指针，假如，我们添加一个函数，来调用这个返回的结构体，这个结构体能不能用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;</span><br><span class="line">    struct NumA num;</span><br><span class="line">    num.a &#x3D; a;</span><br><span class="line">    num.b &#x3D; b;</span><br><span class="line">    num.c &#x3D; c;</span><br><span class="line">    num.d &#x3D; d;</span><br><span class="line">    num.e &#x3D; e;</span><br><span class="line">    num.f &#x3D; f;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct NumA returnStruct() &#123;</span><br><span class="line">    struct NumA num &#x3D; getStructA(1,2,3,4,5,6);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    struct NumB num &#x3D; returnStruct();</span><br><span class="line">    printf(&quot;a &#x3D; %d\n&quot;, num.a);  &#x2F;&#x2F; 这里是否能输出，还是会crash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 肯定是可以输出的，在<code>viewDidLoad</code>函数执行时，就已经创建了<code>struct NumB</code>所需要的空间了，返回的数据都存在于<code>viewDidLoad</code>的栈空间里，所以还是可以正常执行的。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>栈：引出SP、FP寄存器。SP：保存栈顶地址，FP：保存栈底的地址。（栈顶的地址比栈底的地址小，所以获取栈顶的值都是通过sub sp, sp #0x10,是减去一个空间，在存值的时候一般都是[sp+#0x08]）</li>
<li>stp/str 存值（16个字节/8个字节）</li>
<li>ldp/ldr 取值（16个字节/8个字节）</li>
<li>stur/ldur 本质上与str/ldr没有区别，带【u】的操作的是一个负值。</li>
<li>bl指令：通过lr(x30)寄存器，保存回家的路，bl跳转到对应的方法</li>
<li>lr寄存器的值会通过保存在栈空间，来确保能够正确的返回。</li>
<li>函数的参数：存放在x0-x7寄存器，超过8个，则放在栈里。</li>
<li>返回值：使用x0寄存器保存，如果大于8个字节，会利用栈空间传递。</li>
<li>函数的局部变量放在栈里，嵌套函数的值也是放在栈里</li>
<li>会把变量的值放在内存里保护起来，用的时候在去取值</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/11/%E9%80%86%E5%90%91/iPhone%E8%B6%8A%E7%8B%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/11/%E9%80%86%E5%90%91/iPhone%E8%B6%8A%E7%8B%B1/" class="post-title-link" itemprop="url">iPhone越狱</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 11:30:03" itemprop="dateCreated datePublished" datetime="2021-04-11T11:30:03+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><ol>
<li>我们需要一台iPhone手机，根据自己的条件，要求系统是iOS11.0 - 14.3，写这篇博客时所能处理的越狱系统是这个，过期之后请自行查找资料。</li>
<li>越狱的网站：<a href="https://unc0ver.dev/" target="_blank" rel="noopener">https://unc0ver.dev/</a>，下载安装包（ipa文件），可以按照对应的步奏进行操作，本篇所说的有另外一种，使用重签名的机制，比较简单。</li>
</ol>
<h1 id="2-开始越狱"><a href="#2-开始越狱" class="headerlink" title="2. 开始越狱"></a>2. 开始越狱</h1><ol>
<li><p>打开我们的工程文件，请自行下载。</p>
</li>
<li><p>在”Signing &amp; Capabilities” 下，修改”Bundle Identifier”为自己的，修改”Team” 使用”personal team”。</p>
</li>
<li><p>在”Build Phases” - “Run Script”下，先将script运行代码注释掉。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重签名机制的脚本文件</span><br><span class="line">#.&#x2F;appSign.sh</span><br></pre></td></tr></table></figure></li>
<li><p>运行当前的空工程文件到手机上。</p>
</li>
<li><p>运行完成之后，在回到”Build Phases” - “Run Script”下，将注释打开，重新运行。</p>
</li>
<li><p>“unc0ver”这个APP已经出现在手机上，点击APP，直接开始”Jailbreak”。手机重启几次之后，就可以了。</p>
</li>
<li><p>在”Setting”中，可以选择自己想使用的选项。其中 “Restore RootFS”可以回到未越狱状态。</p>
</li>
</ol>
<h1 id="3-为什么使用unc0ver"><a href="#3-为什么使用unc0ver" class="headerlink" title="3. 为什么使用unc0ver"></a>3. 为什么使用unc0ver</h1><ol>
<li>它可以在越狱之后，通过简单的操作回到当初未越狱的状态，对系统侵扰是最低的。</li>
<li>这个是一个安装在手机上的APP，可以随时删除。</li>
<li>开发者更新比较及时。写本篇时，iOS系统可更新的版本是14.4.2，而unc0ver已经支持到14.3版本了。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/10/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-1/" class="post-title-link" itemprop="url">ARM汇编-1 初识汇编</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 22:47:53" itemprop="dateCreated datePublished" datetime="2021-04-10T22:47:53+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-初识汇编"><a href="#1-初识汇编" class="headerlink" title="1. 初识汇编"></a>1. 初识汇编</h1><blockquote>
<p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p>
</blockquote>
<p>一个APP安装在手机上面的可执行文件本质上是二进制文件。因为iPhone手机本质上执行的指令是二进制，是由手机上的CPU执行的。所以静态分析是建立在分析二进制上面。</p>
<h1 id="2-发展历程"><a href="#2-发展历程" class="headerlink" title="2. 发展历程"></a>2. 发展历程</h1><h2 id="2-1-编程语言"><a href="#2-1-编程语言" class="headerlink" title="2.1 编程语言"></a>2.1 编程语言</h2><p>从1946年第一台电子计算机问世，人类和机器的交流方式和语言就成为了软件工程师和计算机从业者的主要研究方向。在过去的几十年，编程语言有了长足的发展。</p>
<h2 id="2-2-机器语言"><a href="#2-2-机器语言" class="headerlink" title="2.2 机器语言"></a>2.2 机器语言</h2><p>计算机的硬件作为一种电路元件，它的输出和输入只能是有电或者没电，也就是所说的高电平和低电平，所以计算机传递的数据是由“0” 和“1”组成的二进制数，所以说二进制的语言是计算机语言的本质。</p>
<h2 id="2-3-汇编语言"><a href="#2-3-汇编语言" class="headerlink" title="2.3 汇编语言"></a>2.3 汇编语言</h2><p>不难看出机器语言作为一种编程语言，灵活性较差可阅读性也很差，为了减轻机器语言带给软件工程师的不适应，人们对机器语言进行了升级和改进：用一些容易理解和记忆的字母，单词来代替一个特定的指令。这就是助记符。</p>
<h2 id="2-4-高级语言"><a href="#2-4-高级语言" class="headerlink" title="2.4 高级语言"></a>2.4 高级语言</h2><p>人们需要设计一个能够不依赖于计算机硬件，能够在不同机器上运行的程序。这样可以免去很多编程的重复过程，提高效率，同时这种语言又要接近于数学语言或人的自然语言。这就诞生了高级编程语言。比如：C、C++、Java、OC、Swift。</p>
<p>我们的代码在终端设备上的执行过程，如下图：<br><img src="media/1171618126145_.pic_hd.jpg" alt="1171618126145_.pic_hd"></p>
<ul>
<li>汇编语言与机器语言一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到汇编语言\机器语言，但汇编语言\机器语言几乎不可能还原成高级语言</li>
</ul>
<h2 id="2-5-汇编语言的特点"><a href="#2-5-汇编语言的特点" class="headerlink" title="2.5 汇编语言的特点"></a>2.5 汇编语言的特点</h2><ul>
<li>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</li>
<li>能够不受编译器的限制，对生成的二进制代码进行完全的控制</li>
<li>目标代码简短，占用内存少，执行速度快</li>
<li>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</li>
<li>不区分大小写，比如mov和MOV是一样的</li>
<li>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</li>
</ul>
<h2 id="2-6-用途"><a href="#2-6-用途" class="headerlink" title="2.6 用途"></a>2.6 用途</h2><ul>
<li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li>
<li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li>
<li>软件安全<ul>
<li>病毒分析与防治</li>
<li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li>
</ul>
</li>
<li>理解整个计算机系统的最佳起点和最有效途径</li>
<li>为编写高效代码打下基础</li>
<li>弄清代码的本质</li>
</ul>
<p>越底层越单纯，但是使用起来越困难，同时也是程序员都需要了解的非常重要的语言。</p>
<h2 id="2-7-汇编语言的分类"><a href="#2-7-汇编语言的分类" class="headerlink" title="2.7 汇编语言的分类"></a>2.7 汇编语言的分类</h2><ul>
<li>8086汇编 （8086处理器时16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（Mac，iOS）</li>
</ul>
<p>在iPhone里面，用的的ARM汇编，又根据CPU的架构不同而有差异。</p>
<table>
<thead>
<tr>
<th align="center">架构</th>
<th align="center">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">armv6</td>
<td align="center">古老的iPhone3G之前，iPod Touch（第一代，第二代）</td>
</tr>
<tr>
<td align="center">armv7</td>
<td align="center">iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3, iPad Mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td align="center">armv7s</td>
<td align="center">iPhone5, iPhone5C, iPad4</td>
</tr>
<tr>
<td align="center">armv64</td>
<td align="center">iPhone5S及以后的设备，iPad Air，iPad Mini2以后</td>
</tr>
</tbody></table>
<h1 id="3-几个必要的知识点"><a href="#3-几个必要的知识点" class="headerlink" title="3. 几个必要的知识点"></a>3. 几个必要的知识点</h1><h2 id="3-1-bit"><a href="#3-1-bit" class="headerlink" title="3.1 bit"></a>3.1 bit</h2><p>bit：表示『位』或者『比特』，是计算机运算的基础单位，是二进制数的最小单元。1 bit就是1位二进制数，只能存放0或者1。</p>
<h2 id="3-2-Byte"><a href="#3-2-Byte" class="headerlink" title="3.2 Byte"></a>3.2 Byte</h2><p>Byte：表示『字节』，是计算机文件大小的基本单位。1Byte = 8bit，表示一个字节可以存放8位无符号数。一个汉子是2个字节，16位。一个英文字母是1个字节。</p>
<p>1个字节可以表示为：0000 0000，1111 1111。</p>
<h2 id="3-3-总线"><a href="#3-3-总线" class="headerlink" title="3.3 总线"></a>3.3 总线</h2><p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p>
<p>总线是一种内部结构，它是cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</p>
<p>在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。</p>
<p>简单来说</p>
<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件交互。</li>
<li>总线就是一根根导线的集合</li>
</ul>
<h3 id="3-3-1-总线分类"><a href="#3-3-1-总线分类" class="headerlink" title="3.3.1 总线分类"></a>3.3.1 总线分类</h3><p>一般情况下分为5大类：</p>
<ol>
<li>数据总线：在CPU与RAM之间来回传送需要处理或需要存储的数据。它的宽度决定了CPU单次数据传送量，也就是数据传送的速度。例如：8086微处理器子长16位，其数据总线宽度也是16位，所以单次最大传递2个字节的数据。</li>
<li>地址总线：用来指定在RAM之中存储的数据的地址。它的宽度决定了CPU的寻址能力。例如8086的地址总线宽度是20位，那么它的寻址能力是1M（2^20）。</li>
<li>控制总线：将微处理器控制单元的信号，传送到周边设备。它的宽度决定了CPU对其他器件的控制能力。</li>
<li>扩展总线：外部设备和计算机主机进行数据通信的总线，例如ISA，PCI总线。</li>
<li>局部总线：取代更高速数据传输的扩展总线。</li>
</ol>
<p>其中数据总线、地址总线、控制总线也统称为系统总线。</p>
<h2 id="3-4-进制"><a href="#3-4-进制" class="headerlink" title="3.4 进制"></a>3.4 进制</h2><p>常用的进制有2进制，8进制，10进制，16进制。<br>2进制：00 11 11 100 101，逢2进1<br>8进制 0 1 2 3 4 5 6 7 10， 逢8进1<br>16进制 0 1 2 3 4 5 6 7 8 9 A B C D E F 10， 逢16进1</p>
<p>还有一些可以自己定义的进制，约定几个符合来表示对应的数据：<br>比如3进制 我们用a 3 1表示，通常约定好一些符合来表示对应的数据，以此来达到加密的效果。</p>
<p>运算等一些列就不说了<del>~</del></p>
<h2 id="3-5-数据的宽度"><a href="#3-5-数据的宽度" class="headerlink" title="3.5 数据的宽度"></a>3.5 数据的宽度</h2><p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int test() &#123;</span><br><span class="line">    int cTemp &#x3D; 0x1FFFFFFFF;</span><br><span class="line">    return cTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个int类型的变量，但是赋值的是9位16进制数。但是这里打印cTemp的值发现是-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p cTemp</span><br><span class="line">(int) $0 &#x3D; -1</span><br><span class="line">(lldb) p &amp;cTemp</span><br><span class="line">(int *) $1 &#x3D; 0x000000016f8e926c</span><br><span class="line">(lldb) x 0x000000016f8e926c</span><br><span class="line">0x16f8e926c: ff ff ff ff b0 92 8e 6f 01 00 00 00 88 a5 51 00  .......o......Q.</span><br><span class="line">0x16f8e927c: 01 00 00 00 10 00 00 00 00 00 00 00 02 00 00 00  ................</span><br><span class="line">(lldb) p (uint)cTemp</span><br><span class="line">(uint) $0 &#x3D; 4294967295</span><br></pre></td></tr></table></figure>

<p>通过上面的打印，发现cTemp所在的地址钟存放的是ff ff ff ff，而前面的1没有了，这就是发生了溢出。但是通过转换无符号数，发现是可以正常打印的。这就说明了，地址钟存放的数据是没有发生变化的，只是由于位数的限制导致的有符号和无符号的区别，导致的数据不一致。</p>
<p>在通常的二进制中，第一位表示正负，0表示正 1表示负。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; int 4个字节，表示32位。第一位为符号为。</span><br><span class="line"> F    F    F    F    F    F    F    F</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>这里提一嘴我们经常用的宽带，都是100M的，200M的，但是这个的意思是100Mbps，说的也是宽度，除以8才是对应的数据传输速度。</p>
<h1 id="4-CPU-amp-寄存器"><a href="#4-CPU-amp-寄存器" class="headerlink" title="4. CPU &amp; 寄存器"></a>4. CPU &amp; 寄存器</h1><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<ul>
<li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制。</li>
<li>不同的CPU，寄存器的个数、结构是不相同的。</li>
</ul>
<h2 id="4-1-浮点和向量寄存器"><a href="#4-1-浮点和向量寄存器" class="headerlink" title="4.1 浮点和向量寄存器"></a>4.1 浮点和向量寄存器</h2><p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p>
<ul>
<li>浮点寄存器 64位: D0 - D31 32位: S0 - S31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<ul>
<li>向量寄存器 128位:V0-V31</li>
</ul>
<h2 id="4-2-通用寄存器"><a href="#4-2-通用寄存器" class="headerlink" title="4.2 通用寄存器"></a>4.2 通用寄存器</h2><p>通用寄存器也称数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。</p>
<p>ARM64拥有有32个64位的通用寄存器 x0 到 x30，以及XZR(零寄存器),这些通用寄存器有时也有特定用途。</p>
<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!</li>
</ul>
<p><img src="arm-register.jpg" alt=""></p>
<p>图片上标注了1、2、3、4分别有所对应。<br>1 - 点击进入汇编<br>2 - 进入汇编之后，选择『All Variables, register』，会显示如图所示<br>3 - 浮点和向量寄存器，存放对应的v0-v31，d0-d31，s0-s31<br>4 - 通用寄存器，存放x0-x28，fp，lr，sp，pc，w0-w28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov x0, #0xa0           ; x0 &#x3D; 0xa0</span><br><span class="line">mov x1,#0x00            ; x1 &#x3D; 0x00</span><br><span class="line">add x1, x0, #0x14       ; x1 &#x3D; x0 + 0x14</span><br><span class="line">mov x0,x1               ; x0 &#x3D; x1</span><br></pre></td></tr></table></figure>

<h2 id="4-3-pc寄存器-program-counter"><a href="#4-3-pc寄存器-program-counter" class="headerlink" title="4.3 pc寄存器(program counter)"></a>4.3 pc寄存器(program counter)</h2><ul>
<li><p>为指令指针寄存器，它指示了CPU当前要读取指令的地址</p>
</li>
<li><p>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</p>
</li>
<li><p>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义</p>
<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010</li>
<li>可以当做数据 0xE003008AA</li>
<li>也可以当做指令 mov x0, x8</li>
</ul>
</li>
<li><p>CPU根据什么将内存中的信息看做指令？</p>
<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul>
</li>
</ul>
<h2 id="4-4-高速缓存"><a href="#4-4-高速缓存" class="headerlink" title="4.4 高速缓存"></a>4.4 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
<h2 id="4-5-bl指令"><a href="#4-5-bl指令" class="headerlink" title="4.5 bl指令"></a>4.5 bl指令</h2><p>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令。</p>
<p>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<br>mov x0,#10、mov x1,#20。但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p>
<p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p>
<h3 id="4-5-1-bl指令-–-练习"><a href="#4-5-1-bl指令-–-练习" class="headerlink" title="4.5.1 bl指令 – 练习"></a>4.5.1 bl指令 – 练习</h3><p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _A,_B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">    mov x0,#0xa0</span><br><span class="line">    mov x1,#0x00</span><br><span class="line">    add x1, x0, #0x14</span><br><span class="line">    mov x0,x1</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0,#0x0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>打开Xcode，新建一个工程，在新建文件是选择 『Assembly File』，生成的是『.s』文件。然后将上面的代码复制粘贴。</p>
</li>
<li><p>在ViewController中，进行函数声明。这里需要注意的是，方法明需要一致。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数的声明~~</span><br><span class="line">int A();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>viewDidLoad</code>中直接调用<code>A()</code>，打断点，然后跳转到汇编。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0, #0xa0       ; x0 &#x3D; a0</span><br><span class="line">    mov x1,#0x00        ; x1 &#x3D; 0</span><br><span class="line">    add x1, x0, #0x14   ; x1 &#x3D; x0 + 0x14</span><br><span class="line">    mov x0,x1           ; x0 &#x3D; x1</span><br><span class="line">    bl _B               ; 跳转到方法 _B --&gt; 执行B</span><br><span class="line">    mov x0, #0x0        ; 从B回来之后执行 x0 &#x3D; 0</span><br><span class="line">    ret                 ; return, 继续点击会发现啥？</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10   ; x0 +&#x3D; 10</span><br><span class="line">    ret                 ; return，方法结束回到A继续执行</span><br></pre></td></tr></table></figure>

<p>这里会有一点问的哈~会导致循环了。为啥会导致循环了呢？翻下一章。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ol>
<li>汇编基础知识，发展、用途、特点</li>
<li>几个知识点：bit，Byte，总线，数据宽度</li>
<li>CPU 寄存器。浮点寄存器（64位: D0 - D31 32位: S0 - S31）；向量寄存器（128位:V0-V31）；通用寄存器（32位w0-w28，64位x0-x28），PC寄存器。</li>
<li>bl指令</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/10/%E9%80%86%E5%90%91/%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E9%80%86%E5%90%91/%E5%AF%86%E7%A0%81%E5%AD%A6-RSA/" class="post-title-link" itemprop="url">密码学_RSA</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 15:25:44" itemprop="dateCreated datePublished" datetime="2021-04-10T15:25:44+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 10:46:59" itemprop="dateModified" datetime="2021-05-14T10:46:59+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-密码学"><a href="#1-密码学" class="headerlink" title="1. 密码学"></a>1. 密码学</h1><h2 id="1-1-密码学概述"><a href="#1-1-密码学概述" class="headerlink" title="1.1 密码学概述"></a>1.1 密码学概述</h2><p>密码学是指研究信息加密，破解密码的技术科学。密码学的起源可追溯到2000年前。而当今的密码学是以数学为基础的。</p>
<h2 id="1-2-发展"><a href="#1-2-发展" class="headerlink" title="1.2 发展"></a>1.2 发展</h2><ol>
<li>在1976年以前，所有的加密方法都是同一种模式：加密、解密使用同一种算法。在交互数据的时候，彼此通信的双方就必须将规则告诉对方，否则没法解密。那么加密和解密的规则（简称密钥），它保护就显得尤其重要。传递密钥就成为了最大的隐患。这种加密方式被成为对称加密算法（symmetric encryption algorithm）</li>
<li>1976年，两位美国计算机学家 迪菲（W.Diffie）、赫尔曼（ M.Hellman ） 提出了一种崭新构思，可以在不直接传递密钥的情况下，完成密钥交换。这被称为“<B>迪菲赫尔曼密钥交换</B>”算法。开创了密码学研究的新方向。</li>
<li>1977年三位麻省理工学院的数学家 <B>罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）</B>一起设计了一种算法，可以实现<B>非对称加密</B>。这个算法用他们三个人的名字命名，叫做<B>RSA算法</B>。</li>
</ol>
<h1 id="2-RSA"><a href="#2-RSA" class="headerlink" title="2. RSA"></a>2. RSA</h1><p>RSA加密方式比较特殊，需要两个密钥：公开密钥简称公钥（publickey）和私有密钥简称私钥（privatekey）。公钥加密，私钥解密；私钥加密，公钥解密。这个加密算法就是伟大的RSA。</p>
<h2 id="2-1-欧拉函数"><a href="#2-1-欧拉函数" class="headerlink" title="2.1 欧拉函数"></a>2.1 欧拉函数</h2><p>首先考虑什么是离散对数：在整数中，离散对数（英语：Discrete logarithm）是一种基于同余运算和<a href="https://baike.baidu.com/item/%E5%8E%9F%E6%A0%B9" target="_blank" rel="noopener">原根</a>的一种对数运算。</p>
<p>互质关系：如果两个正整数，除了1以外，没有其他公因数，我们就称这两个数是互质关系（coprime）。</p>
<p>有一个正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？<br>计算这个值的方式就是<b>欧拉函数</b>。用φ(n)来表示。φ -&gt; phi</p>
<p>例如：</p>
<blockquote>
<p>计算8的欧拉函数，和8互质的数有1、3、5、7<br>φ(8) = 4</p>
<p>例如计算7的欧拉函数，和7互质的数有1、2、3、4、5、6<br>φ(7) = 6</p>
<p>例如计算56的欧拉函数<br>φ(56) = φ(8) * φ(7) = 4 * 6 = 24</p>
</blockquote>
<h3 id="2-2-1-欧拉函数的特性："><a href="#2-2-1-欧拉函数的特性：" class="headerlink" title="2.2.1 欧拉函数的特性："></a>2.2.1 欧拉函数的特性：</h3><ol>
<li>当n是质数的时候，φ(n)=n-1。</li>
<li>如果n可以分解成两个互质的整数之积，如n=A<em>B则：φ(A*B)=φ(A)</em> φ(B)</li>
</ol>
<p>根据以上两点得到：<br>如果N是两个质数P1 和 P2的乘积则φ(N)=φ(P1)* φ(P2)=(P1-1)*(P2-1)</p>
<h2 id="2-2-欧拉定理"><a href="#2-2-欧拉定理" class="headerlink" title="2.2 欧拉定理"></a>2.2 欧拉定理</h2><p>如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。</p>
<p>m^φ(n) % n = 1</p>
<p>也就是说，m的φ(n)次方减去1，能被n整出。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; m &#x3D; 3， n &#x3D; 11, φ(n) &#x3D; 10</span><br><span class="line">&#x2F;&#x2F; 再Python3的环境下，快速输出结果，如下</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3**10%11</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-费马小定理"><a href="#2-2-1-费马小定理" class="headerlink" title="2.2.1 费马小定理"></a>2.2.1 费马小定理</h3><p>欧拉定理的特殊情况：如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1。</p>
<p>m^(n-1) % n = 1</p>
<p>这就是一开始所说的那种情况，如果n为质数，则φ(n)= n-1</p>
<h2 id="2-3-模反元素"><a href="#2-3-模反元素" class="headerlink" title="2.3 模反元素"></a>2.3 模反元素</h2><p>如果两个正整数e和x互质，那么一定可以找到整数d，使得 ed-1 被x整除。那么d就是e对于x的“模反元素”。<br>e*d % x = 1</p>
<h2 id="2-4-公式推导过程："><a href="#2-4-公式推导过程：" class="headerlink" title="2.4 公式推导过程："></a>2.4 公式推导过程：</h2><ol>
<li><p>1^k = 1, 1的k次方等于1</p>
</li>
<li><p>1 * m = m</p>
</li>
<li><p>根据欧拉定理：m^φ(n) % n = 1，公式两边分别执行k次方。</p>
</li>
<li><p>(m^φ(n) % n)^k = 1^k 公式简化后：</p>
</li>
<li><p>m^k*φ(n) % n = 1，等式两边分别乘以m</p>
</li>
<li><p>(m^k*φ(n) % n) * m = 1 * m 简化后：</p>
</li>
<li><p>m^k*φ(n)+1 % n = m</p>
</li>
<li><p>根据模反元素的公式：e<em>d % x = 1，则 e</em>d = k*x + 1</p>
</li>
</ol>
<p>到这里，有没有发现什么？看推导的第7步和第8步的公式，k<em>φ(n)+1 和 k</em>x+1是不是很相似。则 e * d = k*φ(n)+1</p>
<p>那最后是不是可以得出：m^ed % n = m</p>
<p>这就是大名鼎鼎的<b>迪菲赫尔曼密钥交换</b>。<br>我们假设 m = 3，n = 17，<br>服务器生成随机数 e = 15，客户端生成随机数 d = 13</p>
<p>服务器 m^e % n，结果是 3^15 % 17 = 6， 把明文6传给客户端。<br>客户端 m^d % n，结果是 3^13 % 17 = 12， 把明文12传给服务器。</p>
<p>两端拿到的数据分别进行解密：<br>客户端 6^13 % 17 = 10<br>服务器 12^15 % 17 = 10</p>
<p><b>迪菲赫尔曼密钥交换</b>:<br>3^15<em>12 % n = 3^13</em>15 % n<br>m^e<em>d % n = 10 = m^d</em>e % n</p>
<p>从这个时候开始，开创了密码学研究的新方向，也为RSA加密打下了基础。RSA对上面的公式进行了拆分：</p>
<p>m^e % n = c<br>c^d % n = m</p>
<p>这就是RSA诞生的原理。其中<br>m^e % n = c 进行加密<br>c^d % n = m 进行解密</p>
<p>n、e是公钥，n、d是私钥，m是明文，c是密文。</p>
<p>验证： m = 4， n = 15， φ(n) = 8， e = 3，<br>求出d（d是e对于φ(n)的“模反元素”） d = 11，19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; python3环境</span><br><span class="line">&gt;&gt;&gt; 4**33%15</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加入m &#x3D; 5</span><br><span class="line">&gt;&gt;&gt; 5**33%15</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加入m &#x3D; 15</span><br><span class="line">&gt;&gt;&gt; 15**33%15</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>到此，就看到了整个的RAS的基本过程。</p>
<h1 id="3-RSA总结"><a href="#3-RSA总结" class="headerlink" title="3. RSA总结"></a>3. RSA总结</h1><h2 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h2><ol>
<li>n会非常大，长度一般为1024个二进制位。（目前人类已经分解的最大整数，232个十进制位，768个二进制位）</li>
<li>由于需要求出φ(n)，所以根据欧函数特点，最简单的方式n 由两个质数相乘得到: 质数：p1、p2，Φ(n) = (p1 -1) * (p2 - 1)</li>
<li>最终由φ(n)得到e 和 d。总共生成6个数字：p1、p2、n、φ(n)、e、d</li>
</ol>
<h2 id="3-2-关于RSA的安全："><a href="#3-2-关于RSA的安全：" class="headerlink" title="3.2 关于RSA的安全："></a>3.2 关于RSA的安全：</h2><p>除了公钥用到了n和e 其余的4个数字是不公开的。目前破解RSA得到d的方式如下：</p>
<ol>
<li>要想求出私钥 d。由于e<em>d = φ(n)</em>k + 1。要知道e和φ(n);</li>
<li>e是知道的，但是要得到 φ(n)，必须知道p1 和 p2。</li>
<li>由于 n=p1*p2。只有将n因数分解才能算出。</li>
</ol>
<h2 id="3-3-RSA特点"><a href="#3-3-RSA特点" class="headerlink" title="3.3 RSA特点"></a>3.3 RSA特点</h2><ol>
<li>相对来说比较安全（非对称加密）</li>
<li>效率低 </li>
<li>加密小数据，一般加密核心数据</li>
</ol>
<h1 id="4-终端演示"><a href="#4-终端演示" class="headerlink" title="4. 终端演示"></a>4. 终端演示</h1><p>由于Mac系统内置OpenSSL(开源加密库)，所以我们可以直接在终端上使用命令来玩RSA。OpenSSL中RSA算法常用指令主要有三个：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">genrsa</td>
<td align="left">生成并输入一个RSA密钥</td>
</tr>
<tr>
<td align="left">rsatul</td>
<td align="left">使用RSA密钥进行加密、解密、签名和验证等运算</td>
</tr>
<tr>
<td align="left">rsa</td>
<td align="left">处理RSA密钥的格式转化等问题</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用命令行演示</span><br><span class="line">&#x2F;&#x2F; 1. 生成RSA密钥，密钥长度为1024bit</span><br><span class="line">&gt; openssl genrsa -out private.pem 1024</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 从私钥中提取公钥</span><br><span class="line">&gt; openssl rsa -in private.pem -pubout -out public.pem</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 将私钥转换为明文信息</span><br><span class="line">&gt; openssl rsa -in private.pem -text -out private.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 通过公钥加密 首先创建一个message.txt文件，并输入内容</span><br><span class="line">&gt; vi message.txt </span><br><span class="line">&gt; openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5. 通过私钥解密</span><br><span class="line">&gt; openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6. 通过私钥加密数据</span><br><span class="line">&gt; openssl rsautl -sign -in message.txt -inkey private.pem -out penc.txt</span><br><span class="line">&#x2F;&#x2F; 7. 公钥解密数据</span><br><span class="line">&gt; openssl rsautl -verify -in penc.txt -inkey public.pem -pubin -out pdec.txt</span><br></pre></td></tr></table></figure>

<h1 id="5-代码演示"><a href="#5-代码演示" class="headerlink" title="5. 代码演示"></a>5. 代码演示</h1><p>由于Xcode是没有办法直接使用pem文件的，所以需要转化，首先需要生成请求的cer文件（可以理解为证书请求文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl req -new -key private.pem -out rsacert.csr</span><br><span class="line">-----</span><br><span class="line">&gt; Country Name (2 letter code) []:CN</span><br><span class="line">&gt; State or Province Name (full name) []:Beijing</span><br><span class="line">&gt; Locality Name (eg, city) []:Chaoyang</span><br><span class="line">&gt; Organization Name (eg, company) []:Wangjing</span><br><span class="line">&gt; Organizational Unit Name (eg, section) []:alan.com</span><br><span class="line">&gt; Common Name (eg, fully qualified host name) []:alan.com</span><br><span class="line">&gt; Email Address []:alan@163.com</span><br><span class="line"></span><br><span class="line">&gt; Please enter the following &#39;extra&#39; attributes</span><br><span class="line">&gt; to be sent with your certificate request</span><br><span class="line">&#x2F;&#x2F; 这里不使用密码，其他根据要求自己填写。</span><br><span class="line">&gt; A challenge password []:</span><br></pre></td></tr></table></figure>

<p>拿到csr文件之后，需要去请求签名文件，一般用于服务器，下发证书，比如https</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt</span><br></pre></td></tr></table></figure>

<p>然后我们通过crt证书生成Xcode可用的p12证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt</span><br><span class="line">&#x2F;&#x2F; 注意这里需要输入密码，123456</span><br></pre></td></tr></table></figure>

<p>在iOS系统钟，ctr文件是无法直接使用的，所以还需要把ctr文件转化为der文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl x509 -outform der -in rsacert.crt -out rsacert.der</span><br></pre></td></tr></table></figure>


<p>生成的rsacert.der和p.p12文件就相当于我们要使用的公钥和私钥。</p>
<p>正常情况下，客户端不会同时存在公钥和私钥，因为这样做没有意义。客户端一般存放的是公钥，私钥在服务端。代码使用就不放了，这里有一套<a href="https://github.com/ideawu/Objective-C-RSA" target="_blank" rel="noopener">Github Objective-c-RSA</a>代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>RSA终端命令</li>
<li>RSA特点<ul>
<li>RSA安全系数非常高（整个业务逻辑非常安全）</li>
<li>加密效率非常低（不能做大数据加密）</li>
<li>用来加密关键数据</li>
</ul>
</li>
</ul>
<p>感谢~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/15/OC%E5%85%B6%E5%AE%83/Universal-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/OC%E5%85%B6%E5%AE%83/Universal-Link/" class="post-title-link" itemprop="url">Universal Link</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 17:33:57" itemprop="dateCreated datePublished" datetime="2020-03-15T17:33:57+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Universal-Links？"><a href="#什么是Universal-Links？" class="headerlink" title="什么是Universal Links？"></a>什么是Universal Links？</h2><p>iOS9之后，Apple推出的一种通用链接，能够方便的通过https链接来启动APP，通过唯一的网址，不需要特别的schema就可以链接一个特定的视图到APP。<br>这也就设计到universal links的几个特性：</p>
<ol>
<li>Unique：唯一性，不像自定义Url schemes那样，因为他使用到了你网站的http或者https链接</li>
<li>Secure：安全性，当用户安装应用时，iOS会检测你上传到服务器上的文件，以确保你的网站允许其代表应用打开你的应用。</li>
<li>Flexible：灵活性，当没有安装你的app时universal links也是可以正常使用的，当点击link时会直接在safari中打开url。</li>
<li>Simple：一个url可以为app和web提供服务。</li>
<li>Private：其他app可以与你的app通信，不需要知道你的应用程序是否安装。</li>
</ol>
<h2 id="配置Universal-links"><a href="#配置Universal-links" class="headerlink" title="配置Universal links"></a>配置Universal links</h2><p>配置Universal links需要网站与app协同处理，两端都需要做一些工作。</p>
<h3 id="创建并上传关联文件"><a href="#创建并上传关联文件" class="headerlink" title="创建并上传关联文件"></a>创建并上传关联文件</h3><p>首先，你的网站必须支持https。<br><br>然后，创建apple-app-site-association文件，注意一定是没有.json后缀的，在未压缩的情况下，文件大小不能超过128KB。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;&#x2F;wwdc&#x2F;news&#x2F;&quot;, &quot;&#x2F;videos&#x2F;wwdc&#x2F;2015&#x2F;*&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>appID：</b>是由TeamID+BundleId组成，TeamID可以通过开发者账号来查看，Bundle ID可以直接在工程里查看。<br></p>
<p><b>paths：</b>是一个数组类型用来指定网站路径，并且是大小写敏感的：<br>使用* 指定整个网站，在域名下的任何地址都可以打开App。<br><br>“/wwdc/news/”指定链接，以指定网站的某些部分.<br><br>还可以使用“?”匹配任何单个字符，”/foo/*/bar/201?/mypage”</p>
<p>创建好apple-app-site-association文件后，将其上传到web服务器的跟目录下或者<code>.well-known</code>子目录下。<b>文件是通过https访问不需要有任何重定向。</b>然后你可以直接在浏览器中输入domain/apple-app-site-association或者domain/.well-known/apple-app-site-association访问你所上传的文件。</p>
<p>通过Apple的测试网站可以检测你上传的文件是否正确。<a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">传送门</a></p>
<p><b>注意：</b></p>
<blockquote>
<p>在用Nginx处理文件的MIME Type配置时，在域名下针对该文件进行处理，也就是说response的Content-Type必须设置为”application/json“。<br>使用Nginx处理文件的MIME Type配置，在server的某个域名下针对该文件处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;apple-app-site-association &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><ol>
<li><p>需要支持Universal links的话，需要将开发者中心的配置APPlication Services列表中的ASSociated Domains变成Enabled。</p>
</li>
<li><p>在项目targets-&gt;Capabilities-&gt;Associated Domains中配置App link。在这里需要注意一下，有的域名为<a href="http://www.abc.com和abc.com，这两个对于Universal" target="_blank" rel="noopener">www.abc.com和abc.com，这两个对于Universal</a> links来说是不同的域名，所以，如果你的网站是这两个都需要做处理的话，需要将这两个域名都放在associate domains列表下。在添加时都要将<code>applinks:</code>放在域名前面。<br> 例如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applinks:www.abc.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要手动的添加<code>entitlements</code>，当添加domain之后，系统会自动添加相应的文件到工程，如果没有的情况下，只能通过手动添加。 </p>
</li>
<li><p>在AppDelegate中调用方法来处理Universal links的回调。</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> * _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ([userActivity.activityType isEqualToString:<span class="built_in">NSUserActivityTypeBrowsingWeb</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *webUrl = userActivity.webpageURL;</span><br><span class="line">        <span class="keyword">if</span> ([webUrl.host isEqualToString:<span class="string">@"domain"</span>]) &#123;</span><br><span class="line">            <span class="comment">//打开对应页面</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不能打开，使用Safari 打开</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication]openURL:webUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里回传过来一个<code>NSUserActivity</code>类型的数据，对该数据处理来跳转相应的界面。也就不再多说了。<br>到此整体的流程就已经处理完了。相关的内容介绍还是推荐看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2" target="_blank" rel="noopener">官方文档</a>，写的比较细致。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>apple-app-site-association文件上传一定不要有<code>.json</code>后缀，那些隐藏后缀名的需要注意。</li>
<li>web server必须支持https</li>
<li>上传文件最好在根目录下，官方说也可以在根目录下的<code>.well-known</code>目录下。</li>
<li>Xcode中配置Associated Domians时，一定要添加<code>applinks:</code>前缀。最多添加20-30条。</li>
<li>app在<b>安装</b>的时候会访问<code>domain</code>获取<code>apple-app-site-association</code>文件,这个可以通过抓包来获取。不是在打开app时访问。</li>
<li>直接dev打包到手机上应该就可以测试，保证网络畅通。</li>
<li>最简单的方式检测Universal links是否有效，将那个链接拷贝的备忘录中（imessage、邮件），直接点击链接会跳转到App，或者长按，会在弹出的ActionSheet中第二个显示<code>在xxx中打开</code>。</li>
<li>一定是从上级页面（网页）<b>点击触发</b> 的Universal links。</li>
<li>用 Safari 打开目标域名，或者在其他 App 里用 SFSafariViewController, WKWebView, UIWebView 打开目标域名，都可以达到效果。</li>
</ol>
<h2 id="那些坑"><a href="#那些坑" class="headerlink" title="那些坑"></a>那些坑</h2><h3 id="1-跨域跳转：饿了么遇到的一个问题"><a href="#1-跨域跳转：饿了么遇到的一个问题" class="headerlink" title="1. 跨域跳转：饿了么遇到的一个问题"></a>1. 跨域跳转：<a href="http://mobilists.eleme.io/2016/01/10/%E7%AA%81%E7%A0%B4%E5%BE%AE%E4%BF%A1%E8%B7%B3%E8%BD%AC%E9%99%90%E5%88%B6%EF%BC%8DUniversal-Links%E9%82%A3%E4%BA%9B%E5%9D%91/" target="_blank" rel="noopener">饿了么遇到的一个问题</a></h3><p>这里的问题，就是我们将链接复制在备忘录里发现可以拉起App，但是放在网页里，点击却是没有任何效果，这个几乎就是跨域的锅。</p>
<p>这个应该是在iOS9.2之后出现的问题。假设当前网页是abc.com/a，在这里有一个链接跳转到abc.com/b,还是在同一个域名abc.com下。这时点击，系统将不会进行拉起App的操作，必须在不同的域名下比如abcd.com/b，这样才会根据关联文件去判断是否要拉起app。这个时候就需要在Xcode中添加一个域名在碰到跨域问题不能拉起App时，链接改为其他的域名。<br><a href="https://stackoverflow.com/questions/32751225/ios9-universal-links-does-not-work/32751734#32751734" target="_blank" rel="noopener">这里也有解释</a></p>
<h3 id="2-选择性跳转"><a href="#2-选择性跳转" class="headerlink" title="2. 选择性跳转"></a>2. 选择性跳转</h3><p>这个也是一个坑，苹果会通过Universal links记录用户的行为习惯，当你通过一个Universal links成功的拉起了App，这时你发现在status bar右上角有一个小按钮（带一个小箭头）。当你点击了之后会成功的在Safari中打开，这时，苹果就认为你不需要这个Universal links拉起App，此后在通过这个Universal links点击时，都是在safari或者网页中打开，不会再拉起App。这个是有办法补救的，通过在Safari中点击链接长按，在app中打开。此后通过Universal links就可以拉起App了。也就说，苹果会记录最后一次Universal links的跳转情况来判断是否需要拉起app。</p>
<p>这里感觉第一个的跨域跳转与第二个的选择性跳转是很类似的，第一个在当前域名下点击Universal links不能拉起app就相当于当前系统认为你这个universal links本身就在浏览器中打开的，认为不需要拉起app。</p>
<blockquote>
<p>When a user taps a universal link that you handle, iOS also examines the user’s recent choices to determine whether to open your app or your website. For example, a user who has tapped a universal link to open your app can later choose to open your website in Safari by tapping a breadcrumb button in the status bar. After the user makes this choice, iOS continues to open your website in Safari until the user chooses to open your app by tapping OPEN in the Smart App Banner on the webpage.</p>
</blockquote>
<h3 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h3><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2" target="_blank" rel="noopener">官方文档</a></p>
<p>通过Apple的测试网站可以检测你上传的文件是否正确。<a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">传送门</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/15/OC%E5%85%B6%E5%AE%83/Create-private-pods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/OC%E5%85%B6%E5%AE%83/Create-private-pods/" class="post-title-link" itemprop="url">创建pod私有库</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 17:00:47" itemprop="dateCreated datePublished" datetime="2020-03-15T17:00:47+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看本地cocoaPod库 <code>cd ~/.cocoapods/repos</code>在repos文件夹下面，可以看到你当前存在的一些库，当你创建了自己的私有仓库时，也会在这里显示。</p>
<p>按照正常逻辑来看，私有库是一个地址，版本号管理库是一个地址，最好不要把两者放在一起，会显得很乱。<br>所以创建私有库，我们需要创建两个库：一个是私有仓库repo，用来做私有库的版本管理；另一个是私有代码库，用来做代码编写。</p>
<h2 id="创建私有仓库-repo"><a href="#创建私有仓库-repo" class="headerlink" title="创建私有仓库 repo"></a>创建私有仓库 repo</h2><p>这里的私有空间是指私有库存放的位置，repo是repository（存储库）的缩写，如果私有库的podSpec和代码存放在一起就会显得很乱，所有通常的做法就是再私有空间只存放私有库的podSpec文件（可以理解为版本号）。</p>
<h3 id="创建远程私有repo"><a href="#创建远程私有repo" class="headerlink" title="创建远程私有repo"></a>创建远程私有repo</h3><p>这里使用码云，可以免费创建多个私有工程。例如创建了一个私有存储库：<a href="https://gitee.com/devAlan/PrivateRepo。（已不存在）" target="_blank" rel="noopener">https://gitee.com/devAlan/PrivateRepo。（已不存在）</a></p>
<h3 id="添加到本地仓库中"><a href="#添加到本地仓库中" class="headerlink" title="添加到本地仓库中"></a>添加到本地仓库中</h3><p><code>pod repo add [本地仓库repo名称] [远程repo地址]</code><br><code>pod repo add PrivateRepo https://gitee.com/devAlan/PrivateRepo</code><br>使用上面步骤就可以将远程的私有版本存储仓库添加到本地。在Finder中查看repos中就可以发现增加了一个文件夹PrivateRepo。</p>
<h2 id="创建私有代码库"><a href="#创建私有代码库" class="headerlink" title="创建私有代码库"></a>创建私有代码库</h2><p>创建代码私有库有两种方式，第一种是我们正常的使用Xcode创建项目的过程，另一种是使用pod模板来创建的过程，推荐使用模板来创建。</p>
<h3 id="创建一个私人代码库"><a href="#创建一个私人代码库" class="headerlink" title="创建一个私人代码库"></a>创建一个私人代码库</h3><p>创建一个私人代码库，在创建时添加MIT License和README。<br>使用模板创建时，创建空仓库。</p>
<h4 id="将仓库clone到本地，添加项目工程文件。"><a href="#将仓库clone到本地，添加项目工程文件。" class="headerlink" title="将仓库clone到本地，添加项目工程文件。"></a>将仓库clone到本地，添加项目工程文件。</h4><h4 id="添加-podspec文件"><a href="#添加-podspec文件" class="headerlink" title="添加.podspec文件"></a>添加.podspec文件</h4><p>“.podspec”文件是这个代码库的pod描述文件，使用pod命令创建空白模板。<br><br><code>pod spec create 项目名称</code><br><br>这里使用上面的私有代码库创建<code>pod spec create privateAdd</code>。</p>
<p>需要注意一下：生成的默认的podspec文件中，所有没有注释掉的都必须填写正确。</p>
<h3 id="使用pod模板创建"><a href="#使用pod模板创建" class="headerlink" title="使用pod模板创建"></a>使用pod模板创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pod lib creare [项目名称]（最好与远端一致）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下为模板创建时，会用到的一些选项问题，根据实际选择就好。</span><br><span class="line">What platform do you want to use?? [ iOS &#x2F; macOS ]</span><br><span class="line"> &gt; iOS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选择编程语言</span><br><span class="line">What language do you want to use?? [ Swift &#x2F; ObjC ]</span><br><span class="line"> &gt; ObjC</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 是否需要添加本地库</span><br><span class="line">Would you like to include a demo application with your library? [ Yes &#x2F; No ]</span><br><span class="line"> &gt; No</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否有frameworks</span><br><span class="line">Which testing frameworks will you use? [ Specta &#x2F; Kiwi &#x2F; None ]</span><br><span class="line"> &gt; None</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">Would you like to do view based testing? [ Yes &#x2F; No ]</span><br><span class="line"> &gt; No</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建的文件前缀</span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; HM</span><br></pre></td></tr></table></figure>
<p>上述命令操作完成之后，会生成相应的模板文件。<br>代码文件都存放在<code>/[项目名称]/class/</code>下。<br>图片都存放在<code>/[项目名称]/Assets/</code>下。</p>
<h3 id="将本地-Lib-工程与远程私有-lib-Git-仓库关联"><a href="#将本地-Lib-工程与远程私有-lib-Git-仓库关联" class="headerlink" title="将本地 Lib 工程与远程私有 lib Git 仓库关联"></a>将本地 Lib 工程与远程私有 lib Git 仓库关联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程仓库地址  </span><br><span class="line">    git错误处理</span><br><span class="line">    git pull --rebase origin master </span><br><span class="line">    git push -u origin master           </span><br><span class="line">    </span><br><span class="line">git push origin master   #同步操作</span><br><span class="line">    文件冲突 （保留一份 license 和 readme）</span><br><span class="line">    git pull origin master --allow-unrelated-histories</span><br><span class="line">    git mergetool</span><br></pre></td></tr></table></figure>

<h2 id="编辑“-podspec”文件"><a href="#编辑“-podspec”文件" class="headerlink" title="编辑“.podspec”文件"></a>编辑“.podspec”文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Be sure to run `pod spec lint PrivateAdd_v2.podspec' to ensure this is a</span></span><br><span class="line"><span class="comment">#  valid spec and to remove all comments including this before submitting the spec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html</span></span><br><span class="line"><span class="comment">#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明</span></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  These will help people to find your library, and whilst it</span></span><br><span class="line">  <span class="comment">#  can feel like a chore to fill in it's definitely to your advantage. The</span></span><br><span class="line">  <span class="comment">#  summary should be tweet-length, and the description more in depth.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># 私有库名称</span></span><br><span class="line">  s.name         = <span class="string">"PrivateAdd_v2"</span>    </span><br><span class="line">  <span class="comment"># 版本号，跟当前版本tag有关</span></span><br><span class="line">  s.version      = <span class="string">"0.0.1"</span>            </span><br><span class="line">  <span class="comment"># 项目描述</span></span><br><span class="line">  s.summary      = <span class="string">"A short description of PrivateAdd_v2."</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line">  <span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line">  <span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line">  <span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line">  <span class="comment">#   * Finally, don't worry about the indent, CocoaPods strips it!</span></span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 主页，自动生成的podspec文件中所有的EXAMPLE都需要改</span></span><br><span class="line">  s.homepage     = <span class="string">"http://EXAMPLE/PrivateAdd_v2"</span> </span><br><span class="line">  <span class="comment"># 项目截图</span></span><br><span class="line">  <span class="comment"># s.screenshots  = "www.example.com/screenshots_1.gif", "www.example.com/screenshots_2.gif"  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Licensing your code is important. See http://choosealicense.com for more info.</span></span><br><span class="line">  <span class="comment">#  CocoaPods will detect a license file if there is a named LICENSE*</span></span><br><span class="line">  <span class="comment">#  Popular ones are 'MIT', 'BSD' and 'Apache License, Version 2.0'.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 项目遵守的协议</span></span><br><span class="line">  s.license      = <span class="string">"MIT (example)"</span>      </span><br><span class="line">  <span class="comment"># s.license      = &#123; :type =&gt; "MIT", :file =&gt; "FILE_LICENSE" &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify the authors of the library, with email addresses. Email addresses</span></span><br><span class="line">  <span class="comment">#  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</span></span><br><span class="line">  <span class="comment">#  accepts just a name if you'd rather not provide an email address.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify a social_media_url where others can refer to, for example a twitter</span></span><br><span class="line">  <span class="comment">#  profile URL.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 作者信息</span></span><br><span class="line">  s.author             = &#123; "liujiajia" =&gt; "liujiajia@gerrit.babytree-inc.com" &#125;  </span><br><span class="line">  <span class="comment"># Or just: s.author    = "liujiajia"</span></span><br><span class="line">  <span class="comment"># s.authors            = &#123; "liujiajia" =&gt; "liujiajia@gerrit.babytree-inc.com" &#125;</span></span><br><span class="line">  <span class="comment"># s.social_media_url   = "http://twitter.com/liujiajia"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  If this Pod runs only on iOS or OS X, then specify the platform and</span></span><br><span class="line">  <span class="comment">#  the deployment target. You can optionally include the target after the platform.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.platform     = :ios           # 平台</span></span><br><span class="line">  <span class="comment"># 平台以及版本号</span></span><br><span class="line">  <span class="comment"># s.platform     = :ios, "5.0"    </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  When using multiple platforms</span></span><br><span class="line">  <span class="comment"># s.ios.deployment_target = "5.0"</span></span><br><span class="line">  <span class="comment"># s.osx.deployment_target = "10.7"</span></span><br><span class="line">  <span class="comment"># s.watchos.deployment_target = "2.0"</span></span><br><span class="line">  <span class="comment"># s.tvos.deployment_target = "9.0"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify the location from where the source should be retrieved.</span></span><br><span class="line">  <span class="comment">#  Supports git, hg, bzr, svn and HTTP.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#当前私有库资源的git地址，相应的tag，这里直接使用代码来标识使用和当前tag一样的值</span></span><br><span class="line">  s.source       = &#123; :git =&gt; "http://EXAMPLE/PrivateAdd_v2.git", :tag =&gt; "#&#123;s.version&#125;" &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  CocoaPods is smart about how it includes source code. For source files</span></span><br><span class="line">  <span class="comment">#  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</span></span><br><span class="line">  <span class="comment">#  For header files it will include any header in the folder.</span></span><br><span class="line">  <span class="comment">#  Not including the public_header_files will make all headers public.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 需要引用的文件代码，classes文件夹下的所有.h.m文件。这里的路径都是相对路径</span></span><br><span class="line">  s.source_files  = <span class="string">"Classes"</span>, <span class="string">"Classes/**/*.&#123;h,m&#125;"</span> </span><br><span class="line">  <span class="comment"># 排除掉哪些文件，不被包含的文件，这里是Classes/Exclude文件夹下的所有</span></span><br><span class="line">  s.exclude_files = <span class="string">"Classes/Exclude"</span>   </span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.public_header_files = "Classes/**/*.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  A list of resources included with the Pod. These are copied into the</span></span><br><span class="line">  <span class="comment">#  target bundle with a build phase script. Anything else will be cleaned.</span></span><br><span class="line">  <span class="comment">#  You can preserve files from being cleaned, please don't preserve</span></span><br><span class="line">  <span class="comment">#  non-essential files like tests, examples and documentation.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.resource  = "icon.png"            # 资源文件</span></span><br><span class="line">  <span class="comment"># s.resources = "Resources/*.png"     # 所有资源文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.preserve_paths = "FilesToSave", "MoreFilesToSave"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Link your library with frameworks, or libraries. Libraries do not include</span></span><br><span class="line">  <span class="comment">#  the lib prefix of their name.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.framework  = "UIKit"          # 依赖的系统framework，去掉后缀</span></span><br><span class="line">  <span class="comment"># s.frameworks = "SomeFramework", "AnotherFramework"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.library   = "iconv"                   # 依赖的系统library</span></span><br><span class="line">  <span class="comment"># s.libraries = "iconv", "xml2", "z"      # 依赖的library，去除前缀和后缀，例如“libz.tbd”，则直接引用为"z"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.vendored_frameworks = "*.framework", "*.framework"          #依赖那些静态库</span></span><br><span class="line">  <span class="comment"># s.vendored_libraries = "*.a", "*.a"           # 依赖哪些静态library</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  If your library depends on compiler flags you can set them in the xcconfig hash</span></span><br><span class="line">  <span class="comment">#  where they will only apply to your library. If you depend on other Podspecs</span></span><br><span class="line">  <span class="comment">#  you can include multiple dependencies to ensure it works.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.requires_arc = true       # 是否开启ARC</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.xcconfig = &#123; "GCC_PREPROCESSOR_DEFINITIONS" =&gt; 'HMTIMEINPREGNACYAPP=1', "HEADER_SEARCH_PATHS" =&gt; "$(SDKROOT)/usr/include/libxml2" &#125;  </span></span><br><span class="line">  <span class="comment"># 这里配置一些内容，"GCC_PREPROCESSOR_DEFINITIONS"：定义一个宏，</span></span><br><span class="line">  <span class="comment"># "HEADER_SEARCH_PATHS"：如果引用该私有库，则会在主工程中寻找文件夹下的内容</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.dependency "JSONKit", "~&gt; 1.4"        # 使用了pod，依赖哪些库</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.prefix_header_contents = &lt;&lt;-EOS     #这里会生成一个默认pch文件，作用于Xcode工程中添加的pch文件一样。</span></span><br><span class="line">  <span class="comment">#      #import &lt;UIKit/UIKit.h&gt;</span></span><br><span class="line">  <span class="comment"># EOS</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这里有一个需要注意的地方，在创建私有库的时候，找不到MIT LICENSE证书，这里讲license修改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.license      &#x3D; &#123; :type &#x3D;&gt; &quot;MIT&quot;, :file &#x3D;&gt; &quot;LICENSE&quot; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二级库subspec"><a href="#二级库subspec" class="headerlink" title="二级库subspec"></a>二级库subspec</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.subspec &#39;UIView+Category&#39; do |ss| </span><br><span class="line">  ss.source_files &#x3D; &quot;PrivateAdd_v3&#x2F;PrivateAdd_v3&#x2F;Classes&#x2F;UIView+Category&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line">  ss.framework &#x3D; &quot;UIKit&quot;</span><br><span class="line">  # ss.vendored_libraries &#x3D; &#39;&#x2F;*.a&#39;</span><br><span class="line">  # ss.vendored_frameworks &#x3D; &#39;&#x2F;*.framework&#39;</span><br><span class="line">  # ss.resource &#x3D; &#39;Moments&#x2F;ForPregnacy&#x2F;**&#x2F;*.bundle&#39;, &#39;Moments&#x2F;ForPregnacy&#x2F;**&#x2F;*.png&#39;, &#39;Moments&#x2F;ForPregnacy&#x2F;**&#x2F;*.mp3&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>使用subspec关键字，并添加指定文件就行。</p>
<h2 id="验证私有库"><a href="#验证私有库" class="headerlink" title="验证私有库"></a>验证私有库</h2><p>修改完相应的代码块之后，开始验证私有库配置是否正确。</p>
<h3 id="本地验证"><a href="#本地验证" class="headerlink" title="本地验证"></a>本地验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line">&#x2F;&#x2F; 如果使用了私有库，则使用--sources来标明，给出具体地址</span><br><span class="line">pod lib lint --sources&#x3D;[私有仓库repo地址],[私有库git地址],https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git</span><br></pre></td></tr></table></figure>

<p>如果出现错误，基本上都是podspec文件中的配置出现了问题，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br><span class="line"></span><br><span class="line"> -&gt; PrivateAdd_v2 (0.0.1)</span><br><span class="line">    - WARN  | attributes: Missing required attribute &#96;license&#96;.</span><br><span class="line">    - WARN  | license: Missing license type.</span><br><span class="line">    - ERROR | description: The description is empty.</span><br><span class="line">    - ERROR | [iOS] unknown: Encountered an unknown error (The &#96;PrivateAdd_v2&#96; pod failed to validate due to 1 error:</span><br><span class="line">    - WARN  | attributes: Missing required attribute &#96;license&#96;.</span><br><span class="line">    - WARN  | license: Missing license type.</span><br><span class="line">    - ERROR | description: The description is empty.</span><br><span class="line"></span><br><span class="line">) during validation.</span><br><span class="line"></span><br><span class="line">[!] PrivateAdd_v2 did not pass validation, due to 2 errors and 2 warnings.</span><br><span class="line">You can use the &#96;--no-clean&#96; option to inspect any issue.</span><br></pre></td></tr></table></figure>
<p>这就需要将上面的错误修改掉。</p>
<p>一般情况下出现警告在后面添加<code>pod lib lint --allow-warnings</code>，就可以通过验证了。验证通过会提示passed validation。</p>
<p>如果依赖一些静态库（.framework，.a），则在命令后面添加<code>--use-libraries</code>，表示依赖了静态库。</p>
<p>如果报错不是很明显，这命令后添加<code>--verbose</code>，会输出验证的过程，并给出报错信息。</p>
<h3 id="远端验证"><a href="#远端验证" class="headerlink" title="远端验证"></a>远端验证</h3><p><code>pod spec lint</code>，一般情况下私有库都是存在远程git上的，所以基本上只在第一次验证使用本地验证之后，就可以直接使用远端验证了。<br>但是一般情况下，创建的私有代码库如果是私有的（并不是官方的），这时候，我们在做远端验证时，需要添加代码地址。，不然pod会默认从官方repo查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources&#x3D;[私有仓库repo地址],[私有库git地址],https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者只添加前面两项，最后一项可以忽略</span><br><span class="line">pod spec lint --sources&#x3D;[私有仓库repo地址],[私有库git地址]</span><br></pre></td></tr></table></figure>
<p>如果出现一些警告，可以直接在命令最后添加<code>--allow-warnings</code>来屏蔽警告。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateRepo,https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateAdd_v3.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings</span><br><span class="line"></span><br><span class="line">pod spec lint --sources&#x3D;https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateRepo,https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateAdd_v3.git --allow-warnings</span><br></pre></td></tr></table></figure>

<h2 id="发布私有库"><a href="#发布私有库" class="headerlink" title="发布私有库"></a>发布私有库</h2><p>将podspec文件推送到私有空间repo，在发布时一定要记住，已经做了tag处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [私有仓库repo] [私有库podspec文件地址] --allow-warnings</span><br><span class="line">pod repo push [私有仓库repo] [私有库podspec文件地址] --sources&#x3D;[私有仓库repo地址],[私有库地址],https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateAdd_v2.git --allow-warnings</span><br></pre></td></tr></table></figure>
<p>由于基本上的所有命令操作都是在该私有库文件夹下，所以不用管podspec的文件位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push PrivateRepo PrivateAdd.podspec --allow-warnings</span><br></pre></td></tr></table></figure>

<p>执行该命令时，相当于直接将podspec文件push到repo的Git地址上。</p>
<h2 id="引用私有库"><a href="#引用私有库" class="headerlink" title="引用私有库"></a>引用私有库</h2><h3 id="本地路径引用"><a href="#本地路径引用" class="headerlink" title="本地路径引用"></a>本地路径引用</h3><p>做好验证之后，如果需要测试，可以直接在podfile中引用私有库的本地路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ..&#x2F;是回到上一级文件目录，是以当前podfile所在文件位置决定</span><br><span class="line">pod &#39;Private_v2&#39;, :path &#x3D;&gt; &#39;..&#x2F;..&#x2F;Private_v2&#39;</span><br></pre></td></tr></table></figure>
<p>这个时候如果改动Private_v2中的代码就是直接改动。</p>
<h3 id="repo引用"><a href="#repo引用" class="headerlink" title="repo引用"></a>repo引用</h3><p>在podfile中先添加source，然后直接pod引入，当然在引用私有库的时候，不仅需要需要私有仓库repo的权限，还需要有私有库的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateRepo&#39;</span><br><span class="line"> </span><br><span class="line">pod &#39;Private_v2&#39;</span><br><span class="line"></span><br><span class="line">#或者使用下面的方式</span><br><span class="line">#pod &#39;Private_v2&#39;, :git&#x3D;&gt; &#39;https:&#x2F;&#x2F;gitee.com&#x2F;devAlan&#x2F;PrivateRepo&#39;</span><br></pre></td></tr></table></figure>


<h2 id="pod-常用命令"><a href="#pod-常用命令" class="headerlink" title="pod 常用命令"></a>pod 常用命令</h2><ol>
<li><p>安装podfile中依赖的命令<br><code>pod install</code><br><code>pod update</code><br><code>--no-repo-update</code>   不需要更新repo<br><code>--repo-update</code>   更新repo</p>
</li>
<li><p>repo相关<br><code>pod repo list</code><br><code>pod repo remove xxx</code>   移除一个本地repo<br><code>pod repo add [本地仓库repo名称] [远程repo地址]</code>  远程版本空间添加到本地</p>
</li>
<li><p>私有库创建相关<br><code>pod lib lint</code>      本地验证<br><code>pod spec lint</code>     远程验证<br><code>pod repo push [本地仓库repo] [*.podspec]</code>  发布版本到repo<br><code>--source=[私有repo地址][私有代码库地址][pod地址]</code><br><code>--allow-warnings</code>  忽略warning<br><code>--use-libraries</code>   使用了第三方的framework或者.a文件<br><code>--verbose</code>         打印流程，可以快速定位失败原因</p>
</li>
<li><p>podspec中使用到的*<br><code>/**</code> 子目录下所有文件夹<br><code>/*</code>    目录下所有文件</p>
</li>
</ol>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li><p>私有库依赖主项目中的某些文件，如果是强制性的依赖，导致本地验证和远程验证都无法通过，所以更别说发布了。<br> 这种是没有完全的组件化。我们需要在podspec中添加HEADER_SEARCH_PATHS，添加指定位置文件路径。这里的路径也是相对路径。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.xcconfig &#x3D; &#123; &quot;GCC_PREPROCESSOR_DEFINITIONS&quot; &#x3D;&gt; &#39;HMTIMEINPREGNACYAPP&#x3D;1&#39;, </span><br><span class="line">&quot;HEADER_SEARCH_PATHS&quot; &#x3D;&gt; &quot;$(SRCROOT)&#x2F;usr&#x2F;include&#x2F;libxml2&quot;, $(SRCROOT)&#x2F;..&#x2F;Commen&#x2F;** &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做仍然无法通过验证，这就需要我们将私有空间repo pull到本地，手动创建版本号文件夹添加podspec文件，然后push。</p>
</li>
<li><p>在上面的代码中还有一个 <code>GCC_PREPROCESSOR_DEFINITIONS</code>，这是定义一个宏，可以在Project-Build Settings - Preprocessor Macros下看到。</p>
<p>可以配合一些没有必要引入私有代码库中的文件来使用。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/10/OC%E5%85%B6%E5%AE%83/Cocoapods-can-not-used/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/OC%E5%85%B6%E5%AE%83/Cocoapods-can-not-used/" class="post-title-link" itemprop="url">Mac升级造成cocoapods不可用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-10 17:00:52" itemprop="dateCreated datePublished" datetime="2020-03-10T17:00:52+08:00">2020-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Mac系统升级之后，造成pods不可用，这里找到了解决的方案，前提是已经安装了cocoapods。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo gem update --system</span><br><span class="line">sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods -v1.5.3</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure>

<p>第一步：更新gem。<br>第二步：安装指定的cocoapods版本，我这里指定的是1.5.3<br>第三步：更新pod</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/06/Github-Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/Github-Hexo/" class="post-title-link" itemprop="url">利用Github从零开始搭建Hexo博客，可迁移</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-06 22:07:06" itemprop="dateCreated datePublished" datetime="2020-03-06T22:07:06+08:00">2020-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 10:21:40" itemprop="dateModified" datetime="2021-05-17T10:21:40+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>安装Node.js，安装完成之后可以正常使用npm命令</li>
<li>安装hexo，<code>npm install -g hexo-cli</code></li>
</ol>
<h2 id="创建步奏"><a href="#创建步奏" class="headerlink" title="创建步奏"></a>创建步奏</h2><ol>
<li><p>创建git仓库，这里需要注意一下，GitPage会默认给分配二级域名，但是当仓库名与账号组织名称一样的情况下会省略掉二级域名，所以这里创建的名称为<code>{yourname}.github.io</code>，一定是以<code>github.io</code>结尾的。当然也可以创建其他的。只是在之后的配置上略有不同。</p>
</li>
<li><p>创建仓库时使用readme进行初始化。</p>
</li>
<li><p>同时新建一个hexo分支，并设置为默认分支。</p>
</li>
<li><p>使用<code>hexo init {name}</code>来初始化，或者新建一个<code>{name}</code>文件夹，在该文件夹下，执行<code>hexo init</code>命令是一样的效果。</p>
</li>
<li><p>依次执行</p>
<p> <code>hexo clean</code>：clean<br> <code>hexo g</code>：generate，编译生成HTML代码，放在根目录下的public下。<br> <code>hexo s</code>：serve，提供serve命令把博客在本地运行起来，然后点击给出的链接就可以正常的使用了，如果链接打不开，可能是端口被占用，可以使用<code>hexo s -p 端口号</code>来指定端口号。</p>
</li>
<li><p>我这里是用了一个比较主流的主题<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a>，以此为例，大家喜欢什么主题自己配置就好。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p> 依次执行命令进行配置就好了。随后在根目录下的<code>_config.yml</code>文件里配置： <code>next</code>。</p>
</li>
</ol>
<ol start="7">
<li><p>删除主题下的git。这里有一点要注意的，在remote远程仓库之前，要把<b>themes文件夹</b>拉下来的主题，删除对应的<b>.git</b>文件删除掉。因为外部已经有了git，内部文件夹也有git时会出现问题。</p>
</li>
<li><p>配置根目录下的<code>_config.yml</code>文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 不会飞的小白</span><br><span class="line">subtitle: &#39;Stay Hungry, Stay Foolish&#39;</span><br><span class="line">description: &#39;&#39;</span><br><span class="line">keywords: iOS, Swift, GitHub</span><br><span class="line">author: 不会飞的小白</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#39;&#39;</span><br></pre></td></tr></table></figure>
<p> <b>Site里头的东西，根据自身想法看着写就行。有一个需要注意的是language，它的值是根据对应的Theme中的语言相对应的。</b></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;liujiaboy.github.io&#x2F;</span><br><span class="line">root: &#x2F;</span><br></pre></td></tr></table></figure>

<p> <b>这里也需要注意。如果添加了搜索功能或者没有按照{name}.github.io这种命名方式创建的，这里的是必须要填写的。URL：为Github Page生成后对应的地址。root：为哪一级为根目录。</b></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br><span class="line">#主题</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;liujiaboy&#x2F;liujiaboy.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p> <b>这里是对应的仓库地址，type一定是 git类型，分支可以选择，我这里是master。</b></p>
</li>
<li><p>上面的配置完成之后，再执行<b>步奏5</b>，本地预览没问题后，可以直接走发布。而发布也就是将生成的public文件中的内容push到deploy对应的仓库的分支中。</p>
<p> <code>hexo d</code>:deploy: 发布。<br> 如果出现问题，执行<code>npm install hexo-deployer-git</code>安装git插件。</p>
</li>
<li><p>这个时候，可以在根目录下，remote远程仓库了。</p>
<p><code>git remote add origin &lt;远程版本库URL&gt;</code>。这个时候本地默认就是之前创建的<code>hexo</code>分支。</p>
<p>执行<code>git add .</code>, <code>git commit -m&quot;xxx&quot;</code>之后，在push之前，先把远程分支上的内容pull下来。这个时候执行</p>
<p><code>git pull origin hexo</code></p>
<p>如果出现问题，是因为本地有提交内容无法完成merge操作。将上面的执行命令改为</p>
<p><code>git pull origin hexo --allow-unrelated-histories</code></p>
<p>完成merge操作之后，执行<code>git push origin hexo</code>就可以了。</p>
</li>
</ol>
<p>这个时候就已经完成了整体的库都放在Github上了。默认分支hexo存放所有的数据，master分支存放Github Page需要的数据。这就可以开心的玩耍了，也不用担心换设备迁移带来的问题了。</p>
<h2 id="hexo迁移"><a href="#hexo迁移" class="headerlink" title="hexo迁移"></a>hexo迁移</h2><ol>
<li><p>确保当前设备已经有Node.js, hexo环境。</p>
</li>
<li><p>从远程仓库clone到指定文件夹。</p>
</li>
<li><p>在该文件夹下，执行</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>
<p> 这一步是必须执行的，创建hexo环境，如果在本电脑的环境下已经执行过下面两个命令，就不用重复执行了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p> 这个时候就没必要执行<code>hexo init</code>了，因为当文件夹下有内容的时候跟本执行不了，会报错。</p>
</li>
<li><p>如果是多设备同时开发的话，那就需要用到 <code>git pull origin hexo</code>来拉取最新数据了，但是一般情况下不会出现，毕竟自己的博客不会涉及到多人协作。</p>
</li>
<li><p>就可以开心的玩耍了。</p>
</li>
</ol>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="NexT主题添加theme-next-canvas-nest几何动效"><a href="#NexT主题添加theme-next-canvas-nest几何动效" class="headerlink" title="NexT主题添加theme-next-canvas-nest几何动效"></a>NexT主题添加theme-next-canvas-nest几何动效</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https:<span class="comment">//github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span></span><br></pre></td></tr></table></figure>
<p>完成上诉操作之后，再next配置文件_config.yml中配置开启canvas_nest，如果没有相关配置，直接复制代码粘贴进去就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#39;0,0,255&#39; # RGB values, use &#39;,&#39; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # the number of lines</span><br></pre></td></tr></table></figure>

<h3 id="订阅-rss"><a href="#订阅-rss" class="headerlink" title="订阅 rss"></a>订阅 rss</h3><p>博客一般都需要rss订阅，如果要开启，需要安装一个插件。安装完成会自动生成相关配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>生成的rss对应的文件public/atom.xml</p>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;文章名&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章，使用markdown的格式。在一篇文章的开头，会有如下必要信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 利用Github从零开始搭建Hexo博客，可迁移</span><br><span class="line">date: 2020-03-06 22:07:06</span><br><span class="line">tags:</span><br><span class="line">    - Github</span><br><span class="line">    - hexo</span><br><span class="line"></span><br><span class="line">categories:</span><br><span class="line">    - 杂记</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>其中title， date是必填的，tags就是标签，可选， categories：分类，也是可选。在next主题下，默认会生成目录。</p>
<h3 id="创建标签页-tags"><a href="#创建标签页-tags" class="headerlink" title="创建标签页 tags"></a>创建标签页 tags</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>也会生成类似文章的md文件，可以在头部自行添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2020-03-06 22:07:06</span><br><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>type: 指定为tags<br>comments：是否允许评论</p>
<h3 id="分类页-categories"><a href="#分类页-categories" class="headerlink" title="分类页 categories"></a>分类页 categories</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>指定type：categories</p>
<p>hexo默认会创建<code>archives</code>类型的文件，不会默认创建tags和categories，但是创建完成这两个之后，只需要指定type类型即可，不用在文件中添加其他数据。</p>
<h3 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h3><p>很多情况下需要搜索全站内容，所以有必要支持搜索。需要安装插件支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>很多主题对应的搜索都不一样，但是搜索的插件都是必须的。这里需要修改上面提到的URL并指定root文件路径。</p>
<h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><p>当页面出错的时候，就很有必要的添加一个404的错误页面。直接在根目录下创建一个404.md文件即可。也有会接入腾讯公益404广告的，自行google吧。</p>
<p>这个只针对绑定域名的有效，GitHub默认分配的是没有效果的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404 Not Found</span><br><span class="line">date: 2020-03-06 11:06:55</span><br><span class="line">---</span><br><span class="line">&lt;center&gt;</span><br><span class="line">    对不起，您访问的页面不存在或已被删除</span><br><span class="line">&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure>

<h3 id="创建about"><a href="#创建about" class="headerlink" title="创建about"></a>创建about</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<h3 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h3><ol>
<li><p>绝对路径引用<br> 当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source&#x2F;images&#x2F;image.jpg</span><br><span class="line">&#x2F;&#x2F; 这样就可以了</span><br><span class="line">![](&#x2F;images&#x2F;image.jpg)</span><br></pre></td></tr></table></figure>
</li>
<li><p>相对路径引用<br> 图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p> 修改之后，执行命令<code>$ hexo new post_name</code>，在source/_posts中会生成文章post_name.md的同时，会生成文章同名的文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="1-默认buffer太小，push、pull失败"><a href="#1-默认buffer太小，push、pull失败" class="headerlink" title="1. 默认buffer太小，push、pull失败"></a>1. 默认buffer太小，push、pull失败</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;liujiaboy&#x2F;liujiaboy.github.io.git&#x2F;&#39;: LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.postBuffer 1048576000</span><br></pre></td></tr></table></figure>

<p>这中问题的原因是，大文件造成的，curl的postBuffer默认值太小，增大缓存配置就好了。</p>
<h2 id="Error-Spawn-failed"><a href="#Error-Spawn-failed" class="headerlink" title="Error: Spawn failed"></a>Error: Spawn failed</h2><ol>
<li>删除.deploy_git文件夹;</li>
<li>输入git config –global core.autocrlf false</li>
<li>然后，依次执行：<ol>
<li>hexo clean</li>
<li>hexo g</li>
<li>hexo d</li>
</ol>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感谢大佬们做的总结，不一一列举了。感谢<br><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next: Github</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
