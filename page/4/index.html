<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/page/4/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/25/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-4/" class="post-title-link" itemprop="url">ARM汇编-4 指针</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 23:34:37" itemprop="dateCreated datePublished" datetime="2021-04-25T23:34:37+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h1><blockquote>
<p>指针也就是内存地址，指针变量是用来存放内存地址的变量。不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。<br>可使用 &amp; 运算符访问地址。</p>
</blockquote>
<p>之前的文章中有过说明，指针在内存中占8个字节。<br>可以是用sizeof来打印指针的size。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    a ++;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义一个int类型的指针a，然后赋值位100，我们知道指针的size是8个字节，a++之后打印多少？</p>
<p>答案是104。是的，没有看错，这里是因为指针的自增和自减操作，与执行的数据类型的宽度有关。</p>
<p>如果<code>a = (char *)100</code>,则打印的就是101。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    a &#x3D; a + 1;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个不是指针的自增、自减了，这个时候就跟指针的size有关了，打印108。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func_add() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    </span><br><span class="line">    int *b;</span><br><span class="line">    b &#x3D; (int *)200;</span><br><span class="line">    </span><br><span class="line">    int x &#x3D; a - b;</span><br><span class="line">    printf(&quot;x &#x3D; %d&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先说答案，打印的结果是<code>x = -25</code>。</p>
<p>a - b = -100, 然后除以4就得到了这个结果。</p>
<blockquote>
<p>指针的运算单位是执行的数据类型的宽度。</p>
</blockquote>
<h2 id="1-1-二级指针"><a href="#1-1-二级指针" class="headerlink" title="1.1 二级指针"></a>1.1 二级指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int **a;</span><br><span class="line">    a &#x3D; (int **)100;</span><br><span class="line">    a &#x3D; a + 1;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候a运算时，执行的类型就是 <code>char *</code>类型，这是一个指针，8个字节。所以结果就是108。</p>
<h1 id="2-指针的汇编"><a href="#2-指针的汇编" class="headerlink" title="2. 指针的汇编"></a>2. 指针的汇编</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    int b &#x3D; 10;</span><br><span class="line">    a &#x3D; &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我们正常的理解，上述代码的意思就是把b的地址给到a，这个时候<code>*a=10</code>。</p>
<p>看一下上面的代码汇编之后是什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">    0x100206130 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. x8 &#x3D; sp + 0x4，x8指向这个位置</span><br><span class="line">    0x100206134 &lt;+4&gt;:  add    x8, sp, #0x4              ; &#x3D;0x4 </span><br><span class="line">    &#x2F;&#x2F; 2. 局部变量，w9&#x3D;10</span><br><span class="line">    0x100206138 &lt;+8&gt;:  mov    w9, #0xa</span><br><span class="line">    &#x2F;&#x2F; 3. 把w9的值放在x8所在的地址上。</span><br><span class="line">    0x10020613c &lt;+12&gt;: str    w9, [sp, #0x4]</span><br><span class="line">    &#x2F;&#x2F; 4. 把x8存储的地址放在sp + 0x8的位置上。</span><br><span class="line">-&gt;  0x100206140 &lt;+16&gt;: str    x8, [sp, #0x8]</span><br><span class="line">    0x100206144 &lt;+20&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100206148 &lt;+24&gt;: ret</span><br></pre></td></tr></table></figure>

<p>通过lldb打印一下相关数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read sp</span><br><span class="line">      sp &#x3D; 0x000000016fbff880</span><br><span class="line"></span><br><span class="line">(lldb) register read x8</span><br><span class="line">      x8 &#x3D; 0x000000016fbff884</span><br><span class="line">   </span><br><span class="line">(lldb) register read x9</span><br><span class="line">      x9 &#x3D; 0x000000000000000a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印一下x8寄存器里的内存地址情况，里头存的值是0xa</span><br><span class="line">(lldb) x 0x000000016fbff884</span><br><span class="line">0x16fbff884: 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x16fbff894: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x8的地址放在了sp+0x8的位置，打印一下内存，就是x8存储的地址。</span><br><span class="line">(lldb) x 0x000000016fbff888</span><br><span class="line">0x16fbff888: 84 f8 bf 6f 01 00 00 00 00 00 00 00 00 00 00 00  ...o............</span><br><span class="line">0x16fbff898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>


<h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int arr[5] &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, *(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    char *p;</span><br><span class="line">    char a &#x3D; *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码，我们知道，只是把*p的值给了a<br>为什么会发生野指针呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">    0x100812134 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. 因为p是指针。把sp + 0x8的地址中的值给x8</span><br><span class="line">-&gt;  0x100812138 &lt;+4&gt;:  ldr    x8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 2. 把x8寄存器中存的地址的值给w9</span><br><span class="line">    0x10081213c &lt;+8&gt;:  ldrb   w9, [x8]</span><br><span class="line">    0x100812140 &lt;+12&gt;: strb   w9, [sp, #0x7]</span><br><span class="line">    0x100812144 &lt;+16&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100812148 &lt;+20&gt;: ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步寻址操作，获取x8寄存器的值的地址</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read sp</span><br><span class="line">      sp &#x3D; 0x000000016f5f3880</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sp + 0x8 &#x3D; 0x000000016f5f3888</span><br><span class="line">(lldb) x 0x000000016f5f3888</span><br><span class="line">0x16f5f3888: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x16f5f3898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br><span class="line">(lldb) register read x8</span><br><span class="line">  x8 &#x3D; 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p> 这里发现 x8寄存器中存的地址是空，全是0。</p>
</li>
<li><p>把x8寄存器中地址所在的值给w9。寻址操作<br> 这里寻址是从0x00000000上找值，从空地址上找值，就会发生crash。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/18/OC%E5%8E%9F%E7%90%86/oc-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/OC%E5%8E%9F%E7%90%86/oc-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">3.对象的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 13:39:47" itemprop="dateCreated datePublished" datetime="2021-04-18T13:39:47+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-18 10:12:01" itemprop="dateModified" datetime="2021-06-18T10:12:01+08:00">2021-06-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本篇使用的objc源码版本位818.2</p>
</blockquote>
<h1 id="1-clang介绍"><a href="#1-clang介绍" class="headerlink" title="1. clang介绍"></a>1. clang介绍</h1><p>Clang是一个由Apple主导的使用C++编写、基于LLVM、发布于LLVM BSD许可证下的C/C++/Objective-C/Objective-C++编译器。它与GNU C语言规范几乎完全兼容(当然，也有部分不兼容的内容， 包括编译命令选项也会有点差异)，并在此基础上增加了额外的语法特性，比如C函数重载 (通过<strong>attribute</strong>((overloadable))来修饰函数)，其目标(之一)就是超越GCC。</p>
<p>2013年4月,Clang已经全面支持C++11标准，并开始实现C++1y特性(也就是C++14，这是 C++的下一个小更新版本)。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。 </p>
<h2 id="1-1-clang的简单使用"><a href="#1-1-clang的简单使用" class="headerlink" title="1.1 clang的简单使用"></a>1.1 clang的简单使用</h2><p>我们通常想看代码的内部实现逻辑，通常会把源文件转换成cpp文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li>main.m 目标文件</li>
<li>main.cpp 转换后的文件</li>
</ul>
<h2 id="1-2-UIKit报错问题"><a href="#1-2-UIKit报错问题" class="headerlink" title="1.2 UIKit报错问题"></a>1.2 UIKit报错问题</h2><p>当我们想转化带有UIKit相关的的东西时，上面的命令就会报错了。使用如下命令即可</p>
<p>clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.3.sdk ViewController.m</p>
<p>如果还会报错，多数是因为<code>iPhoneSimulator14.3.sdk</code>没有找到，则通过xcode-contents找到对应的sdk即可。 </p>
<h2 id="1-3-xcrun"><a href="#1-3-xcrun" class="headerlink" title="1.3 xcrun"></a>1.3 xcrun</h2><p>xcode安装的时候顺带安装了<code>xcrun</code>命令，<code>xcrun</code>命令在<code>clang</code>的基础上进行了一些封装，要更好用一些。</p>
<ul>
<li><p>模拟器 - 使用如下命令<br>xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp </p>
</li>
<li><p>真机<br>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp</p>
</li>
</ul>
<h1 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h1><p>在main.m下创建一个Person类，然后通过上面的clang命令，找到我们需要的cpp文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#x2F;&#x2F; 添加一个属性，方便确认这就是我们要找的类</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>转化之后，在cpp文件里，我们找到了如下的结构体。</p>
<h2 id="2-1-类的声明"><a href="#2-1-类的声明" class="headerlink" title="2.1 类的声明"></a>2.1 类的声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @interface Person : NSObject。声明</span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现，一个对象，它本身就是一个结构体，内部有一个变量<code>Class isa</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>

<p>通过objc的源码，我们找到了<code>objc_object</code>的定义，其内部就是一个<code>Class isa</code>。与我们clang编译之后的<code>NSObject_IMPL</code>是一致的。所以<code>NSObject_IVARS</code>就是我们经常说的isa指针。</p>
<p>我们经常使用id类型来声明变量时不用带<code>*</code>，就是因为在底层已经做了处理。</p>
<h2 id="2-2-类的实现"><a href="#2-2-类的实现" class="headerlink" title="2.2 类的实现"></a>2.2 类的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @implementation Person</span><br><span class="line"></span><br><span class="line">static NSString * _I_Person_name(Person * self, SEL _cmd) </span><br><span class="line">&#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Person$_name)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Person_setName_(Person * self, SEL _cmd, NSString *name) </span><br><span class="line">&#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _name), (id)name, 0, 1); &#125;</span><br><span class="line">&#x2F;&#x2F; @end</span><br></pre></td></tr></table></figure>

<p>我们在上面的代码里，看到了两个方法</p>
<ol>
<li><code>_I_Person_name</code>：这是一个get方法，直接做了一个return操作。</li>
<li><code>_I_Person_setName_</code>：这是一个set方法，调用了<code>objc_setProperty</code>。</li>
</ol>
<h3 id="2-2-1-set方法"><a href="#2-2-1-set方法" class="headerlink" title="2.2.1 set方法"></a>2.2.1 set方法</h3><p>通过objc的源码，我们查找<code>objc_setProperty</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) </span><br><span class="line">&#123;</span><br><span class="line">    bool copy &#x3D; (shouldCopy &amp;&amp; shouldCopy !&#x3D; MUTABLE_COPY);</span><br><span class="line">    bool mutableCopy &#x3D; (shouldCopy &#x3D;&#x3D; MUTABLE_COPY);</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部判断是通过copy还是mutableCopy，然后调用<code>reallySetProperty</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot &#x3D;&#x3D; newValue) return;</span><br><span class="line">        newValue &#x3D; objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最主要的操作，就是对oldvalue进行release操作，新值进行retain操作。</p>
<p>这也是经常在面试时，经常会问的，声明一个@property内部有哪些操作的的答案：</p>
<ol>
<li>自动创建带有<code>_</code>的变量。</li>
<li>自动实现set、get方法。</li>
</ol>
<p><img src="set_property.jpg" alt=""></p>
<p>苹果的这种设计思路很值得我们学习。它提供了一个对外的接口供上层调用，其内部调用底层的方法。这样上层无论怎么变化，都不会影响底层接口及实现。</p>
<h1 id="3-isa"><a href="#3-isa" class="headerlink" title="3. isa"></a>3. isa</h1><p>我们应该还记得在【alloc、init、new】这一节中有<code>callAlloc</code>这个方法，这个方法有一步操作是进行对象关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    ASSERT(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就看看这里是怎么搞的。对代码进行了简化，如果有需要请自行查看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    &#x2F;&#x2F; 这个是重点，创建一个isa_t，这个isa_t是啥呢？我们点进去看一下。</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下代码可以等先看我isa_t之后再回过头来看。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对bits内容赋默认值</span><br><span class="line">    newisa.bits &#x3D; ISA_MAGIC_VALUE;      </span><br><span class="line">    &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">    &#x2F;&#x2F; 这里是关联对象，就是本节的重点内容，我们进去看这个setClass是怎么实现的。</span><br><span class="line">    newisa.setClass(cls, this);</span><br><span class="line">    newisa.extra_rc &#x3D; 1;</span><br><span class="line">    isa &#x3D; newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先看下isa_t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">private: &#x2F;&#x2F;这是个私有的，不会主动赋值，而是通过赋值别的变量(bits)时给的。</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    void setClass(Class cls, objc_object *obj);</span><br><span class="line">    Class getClass(bool authenticated);</span><br><span class="line">    Class getDecodedClass(bool authenticated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码做了精简处理，看起来会容易点，这个其实就是一个<b>【联合位域】</b>。<br>union是联合体。里面有一个struct。这种方式就是为了优化内存空间，在极少的内存情况下，来使用。举个例子来看一下：</p>
<p>如果我们需要声明一个car的类，定义4个属性，前后左右行驶。如果是int类型的数据，那就是需要4 * 4 = 16个字节的空间，也就是128位。但是如果使用联合位域的话，就可以极大的减少空间。只需要4位就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union car &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        char forward;   &#x2F;&#x2F;1</span><br><span class="line">        char back;      &#x2F;&#x2F;1</span><br><span class="line">        char left;      &#x2F;&#x2F;1</span><br><span class="line">        char right;     &#x2F;&#x2F;1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是<code>0000</code>，第一个0代表的是前，第二个0代表后，依次类推。</p>
<p>知道了联合位域的大概情况，我们就看一下这个<code>ISA_BITFIELD</code>是个什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">        uintptr_t magic             : 6;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t unused            : 1;                                       \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">#     define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#     define RC_HALF  (1ULL&lt;&lt;18)</span><br></pre></td></tr></table></figure>

<p><img src="isa_t.jpg" alt=""></p>
<p>注意：这个是ARM64下的存储，而使用（非M1芯片）电脑本地运行的的都是基于x86_64的，所以这里面的值存储的位置是有些变化的。</p>
<p>特别提一下shiftcls，在ARM64下是33位，在x86下是44位，导致magic开始的位置分别是36和47，这个位置一会有用到。</p>
<ul>
<li>nonpointer:表示是否对 isa 指针开启指针优化 0:纯isa指针，1:不止是类对象地址,isa 中包含了类信息、对象的引用计数等，在iOS中，正常情况下生成的对象nonpointer都等于1。</li>
<li>has_assoc:关联对象标志位，0没有，1存在</li>
<li>has_cxx_dtor:该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象。oc中的<code>dealloc</code></li>
<li>shiftcls:存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li>
<li>magic:用于调试器判断当前对象是真的对象还是没有初始化的空</li>
<li>weakly_referenced:志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。 </li>
<li>unsed:不同版本的是<code>deallocating</code>，标志对象是否正在释放内存</li>
<li>has_sidetable_rc:当对象引用技术大于 10 时，则需要借用该变量存储进位</li>
<li>extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li>
</ul>
<p>我们了解了isa是啥东西了之后，在回过头看看是怎么进行管理对象的。了解上面的代码之后，我们继续看setCalss是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对代码进行了简化，</span><br><span class="line">inline void</span><br><span class="line">isa_t::setClass(Class newCls, UNUSED_WITHOUT_PTRAUTH objc_object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    shiftcls &#x3D; (uintptr_t)newCls &gt;&gt; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很不可思议，只是通过newCls向右偏移了3位。为啥偏移3位？<br>我们知道isa-&gt;shiftcls存储类指针的值。是从isa的内存里面第3位开始的。就这么简单。因为在内存里没有办法直接存储类名，所以通过存储数字替带。</p>
<h2 id="3-1-验证isa指针的关联过程"><a href="#3-1-验证isa指针的关联过程" class="headerlink" title="3.1 验证isa指针的关联过程"></a>3.1 验证isa指针的关联过程</h2><p><code>Person *p = [[Person alloc] init];</code> 运行objc源码工程。<br>断点进入<code>objc_object::initIsa</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    &#x2F;&#x2F; ① 创建newisa</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ② 对bits内容赋默认值</span><br><span class="line">    newisa.bits &#x3D; ISA_MAGIC_VALUE;      </span><br><span class="line">    &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; ③ </span><br><span class="line">    newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">    &#x2F;&#x2F; ④ 这里是关联对象，就是本节的重点内容，我们进去看这个setClass是怎么实现的。</span><br><span class="line">    newisa.setClass(cls, this);</span><br><span class="line">    newisa.extra_rc &#x3D; 1;</span><br><span class="line">    isa &#x3D; newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当断点走到②的时候。我们输出一些newisa的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p newisa</span><br><span class="line">(isa_t) $1 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 0</span><br><span class="line">  cls &#x3D; nil</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 0</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 0</span><br><span class="line">    magic &#x3D; 0</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续执行下一步，仍然输出newisa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p newisa</span><br><span class="line">(isa_t) $5 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 8303511812964353</span><br><span class="line">  cls &#x3D; 0x001d800000000001</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 1</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 0</span><br><span class="line">    magic &#x3D; 59</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有了变化，bits有初值了，cls也被赋值了，而且magic也被赋值了。这些都是默认值，我们上面说了isa的内部是64位的数据。我们把cls的值，放在二进制的计算器里，看看是什么内容。第一位1对应的是nonpointer=1</p>
<p><img src="magic_47.png" alt=""></p>
<p>看这个图，第47位开始的6位数据是110111，这个二进制数是什么？正好是59。</p>
<p>之后，继续断点下一步。走到④。然后进到setClass方法内部，我们执行语句，看看cls偏移后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (uintptr_t)newCls</span><br><span class="line">(uintptr_t) $15 &#x3D; 4295000320</span><br><span class="line">(lldb) po (uintptr_t)newCls &gt;&gt; 3</span><br><span class="line">536875040</span><br></pre></td></tr></table></figure>

<p>然后继续下一步，打印newisa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lldb) p newisa</span><br><span class="line">(isa_t) $11 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 8303516107964673</span><br><span class="line">  cls &#x3D; Person</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 1</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 536875040</span><br><span class="line">    magic &#x3D; 59</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯哼。。。。。是不是，就是这么牛。shiftcls是啥，存储类指针的值。也验证了我们上面说的，是从isa的内存里面第3位开始的。就这么简单。因为在内存里没有办法直接存储类名，所以通过存储数字替带。</p>
<p>我们继续执行，返回到<code>_class_createInstanceFromZone</code>这个函数里，<br>然后先停一停哈，不要走断点了哈~我们来通过<code>object_getClass</code>在来验证一下。</p>
<h2 id="3-2-反向验证-ISA-MASK"><a href="#3-2-反向验证-ISA-MASK" class="headerlink" title="3.2 反向验证 ISA_MASK"></a>3.2 反向验证 ISA_MASK</h2><p>我们通过object_getClass来反向验证isa指向。这里全部对代码进行了简化。如有需要请自行查看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">objc_object::getIsa() </span><br><span class="line">&#123;</span><br><span class="line">    if (fastpath(!isTaggedPointer())) return ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">objc_object::ISA(bool authenticated)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return isa.getDecodedClass(authenticated);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">isa_t::getClass(MAYBE_UNUSED_AUTHENTICATED_PARAM bool authenticated) &#123;</span><br><span class="line">    uintptr_t clsbits &#x3D; bits;</span><br><span class="line">    clsbits &amp;&#x3D; ISA_MASK;</span><br><span class="line">    return (Class)clsbits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到了结果了，最后就是通过<code>bits &amp; ISA_MASK</code>来返回当前class的。还记得bits是啥吗？往上翻一下，bits是isa指针内部的第一个元素。所以我们按照这个&amp;运算来验证一些，返回的数据是不是person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx obj</span><br><span class="line">0x10060d9b0: 0x011d800100008101 0x0000000000000000</span><br><span class="line">0x10060d9c0: 0x0000000000000000 0x86c8f7c495bce30f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿第一位的地址进行&amp;运算，注意这里是在mac上，所以使用x86下的ISA_MASK值</span><br><span class="line">(lldb) po 0x011d800100008101 &amp; 0x00007ffffffffff8ULL</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>以上就是isa的全部内容了。但是isa里面的这些东西是真的有用吗？肯定是有用的啊，我们从dealloc的函数实现去找到蛛丝马迹。</p>
<h1 id="4-补充-dealloc"><a href="#4-补充-dealloc" class="headerlink" title="4.补充 dealloc"></a>4.补充 dealloc</h1><p>在objc源码中找到dealloc的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，见证奇迹的时候到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  &#x2F;&#x2F; fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer                     &amp;&amp;</span><br><span class="line">         !isa.weakly_referenced             &amp;&amp;</span><br><span class="line">         !isa.has_assoc                     &amp;&amp;</span><br><span class="line">#if ISA_HAS_CXX_DTOR_BIT</span><br><span class="line">         !isa.has_cxx_dtor                  &amp;&amp;</span><br><span class="line">#else</span><br><span class="line">         !isa.getClass(false)-&gt;hasCxxDtor() &amp;&amp;</span><br><span class="line">#endif</span><br><span class="line">         !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>objc_object::rootDealloc</code>中对isa的各个属性的值来判断是执行<code>free</code>操作或者<code>object_dispose</code>。free函数就不用多说了，来看看dispose操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是整个的dealloc的流程。通过源码只是来加深对这些流程的印象。<br>到这里，对象的alloc、init、dealloc都已经出现了，接下来就是类相关了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">oc-2-内存对齐</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 18:34:07" itemprop="dateCreated datePublished" datetime="2021-04-17T18:34:07+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 11:47:21" itemprop="dateModified" datetime="2021-06-09T11:47:21+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h1><p>在上一节中，我们知道开辟空间会用到<code>calloc</code>这个函数，那我们就追一下这个函数的内部逻辑。</p>
<p>但是发现<code>calloc</code>这个方法没有办法继续下一步追踪了，如图：</p>
<p><img src="calloc-1.jpg" alt=""></p>
<p>我们发现<code>calloc</code>定义在<code>malloc/_malloc.h</code>文件下，我们也找到了对应的<a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">源码</a>。我这里用的是一份可运行的源码。</p>
<p>接下来，直接上代码，在main函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 开辟40个字节的空间</span><br><span class="line">void *p &#x3D; calloc(1, 40);</span><br><span class="line">NSLog(@&quot;%lu&quot;,malloc_size(p));</span><br></pre></td></tr></table></figure>

<p>直接运行，查看<code>malloc.c -&gt; calloc</code>的内部实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">calloc(size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	return _malloc_zone_calloc(default_zone, num_items, size, MZ_POSIX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>calloc</code>只是调用了<code>_malloc_zone_calloc</code>方法，其它啥也没做，这里需要注意的是，<code>default_zone</code>参数，它是一个虚拟的默认zone，通过它可以做一些事情，如下：</p>
<h2 id="malloc-zone-calloc"><a href="#malloc-zone-calloc" class="headerlink" title="_malloc_zone_calloc"></a>_malloc_zone_calloc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size,</span><br><span class="line">		malloc_zone_options_t mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	if (malloc_check_start) &#123;</span><br><span class="line">		internal_check();</span><br><span class="line">	&#125;</span><br><span class="line">	ptr &#x3D; zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line">	if (os_unlikely(malloc_logger)) &#123;</span><br><span class="line">		malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,</span><br><span class="line">				(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);</span><br><span class="line">	if (os_unlikely(ptr &#x3D;&#x3D; NULL)) &#123;</span><br><span class="line">		malloc_set_errno_fast(mzo, ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>calloc</code>直接调用的是<code>_malloc_zone_calloc</code>。我们看一下这个函数的实现。通过返回值，我们确定重点代码应该与<code>ptr</code>有关。所以<code>_malloc_zone_calloc</code>精简如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size,</span><br><span class="line">		malloc_zone_options_t mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	&#x2F;&#x2F; ptr初始化，这里打一个断点</span><br><span class="line">	ptr &#x3D; zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行到这里，发现<code>zone-&gt;calloc</code>进去是一个函数的声明，有没有下文了。这是，我们用lldb调试，打印一下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p zone-&gt;calloc</span><br><span class="line">(void *(*)(_malloc_zone_t *, size_t, size_t)) $0 &#x3D; 0x00000001002f4b93 (.dylib&#96;default_zone_calloc at malloc.c:385)</span><br></pre></td></tr></table></figure>

<p>感觉发现了新大陆：<code>default_zone_calloc</code>在<code>malloc.c</code>文件的第385行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	zone &#x3D; runtime_default_zone();</span><br><span class="line">	</span><br><span class="line">	return zone-&gt;calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，又有一个<code>zone</code>。这个才是创建的runtime时的default zone。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_NOEXPORT malloc_zone_t* lite_zone &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">MALLOC_ALWAYS_INLINE</span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">runtime_default_zone() &#123;</span><br><span class="line">  &#x2F;&#x2F; lite_zone &#x3D; null，所以会执行创建</span><br><span class="line">	return (lite_zone) ? lite_zone : inline_malloc_default_zone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⬇️</span><br><span class="line"></span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">inline_malloc_default_zone(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 只创建一次，内部是一个os_once</span><br><span class="line">    _malloc_initialize_once();</span><br><span class="line">    &#x2F;&#x2F; malloc_report(ASL_LEVEL_INFO, &quot;In inline_malloc_default_zone with %d %d\n&quot;, malloc_num_zones, malloc_has_debug_zone);</span><br><span class="line">    &#x2F;&#x2F; 可以看到malloc_zones是一个(malloc_zone_t **)类型的数据</span><br><span class="line">    &#x2F;&#x2F; malloc_zone_t **malloc_zones &#x3D; (malloc_zone_t **)0xdeaddeaddeaddead;</span><br><span class="line">    return malloc_zones[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看一下<code>malloc_zones</code>的内容：</p>
<p><img src="malloc_zones.png" alt=""></p>
<h2 id="malloc-zone-t"><a href="#malloc-zone-t" class="headerlink" title="_malloc_zone_t"></a>_malloc_zone_t</h2><p>上面的大部分内容都是围绕着<code>_malloc_zone_t</code>展开的。</p>
<p>这里可以看到<code>malloc_zones[0]</code>的元素就是一个<code>malloc_zone_t *</code>类型的数据，根据lldb打印出来的数据和查看到的内容可以看到<code>malloc_zone_t</code>中存放的就是一些我们在开辟空间时需要调用的方法。</p>
<p>看一下<code>_malloc_zone_t</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define MALLOC_ZONE_FN_PTR(fn) fn</span><br><span class="line"></span><br><span class="line">typedef struct _malloc_zone_t &#123;</span><br><span class="line">    &#x2F;* Only zone implementors should depend on the layout of this structure;</span><br><span class="line">    Regular callers should use the access functions below *&#x2F;</span><br><span class="line">    void	*reserved1;	&#x2F;* RESERVED FOR CFAllocator DO NOT USE *&#x2F;</span><br><span class="line">    void	*reserved2;	&#x2F;* RESERVED FOR CFAllocator DO NOT USE *&#x2F;</span><br><span class="line">    size_t 	(* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); </span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);</span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); </span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); &#x2F;* same as malloc, but block returned is set to zero and is guaranteed to be page aligned *&#x2F;</span><br><span class="line">    void 	(* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);</span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);</span><br><span class="line">    void 	(* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone);</span><br><span class="line">    const char	*zone_name;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);</span><br><span class="line">&#125; malloc_zone_t;</span><br></pre></td></tr></table></figure>

<p>结构体中的数据与我们图片上的内容是一样的，定义了很多的方法。以<code>calloc</code>为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void 	*(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size);</span><br><span class="line"></span><br><span class="line">转换之后的方法为：</span><br><span class="line"></span><br><span class="line">calloc(_malloc_zone_t *zone, size_tnum_items, size_t size) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用.dylib中的方法，nano_malloc.c : 878</span><br><span class="line">    nano_calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用同样的方式打印一下看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po zone-&gt;calloc</span><br><span class="line">(.dylib&#96;nano_calloc at nano_malloc.c:878)</span><br></pre></td></tr></table></figure>

<p>打印出来的信息已经很全面了，同样告诉我们了<code>nano_calloc</code>方法在<code>nano_malloc.c</code>文件中。</p>
<h2 id="nano-calloc"><a href="#nano-calloc" class="headerlink" title="nano_calloc"></a>nano_calloc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	size_t total_bytes;</span><br><span class="line">   &#x2F;&#x2F; alloc之前需要先判断申请的空间大小是否合理</span><br><span class="line">	if (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果获取到的大小在系统约定的最大值范围内则，直接进行malloc。</span><br><span class="line">	if (total_bytes &lt;&#x3D; NANO_MAX_SIZE) &#123;</span><br><span class="line">	   &#x2F;&#x2F; 所以一定会走这里</span><br><span class="line">		void *p &#x3D; _nano_malloc_check_clear(nanozone, total_bytes, 1);</span><br><span class="line">		if (p) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;* FALLTHROUGH to helper zone *&#x2F;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_zone_t *zone &#x3D; (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line">	&#x2F;&#x2F; 如果初始化失败，则继续执行。</span><br><span class="line">	return zone-&gt;calloc(zone, 1, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>nano_calloc</code>中，我们同样的先看返回值，最底部的是又继续调用了<code>zone-&gt;calloc</code>，感觉不太对，上面就找到了还有一个返回<code>p</code>的位置。运行也确实会走到这里。</p>
<p>接下来就是重点了哈~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	size_t slot_key;   &#x2F;&#x2F; 插槽的key</span><br><span class="line">	&#x2F;&#x2F; 获取真正的内存大小，以及slot_key</span><br><span class="line">	size_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key); &#x2F;&#x2F; Note slot_key is set here</span><br><span class="line">	&#x2F;&#x2F; 拿到插槽的index</span><br><span class="line">	mag_index_t mag_index &#x3D; nano_mag_index(nanozone);</span><br><span class="line">  &#x2F;&#x2F;  </span><br><span class="line">	nano_meta_admin_t pMeta &#x3D; &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line"></span><br><span class="line">	ptr &#x3D; OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));</span><br><span class="line">	if (ptr) &#123;</span><br><span class="line">		&#x2F;&#x2F; 这里都是error的判断</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	   &#x2F;&#x2F; 死循环获取内存指针，拿到返回</span><br><span class="line">		ptr &#x3D; segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (cleared_requested &amp;&amp; ptr) &#123;</span><br><span class="line">		memset(ptr, 0, slot_bytes); &#x2F;&#x2F; TODO: Needs a memory barrier after memset to ensure zeroes land first?</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来看一下开辟空间的算法：segregated_size_to_fit</p>
<h2 id="segregated-size-to-fit"><a href="#segregated-size-to-fit" class="headerlink" title="segregated_size_to_fit"></a>segregated_size_to_fit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static MALLOC_INLINE size_t</span><br><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span><br><span class="line">&#123;</span><br><span class="line">	size_t k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	if (0 &#x3D;&#x3D; size) &#123;</span><br><span class="line">		size &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior</span><br><span class="line">	&#125;</span><br><span class="line">	k &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta</span><br><span class="line">	slot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;							&#x2F;&#x2F; multiply by power of two quanta size</span><br><span class="line">	*pKey &#x3D; k - 1;													&#x2F;&#x2F; Zero-based!</span><br><span class="line"></span><br><span class="line">	return slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法在上一节中计算<code>alignedInstanceSize</code>类似。这里的主要逻辑是先右移4位，再左移4位。相当于把后4位抹零。拿我们开辟空间传进来的40为例计算一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(size + NANO_REGIME_QUANTA_SIZE - 1) &#x3D; 40 + 15 -1</span><br><span class="line">54 -&gt; 0011 0110</span><br><span class="line">&gt;&gt; 4  0000 0011         &#x2F;&#x2F; 右移4位</span><br><span class="line">&lt;&lt; 4  0011 0000 &#x3D; 48    &#x2F;&#x2F; 左移4位</span><br></pre></td></tr></table></figure>

<p>这里计算出来的大小就是48。而<code>slot_key=47</code>。之后就是获取内存指针。</p>
<p><img src="calloc-2.jpg" alt=""></p>
<p>这就是<code>calloc</code>的流程，同时，再一次验证了，iOS在内存中是16字节对齐。</p>
<h1 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h1><p>结构体内存对齐3打原则：</p>
<blockquote>
<ol>
<li>数据成员对⻬规则：结构体(struct)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始(比如int为4字节,则要从4的整数倍地址开始存储。</li>
<li>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a里存有struct b，b里有char，int, double等元素，那b应该从8的整数倍开始存储)</li>
<li>收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍。不足的要补⻬。</li>
</ol>
</blockquote>
<p>开始代码之前，先了解一下各种数据类型所占的内存大小：</p>
<p><img src="calloc-3.jpg" alt=""></p>
<p>接下来上代码，看看结构体的内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   </span><br><span class="line">    char b;     </span><br><span class="line">    int c;      </span><br><span class="line">    short d;    </span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a; </span><br><span class="line">    int b;    </span><br><span class="line">    char c;   </span><br><span class="line">    short d;  </span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str1 &#x3D; %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>输出的结果很明白的哈。<code>str1 = 24, str2-16</code></p>
<p>我们分析一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F; 8 (0-7)</span><br><span class="line">    char b;     &#x2F;&#x2F; 1 [8 1] (8)</span><br><span class="line">    int c;      &#x2F;&#x2F; 4 [9 10 11 12] 9不是4的整数倍(12 13 14 15)</span><br><span class="line">    short d;    &#x2F;&#x2F; 2 [16 17]</span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部需要的大小为: 17</span><br><span class="line">&#x2F;&#x2F; 最大属性 : 8</span><br><span class="line">&#x2F;&#x2F; 结构体整数倍: 24</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F;8 (0-7)</span><br><span class="line">    int b;      &#x2F;&#x2F;4 (8 9 10 11)</span><br><span class="line">    char c;     &#x2F;&#x2F;1 (12)</span><br><span class="line">    short d;    &#x2F;&#x2F;2 (13 14) 13不是2的整数倍，从14开始(14 15)</span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部需要的大小为: 15</span><br><span class="line">&#x2F;&#x2F; 最大属性 : 8</span><br><span class="line">&#x2F;&#x2F; 结构体整数倍: 16</span><br><span class="line">NSLog(@&quot;str1 &#x3D; %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>如果结构体内部套用结构体呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Struct3 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F;8 (0-7)</span><br><span class="line">    int b;      &#x2F;&#x2F;4 (8 9 10 11)</span><br><span class="line">    char c;     &#x2F;&#x2F;1 (12)</span><br><span class="line">    struct Struct2 str_2;   &#x2F;&#x2F; 13 14 15 (16 - 31)</span><br><span class="line">&#125;str3;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str3 &#x3D; %lu&quot;, sizeof(str3));</span><br></pre></td></tr></table></figure>

<p>按照内存对齐第二条原则，结构体成员从其内部最大成员的size的整数倍开始。c的位置是12，接下来的位置是13，不满足8的整数倍。所以按照原则，前面补齐，从16位开始。所以str3结构体的大小为32。</p>
<h1 id="对象的内存对齐"><a href="#对象的内存对齐" class="headerlink" title="对象的内存对齐"></a>对象的内存对齐</h1><p>老样子，先看代码哈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int score;</span><br><span class="line">@property (nonatomic, assign) long height;</span><br><span class="line">@property (nonatomic) char c1;</span><br><span class="line">@property (nonatomic) char c2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">Person *person &#x3D; [Person alloc];</span><br><span class="line">person.name &#x3D; @&quot;name&quot;;</span><br><span class="line">person.age &#x3D; 18;</span><br><span class="line">person.score &#x3D; 20;</span><br><span class="line">person.height &#x3D; 180;</span><br><span class="line">person.c1 &#x3D; &#39;a&#39;;</span><br><span class="line">person.c2 &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,person,sizeof(person),class_getInstanceSize([Person class]),malloc_size((__bridge const void *)(person)));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在NSLog上打个断点。有时间的话，可以把属性先注释掉，从0开始，一个属性一个属性的加起来看输出的是什么结果。</p>
<ol>
<li><p>po 这里直接输出person指向的对象的内存地址。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po person</span><br><span class="line">&lt;Person: 0x600002adbcf0&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里有一个需要介绍的点，上一章中有用到x person命令，输出的内容与<code>View Memory</code>中显示的是一致的。而<code>x/8gx</code>就是进行排序。8代表的是输出8组内存。如果是4那就是输出4组内容。每一块都是8个字节。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8gx person</span><br><span class="line">0x600002adbcf0: 0x0000000103930808 0x0000001200006261</span><br><span class="line">0x600002adbd00: 0x0000000000000014 0x000000010392b038</span><br><span class="line">0x600002adbd10: 0x00000000000000b4 0x0000000000000000</span><br><span class="line">0x600002adbd20: 0x0000c1c5c19bbd20 0x00000000000007fb</span><br></pre></td></tr></table></figure>
<p> 0x600002adbcf0：是person指向的首地址。后面存放的都是属性的值。内存都是连续的。</p>
</li>
<li><p>我们分别输出内存里的内容。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0000000103930808</span><br><span class="line">Person  &#x2F;&#x2F; isa指针</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000012</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">(lldb) 0x61是十进制的97 -&gt; a</span><br><span class="line"></span><br><span class="line">(lldb) po 0x0000000000000014</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">(lldb) po 0x000000010392b038</span><br><span class="line">name</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000000000000b4</span><br><span class="line">180</span><br></pre></td></tr></table></figure>

<p> 0x0000001200006261：这一块地址上内容是被拆开的。我们知道int是4个字节，char是1个字节，所以前面的几位是int的值，后面的再进行拆分，分别是两个char类型的数据。</p>
<p> 苹果在内存上也是做了足够多的优化，虽然在内存上是16个字节对齐的，以空间换时间，提高读取效率，但是在内部实现上，还是进行了大量的优化，这样做的目的是最大限度的节约内存同时保证数据的安全性，但是一定要注意的是，属性是按8个字节对齐的。</p>
<p> 但是为啥两个int类型的数据没有放在一起呢？可能是系统内部做的优化，可以试一下，把所有的char类型注释掉，两个int类型的数据就会存放在一起。可能是会将char类型的数据优先进行填充吧。另外可以多试一下，3个char类型的会怎么样，等等…</p>
</li>
<li><p>最后输出的结果是</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600002adbcf0&gt; - 8 - 40 - 48</span><br></pre></td></tr></table></figure>
<p> 我们分析一下输出的内容：</p>
<ul>
<li>person：当前的类对象，存放的指针，指向的内存地址。</li>
<li>sizeof(person)：person存放的就是一个指针，8个字节。</li>
<li>class_getInstanceSize([Person class])：这个类真正需要的空间。属性是8个字节对齐的。</li>
<li>malloc_size((__bridge const void *)(person))：内存中需要开辟的空间。内存空间是16个字节对齐的。</li>
</ul>
</li>
</ol>
<h2 id="float、double"><a href="#float、double" class="headerlink" title="float、double"></a>float、double</h2><p>加如改变其中的一个属性位double类型的，又会是什么情况呢？我这里把上面的height改为了double类型。看一下输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8gx person</span><br><span class="line">0x600000045530: 0x000000010626d808 0x0000001200006261</span><br><span class="line">0x600000045540: 0x0000000000000014 0x0000000106268038</span><br><span class="line">0x600000045550: 0x4066800000000000 0x0000000000000000</span><br><span class="line">0x600000045560: 0x0000000000000000 0x0000000000000000</span><br><span class="line">(lldb) po 0x4066800000000000</span><br><span class="line">4640537203540230144</span><br></pre></td></tr></table></figure>

<p>诶<del>~</del> 怎么没有输出180呢？是因为对于float、double类型的数据，系统会做一次特殊的转换处理。我们没有办法直接从内存中读出double类型的值。</p>
<p>但是我们可以通过转化double类型的数据来看是否位上面对应的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x (double)180.0</span><br><span class="line">(double) $4 &#x3D; 0x4066800000000000</span><br></pre></td></tr></table></figure>
<p>转换后，发现正好是对应的数据。</p>
<p>这里当然有读取浮点数的方法<code>p/f [0x000000123]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;f 0x4066800000000000</span><br><span class="line">(long) $5 &#x3D; 180</span><br></pre></td></tr></table></figure>

<p>这就是内存补齐的内容</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>calloc的流程。</li>
<li>结构体的对齐规则。</li>
<li>类对象的属性是8个字节对齐的，但是在内存空间是16个字节对齐。</li>
<li>x/4gx的使用</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">libmalloc源码</a><br><a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">苹果更多源码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-1-alloc-init-new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-1-alloc-init-new/" class="post-title-link" itemprop="url">OC-1-alloc、init、new</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 09:20:25" itemprop="dateCreated datePublished" datetime="2021-04-17T09:20:25+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 10:10:02" itemprop="dateModified" datetime="2021-06-09T10:10:02+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-先看一个问题"><a href="#1-先看一个问题" class="headerlink" title="1. 先看一个问题"></a>1. 先看一个问题</h1><p>我们先看一段代码，打印一下输出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 &#x3D; [Person alloc];</span><br><span class="line">Person *p2 &#x3D; [p1 init];</span><br><span class="line">Person *p3 &#x3D; [p1 init];</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p1,p1,&amp;p1);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p2,p2,&amp;p2);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p3,p3,&amp;p3);</span><br></pre></td></tr></table></figure>

<p>看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114068</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114060</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114058</span><br></pre></td></tr></table></figure>

<p>前两个打印的都是当前对象的指针地址，而最后一个为啥会不一样？<br>首先需要明白p和&amp;p的区别：p是当前变量指向的地址。&amp;p是存放当前变量所在的地址。<br>这里第一个%p打印就是[Person alloc]生成的地址。第二个%p是存放的是指向【生成的对象】的地址。</p>
<p>也就是当前alloc生成一个对象开辟了一块内存空间。p1、p2、p3分别开辟一块地址指向alloc开辟的空间。</p>
<p><img src="oc-address.png" alt=""></p>
<p>我们可以通过汇编模式或者符号断点查看源码所在的位置。这里不细说了，比较简单。最后定位的源码位置在<code>libobjc.A.dylib-&gt;objc_init</code>。</p>
<h1 id="2-alloc的执行过程"><a href="#2-alloc的执行过程" class="headerlink" title="2. alloc的执行过程"></a>2. alloc的执行过程</h1><p>那我们接下来要看alloc是怎么执行的。需要看objc的源码。<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4源码</a>是可以直接下载的。我们这里用的是最新的818.2版本的。</p>
<p>通过一系列风骚的操作，我们让源码可以运行起来。通过断点和源码我们分析一下alloc的执行过程。</p>
<h2 id="2-1-objc-rootAlloc"><a href="#2-1-objc-rootAlloc" class="headerlink" title="2.1 _objc_rootAlloc"></a>2.1 _objc_rootAlloc</h2><p>在main.m中，创建一个对象，打上断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p &#x3D; [Person alloc];</span><br><span class="line">Person *p1 &#x3D; [p init];</span><br></pre></td></tr></table></figure>

<p>这里只是alloc的最基本的方法。没有什么代码量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-callAlloc"><a href="#2-2-callAlloc" class="headerlink" title="2.2 callAlloc"></a>2.2 callAlloc</h2><p>这里是核心代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__ &#x2F;&#x2F; 是个宏定义</span><br><span class="line">    &#x2F;&#x2F; slowpath表示括号内的条件可能性教小</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    &#x2F;&#x2F; fastpath表示括号内的条件可能性教大</span><br><span class="line">    &#x2F;&#x2F; 如果有自定义的allocWithZone（hasCustomAWZ）</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);   &#x2F;&#x2F; 1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available. 根据传进来的参数判断</span><br><span class="line">    if (allocWithZone) &#123;                            &#x2F;&#x2F; 2. </span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); &#x2F;&#x2F; 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>该处内容是现阶段alloc执行的代码</li>
<li>根据<code>callAlloc</code>调用传进来的参数判断，基本都会执行【1】。</li>
<li>通过消息发送，执行<code>alloc</code>，这里有个很有意思的点，源码跑起来就能知道。</li>
</ol>
<h2 id="2-3-objc-rootAllocWithZone"><a href="#2-3-objc-rootAllocWithZone" class="headerlink" title="2.3 _objc_rootAllocWithZone"></a>2.3 _objc_rootAllocWithZone</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-class-createInstanceFromZone"><a href="#2-4-class-createInstanceFromZone" class="headerlink" title="2.4 _class_createInstanceFromZone"></a>2.4 _class_createInstanceFromZone</h2><p>这里是重中之重。alloc的流程都在这里完美的展示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 既然要生成一个对象，首先要做的就是开辟空间，但是要开辟多少？</span><br><span class="line">    &#x2F;&#x2F; 由对象的ivars决定。在iOS中，字节是8自己对齐，而内存是16字节对齐，所以小于16字节会补齐</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 2. 算出来需要多少空间，这里进行开辟</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 极少数情况下，obj会创建失败</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3. 空间有了，这里进行对象关联</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-cls-gt-instanceSize"><a href="#2-4-1-cls-gt-instanceSize" class="headerlink" title="2.4.1 cls-&gt;instanceSize"></a>2.4.1 cls-&gt;instanceSize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    &#x2F;&#x2F; 有缓存的情况下</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 新开辟</span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果有缓存的情况下，则会执行fastInstanceSize。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t fastInstanceSize(size_t extra) const</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(hasFastInstanceSize(extra));</span><br><span class="line"></span><br><span class="line">    if (__builtin_constant_p(extra) &amp;&amp; extra &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return _flags &amp; FAST_CACHE_ALLOC_MASK16;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        size_t size &#x3D; _flags &amp; FAST_CACHE_ALLOC_MASK;</span><br><span class="line">        &#x2F;&#x2F; remove the FAST_CACHE_ALLOC_DELTA16 that was added</span><br><span class="line">        &#x2F;&#x2F; by setFastInstanceSize</span><br><span class="line">        &#x2F;&#x2F; 内存对齐是16字节</span><br><span class="line">        return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新开辟空间时计算对象所在空间</span><br><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() const &#123;</span><br><span class="line">    return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 8字节对齐</span><br><span class="line">static inline size_t word_align(size_t x) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过算法得到8字节的倍数</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 16字节对齐 fastInstanceSize</span><br><span class="line">static inline size_t align16(size_t x) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过算法得到16字节的倍数</span><br><span class="line">    return (x + size_t(15)) &amp; ~size_t(15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举例说明一下算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; WORD_MASK &#x3D; 7</span><br><span class="line">(x + 7) &amp; ~7;</span><br><span class="line">&#x2F;&#x2F; x &#x3D; 2, x + 7 &#x3D; 9   -&gt; 0000 1001  ⬇️   x&#x3D;10 17 &#x3D; 0001 0001</span><br><span class="line">&#x2F;&#x2F; 7 &#x3D; 0000 0111 -&gt; !7 &#x3D; 1111 1000  ⬇️        !7 &#x3D; 1111 1000</span><br><span class="line">&#x2F;&#x2F;              9 &amp; !7 &#x3D; 0000 1000 &#x3D; 8  (17 &amp; !7 &#x3D; 0001 0000 &#x3D; 16)</span><br></pre></td></tr></table></figure>

<p>所以：<code>word_align</code>计算出来的都是8的倍数。<br>     <code>align16</code>计算出来的都是16的倍数。</p>
<p>这里需要注意的是在ARM64下，内存开辟都是16个字节进行对齐的。所以计算的大小的都是16的倍数。</p>
<h3 id="2-4-2-calloc"><a href="#2-4-2-calloc" class="headerlink" title="2.4.2 calloc"></a>2.4.2 calloc</h3><p>calloc申请开辟内存，返回地址指针。</p>
<h3 id="2-4-3-obj-gt-initInstanceIsa"><a href="#2-4-3-obj-gt-initInstanceIsa" class="headerlink" title="2.4.3 obj-&gt;initInstanceIsa"></a>2.4.3 obj-&gt;initInstanceIsa</h3><p>生成的对象与class进行关联。通过isa指针。（isa之后会有说明，每一个类都有一个isa指针）。</p>
<h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p><img src="oc-alloc.png" alt=""></p>
<p>这个图很好的说明了alloc的流程。</p>
<h1 id="3-init"><a href="#3-init" class="headerlink" title="3. init"></a>3. init</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span><br><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init其实是工厂方法，从上面的代码可以看到，只是<code>return self</code>。这里有一个重要的点，就是大部分的实现都会交给子类去重新自定义init方法。</p>
<h1 id="4-new"><a href="#4-new" class="headerlink" title="4. new"></a>4. new</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false&#x2F;*checkNil*&#x2F;) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到new的实现就是执行了，callAlloc()，然后执行了init操作。与实际上的<code>[[Person alloc] init]</code>并没有什么区别。</p>
<p>但是看到有一些博客上说，还是有区别，因为init被重写之后，调用new可能会造成少些东西。这里不能苟同哈，所有的方法调用，在OC中都是objc_msgSend，会去寻找方法列表的。所以不会存在什么不同。</p>
<h1 id="5-扩展知识"><a href="#5-扩展知识" class="headerlink" title="5. 扩展知识"></a>5. 扩展知识</h1><p>我们已经知道了，本身写一个Person类，需要开辟16个字节的空间，那需要申请多大内存空间是由什么因素决定的？<br>我们可以试一下分别添加一个属性，两个属性，试一下。自己动手试一下哈，看看2.4.1小结处返回的size是多少。其申请内存的大小其实是成员变量说了算。</p>
<p>我这里添加了两个NSString属性，分别赋值A和B。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x600002f86cc0&gt;</span><br><span class="line">(lldb) x p</span><br><span class="line">0x600002f86cc0: 60 76 e3 06 01 00 00 00 40 20 e3 06 01 00 00 00  &#96;v......@ ......</span><br><span class="line">0x600002f86cd0: 60 20 e3 06 01 00 00 00 00 00 00 00 00 00 00 00  &#96; ..............</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x600002f86cc0: 0x0000000106e37660 0x0000000106e32040</span><br><span class="line">0x600002f86cd0: 0x0000000106e32060 0x0000000000000000</span><br><span class="line">(lldb) po 0x0000000106e37660    &#x2F;&#x2F; isa指针，指向class</span><br><span class="line">Person</span><br><span class="line">(lldb) po 0x0000000106e32040</span><br><span class="line">A</span><br><span class="line">(lldb) po 0x0000000106e32060</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<p>通过<code>x p</code>命令我们可以打印出<code>p</code>的内存地址。在源码的运行过程中，断点到size计算那里，打印出来size的大小是<code>32</code>个字节。也就是会空8个字节。</p>
<p>如果声明了4个bool值，则4个bool值则会依次放在内存中，例如：0x0000000001010101，这个就涉及到字节的对齐以及iOS系统对属性的重排（内存优化）。</p>
<h1 id="6-真正的alloc流程"><a href="#6-真正的alloc流程" class="headerlink" title="6. 真正的alloc流程"></a>6. 真正的alloc流程</h1><p>当我们执行<code>[Person alloc]</code>的时候，直接吧断点放在<code>callAlloc-&gt;objc_msgSend</code>，则会先执行消息转发。原因是系统内部会通过llvm的函数方法把<code>alloc</code>指向到<code>objc_alloc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先执行一次<code>callAlloc(cls, true, false)</code>，注意这里的参数。然后执行到calAlloc中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil); &#x2F;&#x2F;1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#x2F;&#x2F; 2.</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); &#x2F;&#x2F; 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行，我们发现会先执行第3个return。所执行的还是<code>alloc</code>，这时候执行的才是真正的alloc。然后就可以顺着第2节的内容继续了。</p>
<p>如图，是完整的alloc会执行两次的流程图：</p>
<p><img src="oc-alloc-2.jpg" alt=""></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>alloc的流程</li>
<li>alloc的两次执行过程</li>
<li>init</li>
<li>new</li>
</ul>
<p>有什么不对的欢迎指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/14/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/14/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-3/" class="post-title-link" itemprop="url">ARM汇编-3 状态寄存器 if、loop、switch</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 22:05:25" itemprop="dateCreated datePublished" datetime="2021-04-14T22:05:25+08:00">2021-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-状态寄存器"><a href="#1-状态寄存器" class="headerlink" title="1. 状态寄存器"></a>1. 状态寄存器</h1><p>CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同)。这种寄存器在ARM中，被称为状态寄存器就是CPSR(current program status register)寄存器。</p>
<p>CPSR和其他寄存器不一样,其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<blockquote>
<p>CPSR寄存器是32位的。</p>
</blockquote>
<ul>
<li>CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!</li>
<li>N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行！</li>
</ul>
<p><img src=".jpg" alt=""></p>
<h2 id="1-1-N-（Negative）"><a href="#1-1-N-（Negative）" class="headerlink" title="1.1 N （Negative）"></a>1.1 N （Negative）</h2><p>cpsr的第31位是N，它记录相关指令执行后的结果，结果是负数，则N=1，非负数则N=0。</p>
<blockquote>
<p>在ARM64的指令集中，逻辑运算或者算数运算（add、sub、or等）指令的执行会影响状态寄存器的值。</p>
</blockquote>
<p>n=1：结果是负数<br>n=0：结果位非负数，包括0</p>
<h2 id="1-2-Z（Zero）"><a href="#1-2-Z（Zero）" class="headerlink" title="1.2 Z（Zero）"></a>1.2 Z（Zero）</h2><p>cpsr的第30位是Z，0标志位。它记录相关指令执行后其结果是否为。如果结果为0，那么Z = 1；如果结果不为0，那么Z = 0.</p>
<p>z=1：结果为0<br>z=0：结果不为0</p>
<h2 id="1-3-C（Carry）"><a href="#1-3-C（Carry）" class="headerlink" title="1.3 C（Carry）"></a>1.3 C（Carry）</h2><p>cpsr第29位是c进位标志位，一般情况进行下无符号述的运算。</p>
<p>加法运算：当运算结果产生了进位时（无符号数溢出）c=1，没有溢出c=0<br>减法运算：包括（CPM）当运算时产生了借位（无符号数溢出），c=0，没有溢出c=1</p>
<h3 id="1-3-1-进位"><a href="#1-3-1-进位" class="headerlink" title="1.3.1 进位"></a>1.3.1 进位</h3><p>两个数据相加，比如正常的十进制运算，5+5=10，向十位数进1，个位数为0。但是超过其最大的位数时，发生溢出，导致进位的值无法保存，也就是说进位的值丢失了。但是CPU在运算的时候，并不会丢弃这个进位的值，二手放在寄存器里了，也就是cpsr的c位。</p>
<h3 id="1-3-2-借位"><a href="#1-3-2-借位" class="headerlink" title="1.3.2 借位"></a>1.3.2 借位</h3><p>两个数据做减法操作，有可能向更高位借位。比如：10-5=5，各位不够减，需要向十位去借。这时候会用c位来标记借位。</p>
<h2 id="1-4-V（Overflow）"><a href="#1-4-V（Overflow）" class="headerlink" title="1.4 V（Overflow）"></a>1.4 V（Overflow）</h2><p>cpsr的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。</p>
<ul>
<li>正数 + 正数 = 负数。溢出</li>
<li>负数 + 负数 = 正数。溢出</li>
<li>正数 + 负数 不可能发生溢出</li>
</ul>
<h1 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h1><p>NZ：是否为0，判断正负<br>CV：无符号，有符号判断是否溢出 </p>
<h1 id="2-全局变量、常量"><a href="#2-全局变量、常量" class="headerlink" title="2. 全局变量、常量"></a>2. 全局变量、常量</h1><p>开始这一节之前，先知道我们的内存分区划分：</p>
<p>代码区：存放代码，可读，可执行<br>栈区：参数、局部变量、临时数据，可读可写<br>堆区：动态申请，可读可写</p>
<p>全局变量：可读可写<br>常量区：只读</p>
<p>接下来，我们分析代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个全局变量</span><br><span class="line">int g &#x3D; 12;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个方法</span><br><span class="line">int func(int a,int b)&#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;haha&#39;就是一个常量，在常量区</span><br><span class="line">    printf(&quot;haha&quot;);</span><br><span class="line">    &#x2F;&#x2F; 局部变量c</span><br><span class="line">    int c &#x3D; a + g + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">   </span><br><span class="line">    func(10, 20);</span><br><span class="line">    </span><br><span class="line">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，走汇编流程，进行查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">-&gt;  0x100bc211c &lt;+0&gt;:  sub    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x100bc2120 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100bc2124 &lt;+8&gt;:  add    x29, sp, #0x10            ; &#x3D;0x10 </span><br><span class="line">    0x100bc2128 &lt;+12&gt;: stur   w0, [x29, #-0x4]</span><br><span class="line">    0x100bc212c &lt;+16&gt;: str    w1, [sp, #0x8]</span><br><span class="line">    0x100bc2130 &lt;+20&gt;: adrp   x0, 1</span><br><span class="line">    0x100bc2134 &lt;+24&gt;: add    x0, x0, #0xf9f            ; &#x3D;0xf9f </span><br><span class="line">    &#x2F;&#x2F; ① 这里执行了printf操作，大致可以判断，x0中存的就是&#39;haha&#39;</span><br><span class="line">    0x100bc2138 &lt;+28&gt;: bl     0x100bc25b0               ; symbol stub for: printf</span><br><span class="line">    0x100bc213c &lt;+32&gt;: ldur   w8, [x29, #-0x4]</span><br><span class="line">    &#x2F;&#x2F; ② 这里获取的是全局变量</span><br><span class="line">    0x100bc2140 &lt;+36&gt;: adrp   x9, 3</span><br><span class="line">    0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; &#x3D;0x648 </span><br><span class="line">    0x100bc2148 &lt;+44&gt;: ldr    w10, [x9]</span><br><span class="line">    0x100bc214c &lt;+48&gt;: add    w8, w8, w10</span><br><span class="line">    0x100bc2150 &lt;+52&gt;: ldr    w10, [sp, #0x8]</span><br><span class="line">    0x100bc2154 &lt;+56&gt;: add    w8, w8, w10</span><br><span class="line">    0x100bc2158 &lt;+60&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x100bc215c &lt;+64&gt;: ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bc2160 &lt;+68&gt;: mov    x0, x8</span><br><span class="line">    0x100bc2164 &lt;+72&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100bc2168 &lt;+76&gt;: add    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x100bc216c &lt;+80&gt;: ret</span><br></pre></td></tr></table></figure>

<p>①这里执行了printf操作，这里看一些是否真的打印了’haha’。我们追一下x0寄存器的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x100bc2130 &lt;+20&gt;: adrp   x0, 1</span><br></pre></td></tr></table></figure>
<p>这里有一个关键字需要注意一下：<br>adrp: 针对address page操作<br>这一行代码有三个操作：</p>
<ol>
<li>将1左移12位（即在1后加3个0变成1000）</li>
<li>将当前寄存器的地址的低12位清0，即当前行的地址的后3位清0。0x1002b2184 -&gt; 0x100bc2130</li>
<li>把0x1000+0x100bc2000赋值给x0，x0=0x100bc3000，即当前行地址的倒数第4位与x0后面的数字相加</li>
</ol>
<p>说白了，这句代码的意思就是找到某一页地址的开始。我们走断点，打印一下x0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read x0</span><br><span class="line">x0 &#x3D; 0x0000000100bc3000</span><br></pre></td></tr></table></figure>

<p>下一句的代码是，<code>add x0, x0, #0xf9f</code>，就x0的地址+0x0xf9f<br>获取x0的值位0x100bc3f9f</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read x0</span><br><span class="line">x0 &#x3D; 0x0000000100bc3f9f  &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">(lldb) x 0x0000000100bc3f9f</span><br><span class="line">0x100bc3f9f: 68 61 68 61 00 01 00 00 00 1c 00 00 00 02 00 00  haha............</span><br><span class="line">0x100bc3faf: 00 24 00 00 00 00 00 00 00 24 00 00 00 02 00 00  .$.......$......</span><br></pre></td></tr></table></figure>

<p>我们知道’h’的ASCII码是97，对应的16进制就行0x61，’a’是0x68。就是我们的常量’haha’。</p>
<p>这样也就拿到了常量的值。<br>需要注意的是，我们的常量是在编译的时候就已经确定了地址。这里通过当前寄存器的地址为参照，偏移一定的值来获取常量所在的页数。</p>
<p>那继续看一下全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x100bc2140 &lt;+36&gt;: adrp   x9, 3</span><br><span class="line">0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; &#x3D;0x648</span><br></pre></td></tr></table></figure>

<p>我们使用相同的方式，打印一下x9的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; adrp的断点</span><br><span class="line">(lldb) register read x9</span><br><span class="line">x9 &#x3D; 0x0000000100bc5000  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add 的断点</span><br><span class="line">lldb) register read x9</span><br><span class="line">x9 &#x3D; 0x0000000100bc5648  g  &#x2F;&#x2F; 这里拿到的是变量g，而g在内存中的值是0c</span><br><span class="line">(lldb) x 0x0000000100bc5648</span><br><span class="line">0x100bc5648: 0c 00 00 00 0c 00 00 00 38 5e 44 29 02 00 00 00  ........8^D)....</span><br><span class="line">0x100bc5658: f0 33 bc 00 01 00 00 00 d0 4f bc 00 01 00 00 00  .3.......O......</span><br></pre></td></tr></table></figure>

<p>我们可以通过相同的方式获取全局变量的值，g=12。</p>
<p>所以局部变量和全局变量都是通过adrp以当前寄存器的地址为参照来查找address来获取值的。</p>
<h2 id="2-1-汇编还原高级语言"><a href="#2-1-汇编还原高级语言" class="headerlink" title="2.1 汇编还原高级语言"></a>2.1 汇编还原高级语言</h2><p>这里使用一个牛逼的工具Hopper，可以查看对应的方法转化成汇编之后的代码。</p>
<ol>
<li>build成功之后，在我们的工程里有一个’Products’文件，里头有对应的<code>xxx.app</code>。</li>
<li>点击show in finder，找到对应的app，右键显示包内容。</li>
<li>找到与项目同名的黑乎乎的东西（可执行文件），直接拖到Hopper里头就可以了。</li>
</ol>
<p>我们找到对应的方法func</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_func:</span><br><span class="line">000000010000611c         sub        sp, sp, #0x20    ; CODE XREF&#x3D;_main+32</span><br><span class="line">0000000100006120         stp        x29, x30, [sp, #0x10]</span><br><span class="line">0000000100006124         add        x29, sp, #0x10</span><br><span class="line">&#x2F;&#x2F; 这里我们可以知道有两个变量，w0、w1分别存起来</span><br><span class="line">0000000100006128         stur       w0, [x29, #-0x4]</span><br><span class="line">000000010000612c         str        w1, [sp, #0x8]</span><br><span class="line">&#x2F;&#x2F; adrp操作，获取页数</span><br><span class="line">0000000100006130         adrp       x0, #0x100007000 ; argument #1 for method imp___stubs__printf</span><br><span class="line">&#x2F;&#x2F; 这里直接把结果给出来了。haha存放在x0</span><br><span class="line">0000000100006134         add        x0, x0, #0xf9f   ; &quot;haha&quot;</span><br><span class="line">&#x2F;&#x2F; 执行printf</span><br><span class="line">0000000100006138         bl         imp___stubs__printf</span><br><span class="line">&#x2F;&#x2F; 取值，这个位置的值就是w0</span><br><span class="line">000000010000613c         ldur       w8, [x29, #-0x4]</span><br><span class="line">&#x2F;&#x2F; adrp操作，根据页数获取值</span><br><span class="line">0000000100006140         adrp       x9, #0x100009000</span><br><span class="line">&#x2F;&#x2F; 获取变量_g。我们可以通过地址去找对应的值。可以在Hopper中找到对应的值</span><br><span class="line">0000000100006144         add        x9, x9, #0x648   ; _g</span><br><span class="line">&#x2F;&#x2F; 赋值w10 &#x3D; _g </span><br><span class="line">0000000100006148         ldr        w10, x9</span><br><span class="line">&#x2F;&#x2F; 执行加法操作 w8 +&#x3D; w10</span><br><span class="line">000000010000614c         add        w8, w8, w10</span><br><span class="line">&#x2F;&#x2F; 取值。也就是获取第二个参数的值w1</span><br><span class="line">0000000100006150         ldr        w10, [sp, #0x8]</span><br><span class="line">&#x2F;&#x2F; 执行加法操作 w8 +&#x3D; w10</span><br><span class="line">0000000100006154         add        w8, w8, w10</span><br><span class="line">&#x2F;&#x2F; 把w8的值存起来</span><br><span class="line">0000000100006158         str        w8, [sp, #0x4]</span><br><span class="line">&#x2F;&#x2F; 取值w8</span><br><span class="line">000000010000615c         ldr        w8, [sp, #0x4]</span><br><span class="line">&#x2F;&#x2F; 把w8的值给x0（x0存放返回值）</span><br><span class="line">0000000100006160         mov        x0, x8</span><br><span class="line">&#x2F;&#x2F; 释放内存，return</span><br><span class="line">0000000100006164         ldp        x29, x30, [sp, #0x10]</span><br><span class="line">0000000100006168         add        sp, sp, #0x20</span><br><span class="line">000000010000616c         ret</span><br></pre></td></tr></table></figure>

<p>汇编的代码逻辑已经直接表示出来了。最终可以得出一个函数的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int w1, int w2) &#123;</span><br><span class="line">    printf(&quot;haha&quot;);</span><br><span class="line">    return w1 + _g + w2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h1><h2 id="2-1-cmp（Compare）比较指令"><a href="#2-1-cmp（Compare）比较指令" class="headerlink" title="2.1 cmp（Compare）比较指令"></a>2.1 cmp（Compare）比较指令</h2><p>cmp把一个寄存器的内容和另一个寄存器的内容（或立即数）进行比较。但不存储结果，只是更改标志。</p>
<p>一般cmp做完判断后会进行跳转，后面通常会跟上b指令。</p>
<p>cmp比较，其实是一个减法操作，但是不会改变两个比较的值。通过减法的结果去比较。</p>
<ul>
<li>BL 标号：跳转到标号处执行</li>
<li>B.LT 标号：比价结果是<strong>小于（less than）</strong>，执行标号，否则不跳转</li>
<li>B.LE 标号：比较结果是<strong>小于等于（less than or qeual to）</strong>，执行标号，否则不跳转</li>
<li>B.GT  标号：比较结果是<strong>大于（greater than）</strong>，执行标号，否则不跳转</li>
<li>B.GE  标号：比较结果是<strong>大于等于（greater than or equal to）</strong>，执行标号，否则不跳转</li>
<li>B.EQ  标号：比较结果是<strong>等于(equal to)</strong>，执行标号，否则不跳转</li>
<li>B.NE 标号：比较结果是<strong>不等于（not equal to）</strong>，执行标号，否则不跳转</li>
<li>B.LS  标号：比较结果是<strong>无符号小于等于</strong>，执行标号，否则不跳转</li>
<li>B.LO  标号：比较结果是<strong>无符号小于</strong>，执行标号，否则不跳转</li>
<li>B.HI  标号：比较结果是<strong>无符号大于</strong>，执行标号，否则不跳转</li>
<li>B.HS  标号：比较结果是<strong>无符号大于等于</strong>，执行标号，否则不跳转</li>
</ul>
<p>b.gt #0x10000f8d:这个地址是else的跳转地址</p>
<h1 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h1><blockquote>
<p>使用汇编的时候一定是在真机上运行。或者直接选中真机，直接<code>Command+B</code>buid之后，找到对应的可执行文件，直接放在Hopper里就行。</p>
</blockquote>
<h1 id="3-1-do-while"><a href="#3-1-do-while" class="headerlink" title="3.1 do-while"></a>3.1 do-while</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void loopFunc() &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        nsum +&#x3D; 10;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125; while (i &lt; 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下汇编下是什么代码逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FunctionDemo&#96;loopFunc:</span><br><span class="line">-&gt;  0x102c2a764 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 这里是把0放在sp+0xc里头，w：低32位，zr&#x3D;&#x3D;zero</span><br><span class="line">    0x102c2a768 &lt;+4&gt;:  str    wzr, [sp, #0xc]   &#x2F;&#x2F; 假设#0xc存的是a</span><br><span class="line">    0x102c2a76c &lt;+8&gt;:  str    wzr, [sp, #0x8]   &#x2F;&#x2F; 假设#0x8存的是b,之后用的都是w8，会比较乱</span><br><span class="line">    &#x2F;&#x2F; ① 读取a的值</span><br><span class="line">    0x102c2a770 &lt;+12&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    &#x2F;&#x2F; 执行a +&#x3D; 10的操作。</span><br><span class="line">    0x102c2a774 &lt;+16&gt;: add    w8, w8, #0xa              ; &#x3D;0x1 </span><br><span class="line">    &#x2F;&#x2F; 然后把a的值存起来。</span><br><span class="line">    0x102c2a778 &lt;+20&gt;: str    w8, [sp, #0xc]</span><br><span class="line">    &#x2F;&#x2F; 取值b</span><br><span class="line">    0x102c2a77c &lt;+24&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; b +&#x3D; 1</span><br><span class="line">    0x102c2a780 &lt;+28&gt;: add    w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    &#x2F;&#x2F; 把b存起来</span><br><span class="line">    0x102c2a784 &lt;+32&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x102c2a788 &lt;+36&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 比较b的值，b与100比较</span><br><span class="line">    0x102c2a78c &lt;+40&gt;: cmp    w8, #0x64                 ; &#x3D;0x64 </span><br><span class="line">    &#x2F;&#x2F; 如果 lt（小于）if b &lt; 100 跳转到0x102c2a770继续执行。执行①</span><br><span class="line">    0x102c2a790 &lt;+44&gt;: b.lt   0x102c2a770               ; &lt;+12&gt; at main.m:22:14</span><br><span class="line">    0x102c2a794 &lt;+48&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x102c2a798 &lt;+52&gt;: ret</span><br></pre></td></tr></table></figure>

<p>我们直接使用Hopper工具查看汇编，其实比在Xcode中更方便。</p>
<p><img src="do-while.png" alt=""></p>
<h2 id="3-2-while"><a href="#3-2-while" class="headerlink" title="3.2 while"></a>3.2 while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void whileFunc() &#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    while (i &lt; 10) &#123;</span><br><span class="line">        nsum +&#x3D; 10;</span><br><span class="line">        i +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Hopper里查看源码：</p>
<p><img src="while.jpg" alt=""></p>
<p>①处是一个比较，判断w8的值和10的大小，如果<code>b.ge</code>则执行<code>loc_100006128</code>的代码。b.ge是大于等于。<br>②是直接跳转到<code>loc_10000610c</code>的代码。</p>
<h2 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a>3.3 for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void forFunc() &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        nsum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Hopper里查看源码：</p>
<p><img src="for.jpg" alt=""></p>
<p>for循环与while循环区别不大。</p>
<h1 id="4-switch"><a href="#4-switch" class="headerlink" title="4. switch"></a>4. switch</h1><h2 id="4-1-三个case的switch"><a href="#4-1-三个case的switch" class="headerlink" title="4.1 三个case的switch"></a>4.1 三个case的switch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是运行xCode，查看汇编源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;switchFunc:</span><br><span class="line">-&gt;  0x100bea0e8 &lt;+0&gt;:   sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100bea0ec &lt;+4&gt;:   str    w0, [sp, #0xc]</span><br><span class="line">    0x100bea0f0 &lt;+8&gt;:   str    wzr, [sp, #0x8]</span><br><span class="line">    0x100bea0f4 &lt;+12&gt;:  ldr    w8, [sp, #0xc]</span><br><span class="line">    0x100bea0f8 &lt;+16&gt;:  cmp    w8, #0x1                  ; &#x3D;0x1 </span><br><span class="line">    0x100bea0fc &lt;+20&gt;:  str    w8, [sp, #0x4]</span><br><span class="line">    0x100bea100 &lt;+24&gt;:  b.eq   0x100bea128               ; &lt;+64&gt; at main.m:48:18</span><br><span class="line">    0x100bea104 &lt;+28&gt;:  b      0x100bea108               ; &lt;+32&gt; at main.m</span><br><span class="line">    0x100bea108 &lt;+32&gt;:  ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bea10c &lt;+36&gt;:  cmp    w8, #0x2                  ; &#x3D;0x2 </span><br><span class="line">    0x100bea110 &lt;+40&gt;:  b.eq   0x100bea138               ; &lt;+80&gt; at main.m:51:18</span><br><span class="line">    0x100bea114 &lt;+44&gt;:  b      0x100bea118               ; &lt;+48&gt; at main.m</span><br><span class="line">    0x100bea118 &lt;+48&gt;:  ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bea11c &lt;+52&gt;:  cmp    w8, #0x3                  ; &#x3D;0x3 </span><br><span class="line">    0x100bea120 &lt;+56&gt;:  b.eq   0x100bea148               ; &lt;+96&gt; at main.m:54:18</span><br><span class="line">    0x100bea124 &lt;+60&gt;:  b      0x100bea158               ; &lt;+112&gt; at main.m:60:18</span><br><span class="line">    0x100bea128 &lt;+64&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea12c &lt;+68&gt;:  add    w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    0x100bea130 &lt;+72&gt;:  str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea134 &lt;+76&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea138 &lt;+80&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea13c &lt;+84&gt;:  add    w8, w8, #0xa              ; &#x3D;0xa </span><br><span class="line">    0x100bea140 &lt;+88&gt;:  str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea144 &lt;+92&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea148 &lt;+96&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea14c &lt;+100&gt;: add    w8, w8, #0x14             ; &#x3D;0x14 </span><br><span class="line">    0x100bea150 &lt;+104&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea154 &lt;+108&gt;: b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea158 &lt;+112&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea15c &lt;+116&gt;: subs   w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    0x100bea160 &lt;+120&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea164 &lt;+124&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100bea168 &lt;+128&gt;: ret</span><br></pre></td></tr></table></figure>

<p>看汇编源码，其实就是简单的if-else比较，只不过这里换成了b.eq(等于)，然后跳转到对应的代码块。</p>
<h2 id="4-2-4个case的switch"><a href="#4-2-4个case的switch" class="headerlink" title="4.2 4个case的switch"></a>4.2 4个case的switch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    switchFunc(4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们改变一下代码，再加一个case，运行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;switchFunc:</span><br><span class="line">    0x1005460ac &lt;+0&gt;:   sub    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x1005460b0 &lt;+4&gt;:   stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x1005460b4 &lt;+8&gt;:   add    x29, sp, #0x10            ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. 把w0的值存起来，w0 &#x3D; 4</span><br><span class="line">    0x1005460b8 &lt;+12&gt;:  stur   w0, [x29, #-0x4]</span><br><span class="line">    &#x2F;&#x2F; 2. 把0存起来</span><br><span class="line">    0x1005460bc &lt;+16&gt;:  str    wzr, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 3. 取值w8 &#x3D; 4</span><br><span class="line">    0x1005460c0 &lt;+20&gt;:  ldur   w8, [x29, #-0x4]</span><br><span class="line">    &#x2F;&#x2F; 4. 这里是第一个case 1. w8 &#x3D; w8 - 1 &#x3D; 3</span><br><span class="line">    0x1005460c4 &lt;+24&gt;:  subs   w8, w8, #0x1              ; &#x3D;0x1 </span><br><span class="line">    &#x2F;&#x2F; 5. 把x8的值给x9，x9 &#x3D; 0x0000000000000003</span><br><span class="line">    0x1005460c8 &lt;+28&gt;:  mov    x9, x8</span><br><span class="line">    &#x2F;&#x2F; 6. 这个ubfx语法，往下翻有详细解释。把x9的高32位清零，x9 &#x3D; 0x0000000000000003</span><br><span class="line">    0x1005460cc &lt;+32&gt;:  ubfx   x9, x9, #0, #32</span><br><span class="line">    &#x2F;&#x2F; 7. x9的值和3进行比较</span><br><span class="line">    0x1005460d0 &lt;+36&gt;:  cmp    x9, #0x3                  ; &#x3D;0x3 </span><br><span class="line">    &#x2F;&#x2F; 8. 把x9的值放在sp对应的内存地址中</span><br><span class="line">    0x1005460d4 &lt;+40&gt;:  str    x9, [sp]</span><br><span class="line">    &#x2F;&#x2F; 9. 如果7中比较的结果是一个【无符号大于】，则执行0x100546134，其实就是执行了default操作</span><br><span class="line">-&gt;  0x1005460d8 &lt;+44&gt;:  b.hi   0x100546134               ; &lt;+136&gt; at main.m</span><br><span class="line">    &#x2F;&#x2F; 10. adrp:地址操作，x8&#x3D;0x100546000，左边的地址标号后12位清零，然后加上0x0000</span><br><span class="line">    0x1005460dc &lt;+48&gt;:  adrp   x8, 0</span><br><span class="line">    &#x2F;&#x2F; 11. x8 &#x3D; 0x10054614c，然后通过view memory，看里头的值。</span><br><span class="line">    0x1005460e0 &lt;+52&gt;:  add    x8, x8, #0x14c            ; &#x3D;0x14c </span><br><span class="line">    &#x2F;&#x2F; 12. 取值x11 &#x3D; 3</span><br><span class="line">    0x1005460e4 &lt;+56&gt;:  ldr    x11, [sp]</span><br><span class="line">    &#x2F;&#x2F; 13. ldrsw：取值，先计算中括号内部x11, lsl #2:意思是x11左移2位，</span><br><span class="line">    &#x2F;&#x2F;     然后加上x8获取一个地址，把地址里的值给x10</span><br><span class="line">    &#x2F;&#x2F; 3&lt;&lt;2 &#x3D; 二进制数3：11&lt;&lt;2 &#x3D; 1100，也就是十进制12，</span><br><span class="line">    &#x2F;&#x2F; x8+12 &#x3D; 0x10054614c+0xc &#x3D; 0x100546158</span><br><span class="line">    &#x2F;&#x2F; 这是一个寻址操作，把0x100546158地址的值给x10，</span><br><span class="line">    &#x2F;&#x2F; 通过view memory查看x10 &#x3D; 0xffffffd8 &#x3D; -40,是一个负值</span><br><span class="line">    0x1005460e8 &lt;+60&gt;:  ldrsw  x10, [x8, x11, lsl #2]</span><br><span class="line">    &#x2F;&#x2F; x9 &#x3D; 0x10054614c + (-40) &#x3D; 0x100546124</span><br><span class="line">    0x1005460ec &lt;+64&gt;:  add    x9, x8, x10</span><br><span class="line">    &#x2F;&#x2F; 执行跳转到 0x100546124</span><br><span class="line">    0x1005460f0 &lt;+68&gt;:  br     x9</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从这里开始就是case的位置了。</span><br><span class="line">    0x1005460f4 &lt;+72&gt;:  adrp   x0, 1</span><br><span class="line">    0x1005460f8 &lt;+76&gt;:  add    x0, x0, #0xf8c            ; &#x3D;0xf8c </span><br><span class="line">    0x1005460fc &lt;+80&gt;:  bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546100 &lt;+84&gt;:  b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546104 &lt;+88&gt;:  adrp   x0, 1</span><br><span class="line">    0x100546108 &lt;+92&gt;:  add    x0, x0, #0xf8e            ; &#x3D;0xf8e </span><br><span class="line">    0x10054610c &lt;+96&gt;:  bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546110 &lt;+100&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546114 &lt;+104&gt;: adrp   x0, 1</span><br><span class="line">    0x100546118 &lt;+108&gt;: add    x0, x0, #0xf90            ; &#x3D;0xf90 </span><br><span class="line">    0x10054611c &lt;+112&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546120 &lt;+116&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    &#x2F;&#x2F; 直接跳转到这里，执行adrp操作，获取x0</span><br><span class="line">    0x100546124 &lt;+120&gt;: adrp   x0, 1</span><br><span class="line">    0x100546128 &lt;+124&gt;: add    x0, x0, #0xf92            ; &#x3D;0xf92 </span><br><span class="line">    &#x2F;&#x2F; 执行printf操作。</span><br><span class="line">    0x10054612c &lt;+128&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546130 &lt;+132&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546134 &lt;+136&gt;: adrp   x0, 1</span><br><span class="line">    0x100546138 &lt;+140&gt;: add    x0, x0, #0xf94            ; &#x3D;0xf94 </span><br><span class="line">    0x10054613c &lt;+144&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546140 &lt;+148&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100546144 &lt;+152&gt;: add    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x100546148 &lt;+156&gt;: ret</span><br></pre></td></tr></table></figure>

<p>发现不一样了啊，不是if-else判断了。</p>
<p>0x10092e0e0 &lt;+24&gt;:  ubfx   x9, x9, #0, #32<br>x9寄存器是64位，w8是32位，相当于x9的低32位。<br>这里的目的就是x9从0位开始到32位清零，也就x9的高32位清零然后赋值给x9</p>
<p><code>b.hi</code> 无符号大于</p>
<p><code>br x9</code>：b是跳转，br是不影响lr寄存器的跳转。直接跳到x9（x9是一个地址标号）</p>
<p><code>ldrsw  x10, [x8, x11, lsl #2]</code>： 这里先计算中括号内部。而在中括号内部先计算x11。</p>
<ol>
<li>lsl表示左移，<code>x11, lsl #2</code>表示x11左移2位。</li>
<li>加上x8的值。生成一个新的地址。</li>
<li>[]表示寻址，也就是说把生成的地址中的值给x10。</li>
</ol>
<p>看一下我们获取参数是否正确。看一下view memory</p>
<p><img src="switch-viewmemory.jpg" alt=""></p>
<p>偏移表中为什么存储的是地址的偏移量？为什么不直接存对应的地址？</p>
<blockquote>
<p>是因为地址只有在运行的时候才会开辟的，每次运行的值都不一样，所以直接存偏移量，然后通过偏移表的起始位置进行计算就可以直接定位了。</p>
</blockquote>
<h3 id="4-2-1-switch-case-偏移表"><a href="#4-2-1-switch-case-偏移表" class="headerlink" title="4.2.1 switch case 偏移表"></a>4.2.1 switch case 偏移表</h3><p>我们看第11. x8 = 0x10054614c，这个地址正好是当前汇编函数的末尾0x100546148+0x4。所以，这个函数栈空间后有一堆数据，存放一些值，这一堆数据就是case创建的偏移表。而这些值就是我们要偏移的值。</p>
<p>偏移表中的个数是由 (case的最大值 - case的最小值) + 1。看一下上面的图<code>0x10054614c</code>的位置存放的4个值，分别是0xffffffa8=-88, 0xffffffb8=-72, 0xffffffc8=-56, 0xffffffd8=-40</p>
<p>偏移值是一个负数，是因为是以<code>x8 = 0x10054614c</code>寄存器中存的地址为基数，偏移一个负数得到一个地址，这个地址就是在函数开辟的栈空间内。</p>
<p>我们通过一张图重新看一下这个过程：</p>
<p><img src="switch-2.jpg" alt=""></p>
<h2 id="4-3-4个不连续case的switch"><a href="#4-3-4个不连续case的switch" class="headerlink" title="4.3 4个不连续case的switch"></a>4.3 4个不连续case的switch</h2><p>我们知道了，3个连续的case是if-else比较，4个连续的case就不是if-else了，而是会生成一个表。那么4个不连续的case呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum &#x3D; 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 200:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 30:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不在放汇编源码了，4个不连续的case，与3个case一样，也是通过if-else比较来执行代码块的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。</li>
<li>各个case分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。</li>
<li>在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/13/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/13/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-2/" class="post-title-link" itemprop="url">ARM汇编-2 函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-13 21:52:51" itemprop="dateCreated datePublished" datetime="2021-04-13T21:52:51+08:00">2021-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-关于CPU的补充"><a href="#1-关于CPU的补充" class="headerlink" title="1. 关于CPU的补充"></a>1. 关于CPU的补充</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h2><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<blockquote>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
</blockquote>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<h2 id="1-2-高速缓存"><a href="#1-2-高速缓存" class="headerlink" title="1.2 高速缓存"></a>1.2 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<blockquote>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
</blockquote>
<h2 id="1-3-寄存器"><a href="#1-3-寄存器" class="headerlink" title="1.3 寄存器"></a>1.3 寄存器</h2><h3 id="1-3-1-数据地址寄存器"><a href="#1-3-1-数据地址寄存器" class="headerlink" title="1.3.1 数据地址寄存器"></a>1.3.1 数据地址寄存器</h3><p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br>ARM64中：</p>
<ul>
<li>64位 x0-x30，XZR（零寄存器）</li>
<li>32位 w0-w30，WZR（零寄存器）</li>
</ul>
<h3 id="1-3-2-浮点和向量寄存器"><a href="#1-3-2-浮点和向量寄存器" class="headerlink" title="1.3.2. 浮点和向量寄存器"></a>1.3.2. 浮点和向量寄存器</h3><p>因为浮点数的存储以及其运算的特殊性，CPU中专门提供浮点数寄存器来处理浮点数。</p>
<ul>
<li>64位: d0-d31 </li>
<li>32位: d0-d31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<p>向量寄存器 128位:V0-V31</p>
<h3 id="1-3-3-SP、FP寄存器"><a href="#1-3-3-SP、FP寄存器" class="headerlink" title="1.3.3 SP、FP寄存器"></a>1.3.3 SP、FP寄存器</h3><p>说这两个，需要先说一下栈。</p>
<p><img src="stack.jpg" alt=""></p>
<p>栈是一种具有特殊的访问方式的存储空间，先进后处，后进先出。（Last In Out First）</p>
<ul>
<li>sp寄存器在任意时刻会保存栈顶的地址。</li>
<li>fp寄存器也成为x29寄存器。属于通用寄存器，在默写时刻我们利用它保存栈底的地址。</li>
</ul>
<blockquote>
<p>需要注意的是，ARM64里面对栈的操作是16个字节对齐的。</p>
</blockquote>
<p><img src="stack_1.jpg" alt=""></p>
<p>这个图很好的说明了栈是从高地址往低地址开始读写操作的，堆是从低地址向高地址开始的，当栈不断的开辟空间，堆也不断的开辟空间，导致两个区域重叠，就会导致崩溃。也就是常说的堆栈溢出。（堆、栈上的空间是不固定的）</p>
<p>这里我们说个题外话，是不是所有的死循环都会导致崩溃？答案是否定的，只有不断的开辟空间的死循环才会导致崩溃，上一章我们最后的例子就是很好的说明，因为没有开辟空间。</p>
<h1 id="2-函数调用栈"><a href="#2-函数调用栈" class="headerlink" title="2. 函数调用栈"></a>2. 函数调用栈</h1><p>以下代码是常见的函数调用开辟和恢复栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, sp, #0x40             ; 拉伸0x40（64字节）空间</span><br><span class="line">stp    x29, x30, [sp, #0x30]     ; x29, x30 寄存器入栈保护</span><br><span class="line">add    x29, sp, #0x30            ; x29指向栈帧的底部</span><br><span class="line">... </span><br><span class="line">ldp    x29, x30, [sp, #0x30]     ; 恢复x29&#x2F;x30 寄存器的值</span><br><span class="line">add    sp, sp, #0x40             ; 栈平衡</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是： 读、写数据都是往高地址读、写。</p>
</blockquote>
<h2 id="2-1-内存读写指令"><a href="#2-1-内存读写指令" class="headerlink" title="2.1 内存读写指令"></a>2.1 内存读写指令</h2><ul>
<li>str指令：store register，将数据从寄存器中读出来，存在内存中。每次操作8个字节</li>
<li>ldr指令：load register，将数据从内存中读出来，存在寄存器中。每次操作8个字节</li>
<li>stp指令：str指令的变种，每次操作16个字节。</li>
<li>ldp指令：ldr指令的变种，每次操作16个字节。</li>
</ul>
<h2 id="2-2-堆栈操作"><a href="#2-2-堆栈操作" class="headerlink" title="2.2 堆栈操作"></a>2.2 堆栈操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_ABTest:</span><br><span class="line">    sub sp, sp, #0x20       ; 开辟栈空间，在当前sp所在的位置减去32个字节。</span><br><span class="line">    stp x0, x1, [sp, #0x10] ; 之所以用[],是因为sp存的是一个地址,这里的操作是寻址，把x0，x1的值放在对应的位置，但是栈的读写都是在高位，所以这里还需要加上一个值，写在高位</span><br><span class="line">    ldp x1, x0, [sp, #0x10] ; 这里是交换x0，x1的值。注意，当前的操作不会改变sp的值，寄存器中的值进行交换</span><br><span class="line">    add sp, sp, #0x20       ; 这里恢复栈空间。</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li>我们将上面的代码放在“.s”文件中，在ViewControler中声明<code>int ABTest();</code>方法.</li>
<li>在viewDidLoad中调用<code>ABTest();</code>，并在这一行打上断点。运行触发断点之后，按住ctrl键的同时点击小箭头，进入汇编，（按住ctrl是为了不让程序执行下一步）</li>
<li>在右下命令行中输入<code>register read sp</code>查看当前sp所在的位置，是<code>sp = 0x000000016fbf1290</code></li>
<li>点击下一步，开辟栈空间，重复第3步的操作，查看<code>sp = 0x000000016fbf1270</code></li>
<li>进入View Memory，定位到sp所在的位置，查看在<code>0x000000016fbf1280</code>位置的值是什么。</li>
<li>这个时候，分别执行<code>register write x0 0x0a</code>， <code>register write x1 0x0b</code>，修改x0，x1的值，执行下一步。</li>
<li>发现在左边通用寄存器中x0，x1的值已经发生变化。这时候重复第5步操作。查看是否已经发生变化。（需要切换页）</li>
<li>执行下一步，交换x0，x1的值。我们发现左边，通用寄存器中x0，x1的值已经发生了变化，这时候重复第5步，查看内存中的值是否有变化？是没有发生变化的哈~</li>
<li>销毁当前栈空间。重复第3步，查看当前sp的地址。是<code>sp = 0x000000016fbf1290</code></li>
</ol>
<p>如图：</p>
<p><img src="ABTest.jpg" alt=""></p>
<h1 id="3-bl和ret指令"><a href="#3-bl和ret指令" class="headerlink" title="3. bl和ret指令"></a>3. bl和ret指令</h1><h2 id="3-1-bl"><a href="#3-1-bl" class="headerlink" title="3.1 bl"></a>3.1 bl</h2><p>bl其实存在两个操作：</p>
<ol>
<li>将下一条指令的地址放入lr（x30）寄存器。也就是保存回家的路。</li>
<li>转到对应的跳转中执行指令，当指令执行完成后，会根据lr中的地址，返回继续执行。</li>
</ol>
<p>通俗的讲就是离家出走了，执行ret的时候，根据lr中的地址，找到回家的路。</p>
<h2 id="3-2-ret"><a href="#3-2-ret" class="headerlink" title="3.2 ret"></a>3.2 ret</h2><p>默认使用lr（x30）寄存器的值，通过底层指令提示CPU此处作为下条指令地址。这是ARM64平台的特色指令，它面向硬件方面做了优化处理。</p>
<h2 id="3-3-x30寄存器（lr寄存器）"><a href="#3-3-x30寄存器（lr寄存器）" class="headerlink" title="3.3 x30寄存器（lr寄存器）"></a>3.3 x30寄存器（lr寄存器）</h2><p>x30寄存器存放的是函数的返回地址，当ret指令执行时，会寻找x30寄存器保存的地址值。</p>
<p>这也就是，为啥上一章，最后的代码会造成循环引用的原因，因为x30寄存器的地址指向的就是当前bl的下一行代码。</p>
<h2 id="3-4-操作"><a href="#3-4-操作" class="headerlink" title="3.4 操作"></a>3.4 操作</h2><p>我们简写一下上一章的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在ViewDidLoad中执行A()，并打断点。执行上面的代码。按住ctrl键点击小剪头，进入A的汇编。查看当前lr寄存器中存放的地址是谁。然后按照下图所示进行操作，进入ViewDidLoad的汇编。</p>
<p> <img src="viewdidload.jpg" alt=""></p>
</li>
<li><p>我们看到了19行执行了 bl A的操作，也就是在ViewDidLoad中执行A()操作。而lr寄存器所存储的地址就是第20行所在的位置，也就是存储了执行A之后返回ViewDidLoad的地址。0x1003ce56c</p>
</li>
<li><p>点击继续执行，修改x0寄存器的值，继续下一步。执行bl B</p>
</li>
<li><p>这时候我们发现lr寄存器中存储的值已经被修改了，变成了A汇编代码中bl B下一行的地址。<code>lr = 0x1003ce904</code>，这里修改了x0的值。</p>
</li>
<li><p>下一步。继续执行B中的ret操作，发现回到了A，回到了<code>0x1003ce904</code>，继续执行发现修改了x0的值。</p>
</li>
<li><p>下一步，执行ret，发现又回到了A中的<code>0x1003ce904</code>，不断的执行，发现压根回不去ViewDidLoad了。</p>
</li>
</ol>
<p>这就是上一章中说的问题，lr寄存器的值被修改了，导致回不去了。那我们应该怎么处理呢？</p>
<p>最合理的方案是在执行bl操作之前，将bl的下一行地址存放在栈中。如果将值存放在其他寄存器中是绝对不安全的，因为你不知道什么时候就会被系统覆盖。</p>
<h3 id="3-4-1-解决死循环"><a href="#3-4-1-解决死循环" class="headerlink" title="3.4.1 解决死循环"></a>3.4.1 解决死循环</h3><p>我们为了解决上面的问题，我们查看系统是怎么处理这个问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void c() &#123;</span><br><span class="line">    d();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void d() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，在ViewDidLoad中执行<code>c()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;c:</span><br><span class="line">-&gt;  0x1005464e0 &lt;+0&gt;:  stp    x29, x30, [sp, #-0x10]!</span><br><span class="line">    0x1005464e4 &lt;+4&gt;:  mov    x29, sp</span><br><span class="line">    0x1005464e8 &lt;+8&gt;:  bl     0x1005464f4               ; d at ViewController.m:38:1</span><br><span class="line">    0x1005464ec &lt;+12&gt;: ldp    x29, x30, [sp], #0x10</span><br><span class="line">    0x1005464f0 &lt;+16&gt;: ret</span><br></pre></td></tr></table></figure>
<p>在c的汇编里头，我们仔细看下系统是什么处理lr寄存器的。<br>我们看到了x29和x30两个寄存器。x29是fp寄存器，指向栈底；x30寄存器就是lr寄存器。</p>
<ol>
<li><code>stp x29, x30, [sp, #-0x10]!</code> 这是汇编代码简写的形式的。这句话的意思是sp -= 0x10开辟空间，把x29和x30寄存器的值存放在开辟的空间里。“!”的操作是针对sp的，“[]”的操作是针对x29，x30寻址的。需要注意的是，先存值，在改变sp。</li>
<li><code>mov x29, sp</code> 将sp的值赋给x29寄存器。啥意思，fp跟sp指向相同的位置。栈顶栈底指向同一位置，啥情况？之后说哈~</li>
<li>bl操作，执行d()</li>
<li><code>ldp x29, x30, [sp], #0x10</code> 跟第一句差不多，“[]”就是寻址，将sp对应的两个地址的值赋值给x29，x30。第一步是存，这一步是取。然后执行 sp += 0x10的操作，释放栈空间。</li>
<li>执行ret操作，我们就能轻松的回到ViewDidLoad了。因为lr寄存器中的地址正是我们一开始存的值。</li>
</ol>
<p>在执行的过程中，我们一步步查看lr寄存器的值看是怎么变化的。就能清晰明了了。</p>
<p>这个时候，我们就可以修改上面的代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    str x30, [sp, #-0x10]!  ;仿造系统方法，因为x29寄存器暂时没有用处，所以只使用x30。</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    ldr x30, [sp], #0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>执行该代码，我们按照栈操作3.4的流程，查看整体流程，看x30寄存器存放读取的过程，配合View Memory使用会更爽哈~</p>
<p>这里把代码做一下修改，在A中<code>str x30, [sp, #-0x8]!</code>将16个字节改成8个字节会怎样？跑一遍试试看</p>
<p>会发生crash对不对。<b>因为在ARM64里面，对栈的操作是16个字节对齐的。所以开辟空间操作一定是16字节的倍数来进行的。</b></p>
<h1 id="4-函数的参数和返回值"><a href="#4-函数的参数和返回值" class="headerlink" title="4. 函数的参数和返回值"></a>4. 函数的参数和返回值</h1><p>ARM64下，函数的参数是存放在x0-x7(32位w0-w7)这个8个寄存器里面的。如果超过8个参数，就会入栈。<br>函数的返回值是放在x0(32位是w0)寄存器里的。</p>
<p>这里有一个点，在OC中，一般情况下，定义函数最多可以有几个参数？这里有一个小坑哈~<br>在runtime里，我们知道，函数调用都是通过objc_msgsend来处理的，而这里个里头已经存在了两个默认参数，一个是self，一个obj</p>
<p>当我们不知道怎么处理带参数的函数时，就看系统是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 我们定义一个函数，在viewDidLoad中执行。</span><br><span class="line">int sumA(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，按住control点击进汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">首先我们来到viewDidLoad中，</span><br><span class="line">&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    ; 这里我们有看到赋值，sumA(10+20)，我们看到w0&#x3D;10，w1&#x3D;20</span><br><span class="line">    0x104d125d4 &lt;+68&gt;: mov    w0, #0xa          </span><br><span class="line">    0x104d125d8 &lt;+72&gt;: mov    w1, #0x14</span><br><span class="line">-&gt;  0x104d125dc &lt;+76&gt;: bl     0x104d12570               ; sumA at ViewController.m:16  ; 这里有bl指令，继续执行跳转到sumA操作。</span><br><span class="line">    0x104d125e0 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x104d125e4 &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30 </span><br><span class="line">    0x104d125e8 &lt;+88&gt;: ret    </span><br><span class="line">    </span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">FunctionDemo&#96;sumA:</span><br><span class="line">-&gt;  0x100d3a4dc &lt;+0&gt;:  sub    sp, sp, #0x10     ; 开辟16个字节的空间</span><br><span class="line">    0x100d3a4e0 &lt;+4&gt;:  str    w0, [sp, #0xc]    ; 寻址把w0存放在sp+0xC的位置</span><br><span class="line">    0x100d3a4e4 &lt;+8&gt;:  str    w1, [sp, #0x8]    ; 寻址把w1存放在sp+0x8的位置</span><br><span class="line">    0x100d3a4e8 &lt;+12&gt;: ldr    w8, [sp, #0xc]    ; 把sp+0xC位置的值给w8</span><br><span class="line">    0x100d3a4ec &lt;+16&gt;: ldr    w9, [sp, #0x8]    ; 把sp+0x8位置的值给w9</span><br><span class="line">    0x100d3a4f0 &lt;+20&gt;: add    w0, w8, w9        ; 执行加法操作，并赋值给w0</span><br><span class="line">    0x100d3a4f4 &lt;+24&gt;: add    sp, sp, #0x10     ; 释放栈空间</span><br><span class="line">    0x100d3a4f8 &lt;+28&gt;: ret                      ; ret</span><br></pre></td></tr></table></figure>

<p>通过上面汇编之后的代码，我们可以看到整个的流程，相当于生成了两个临时量变去存储传进来的值，然后把返回值存储在w0寄存器里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 我们定义一个函数，在viewDidLoad中执行。</span><br><span class="line">int sumA(int a, int b) &#123;</span><br><span class="line">    int a1 &#x3D; 1;     &#x2F;&#x2F; 生成局部变量a1，b1</span><br><span class="line">    int b1 &#x3D; b;</span><br><span class="line">    return a1 + b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面系统的实现方案，我们就可以自己写一个带有参数，返回值的方法。在“.s”文件中实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global _sumB</span><br><span class="line"></span><br><span class="line">_sumB:</span><br><span class="line">    add x0, x0, x1</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h2 id="4-2-验证超过8个参数的情况"><a href="#4-2-验证超过8个参数的情况" class="headerlink" title="4.2 验证超过8个参数的情况"></a>4.2 验证超过8个参数的情况</h2><p>多余的参数会存放在调用方法所在的栈空间里，然后在调用的方法里去取别人的栈中存放的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，我们看汇编之后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#96;-[ViewController viewDidLoad]:</span><br><span class="line">...</span><br><span class="line">... 这中间省略了一大部分代码，我们直接从这里看</span><br><span class="line">    ; 这里打印 sp &#x3D; 0x000000016f4c53c0</span><br><span class="line">    0x10093e594 &lt;+64&gt;:  bl     0x10093e9b4               ; symbol stub for: objc_msgSendSuper2  </span><br><span class="line">    ; 这个是调用super viewDidLoad</span><br><span class="line">    0x10093e598 &lt;+68&gt;:  mov    w0, #0x1     ; 将1存到w0寄存器中</span><br><span class="line">    0x10093e59c &lt;+72&gt;:  mov    w1, #0x2</span><br><span class="line">    0x10093e5a0 &lt;+76&gt;:  mov    w2, #0x3</span><br><span class="line">    0x10093e5a4 &lt;+80&gt;:  mov    w3, #0x4</span><br><span class="line">    0x10093e5a8 &lt;+84&gt;:  mov    w4, #0x5</span><br><span class="line">    0x10093e5ac &lt;+88&gt;:  mov    w5, #0x6</span><br><span class="line">    0x10093e5b0 &lt;+92&gt;:  mov    w6, #0x7     ; 这些值我们是可以在通用寄存器里看到的</span><br><span class="line">    0x10093e5b4 &lt;+96&gt;:  mov    w7, #0x8     ; 将8存到w7寄存器中</span><br><span class="line">    ; x8 &#x3D; 0x0000000100940ce8  &quot;viewDidLoad&quot;</span><br><span class="line">    0x10093e5b8 &lt;+100&gt;: mov    x8, sp       ; 这里是把sp栈顶的位置放在x8寄存器中。</span><br><span class="line">    ; x8 &#x3D; 0x000000016f4c53c0</span><br><span class="line">    0x10093e5bc &lt;+104&gt;: mov    w10, #0x9    ; 把9放在w10寄存器</span><br><span class="line">    0x10093e5c0 &lt;+108&gt;: str    w10, [x8]    ; 把w10寄存器中的值，放在x8寄存器所在的地址里</span><br><span class="line">    ; 也就是在sp的位置，存放了9这个变量。</span><br><span class="line">-&gt;  0x10093e5c4 &lt;+112&gt;: bl     0x10093e4dc               ; sumA at ViewController.m:16      ; 这里执行 sumA</span><br><span class="line">    0x10093e5c8 &lt;+116&gt;: ldp    x29, x30, [sp, #0x30]    ; x29,x30取值，是为了函数返回</span><br><span class="line">    0x10093e5cc &lt;+120&gt;: add    sp, sp, #0x40             ; &#x3D;0x40 ; 释放栈空间</span><br><span class="line">    0x10093e5d0 &lt;+124&gt;: ret</span><br></pre></td></tr></table></figure>

<p>接下来，我们看test的汇编代码情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#96;test:</span><br><span class="line">    ; 开辟空间之前 sp &#x3D; 0x000000016f4c53c0</span><br><span class="line">-&gt;  0x10093e4dc &lt;+0&gt;:   sub    sp, sp, #0x30 ; &#x3D;0x30</span><br><span class="line">    ; 开辟栈空间后，sp&#x3D;0x000000016f4c5390</span><br><span class="line">    0x10093e4e0 &lt;+4&gt;:   ldr    w8, [sp, #0x30]  ; 这是从sp+0x30的位置取值，放在w8寄存器里。</span><br><span class="line">    ; sp+0x30就是开辟当前栈空间之前的位置，也就是viewDidLoad开辟空间的栈顶位置，这个位置是x8寄存器指向的位置，存放的是变量9</span><br><span class="line">    0x10093e4e4 &lt;+8&gt;:   str    w0, [sp, #0x2c]  ; 把w0寄存器的值存放在栈sp+0x2c里头，也就是sp偏移4个字节，正好存放一个int类型的数据。</span><br><span class="line">    0x10093e4e8 &lt;+12&gt;:  str    w1, [sp, #0x28]</span><br><span class="line">    0x10093e4ec &lt;+16&gt;:  str    w2, [sp, #0x24]</span><br><span class="line">    0x10093e4f0 &lt;+20&gt;:  str    w3, [sp, #0x20]</span><br><span class="line">    0x10093e4f4 &lt;+24&gt;:  str    w4, [sp, #0x1c]</span><br><span class="line">    0x10093e4f8 &lt;+28&gt;:  str    w5, [sp, #0x18]</span><br><span class="line">    0x10093e4fc &lt;+32&gt;:  str    w6, [sp, #0x14]</span><br><span class="line">    0x10093e500 &lt;+36&gt;:  str    w7, [sp, #0x10]</span><br><span class="line">    0x10093e504 &lt;+40&gt;:  str    w8, [sp, #0xc]   ; w8寄存器的值放在sp+0xc里，w8&#x3D;9</span><br><span class="line">    0x10093e508 &lt;+44&gt;:  ldr    w8, [sp, #0x2c]  ; 赋值操作 w8&#x3D;1</span><br><span class="line">    0x10093e50c &lt;+48&gt;:  ldr    w9, [sp, #0x28]  ; w9 &#x3D; 2</span><br><span class="line">    0x10093e510 &lt;+52&gt;:  add    w8, w8, w9       ; w8 &#x3D; w8+w9 &#x3D; 1+2 &#x3D; 3</span><br><span class="line">    0x10093e514 &lt;+56&gt;:  ldr    w9, [sp, #0x24]  ; w9 &#x3D; 3</span><br><span class="line">    0x10093e518 &lt;+60&gt;:  add    w8, w8, w9       ; w8 +&#x3D; w9 &#x3D; 3 + 3</span><br><span class="line">    0x10093e51c &lt;+64&gt;:  ldr    w9, [sp, #0x20]</span><br><span class="line">    0x10093e520 &lt;+68&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e524 &lt;+72&gt;:  ldr    w9, [sp, #0x1c]</span><br><span class="line">    0x10093e528 &lt;+76&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e52c &lt;+80&gt;:  ldr    w9, [sp, #0x18]</span><br><span class="line">    0x10093e530 &lt;+84&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e534 &lt;+88&gt;:  ldr    w9, [sp, #0x14]</span><br><span class="line">    0x10093e538 &lt;+92&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e53c &lt;+96&gt;:  ldr    w9, [sp, #0x10]</span><br><span class="line">    0x10093e540 &lt;+100&gt;: add    w8, w8, w9</span><br><span class="line">    0x10093e544 &lt;+104&gt;: ldr    w9, [sp, #0xc]</span><br><span class="line">    0x10093e548 &lt;+108&gt;: add    w0, w8, w9       ; 计算完成</span><br><span class="line">    0x10093e54c &lt;+112&gt;: add    sp, sp, #0x30    ; &#x3D;0x30 ，释放栈空间</span><br><span class="line">    0x10093e550 &lt;+116&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这里会把9这个参数存放在<code>viewDidLoad</code>所开辟的栈空间里。执行test后，1-8会存放在<code>test</code>函数所开辟的空间中，然后把9这个参数从<code>viewDidLoad</code>所开辟的栈空间里拿回来，是通过x8寄存器来定位地址获取9这个参数的。相当于从别人家借东西，会存在sp计算的问题，会影响效率。</p>
<p>我们一定要知道的一点是，栈的读写都是从高位往低位进行读写，栈空间的读写都是基于上述原则进行操作的。<br>以上操作，配合View Memory查看内存中的数据会更清晰。</p>
<h3 id="4-2-1-release下操作"><a href="#4-2-1-release下操作" class="headerlink" title="4.2.1 release下操作"></a>4.2.1 release下操作</h3><p>我们的这一系列操作都是在debug模式下进行的，加法的计算产生的汇编代码竟然是如此繁杂。如果我们切换到release下运行，会有什么情况发生？</p>
<p>在release下，编译器会进行优化，我们的test方法，只是做了调用，没有任何实际意义，所以在release下根本不会有bl指令。</p>
<p>如果我们执行<code>printf(&quot;%d&quot;, sumA(1,2,3,4,5,6,7,8,9));</code>呢？</p>
<p>其实差别不大，经过系统优化之后，就只剩下<code>mov    w8, #0x2d</code>这一句代码了，0x2d = 45。就是这么简单直接。</p>
<h2 id="4-3-验证返回值"><a href="#4-3-验证返回值" class="headerlink" title="4.3 验证返回值"></a>4.3 验证返回值</h2><p>如果返回值超过8个字节，x0寄存器存不下的时候，会通过栈空间来返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;</span><br><span class="line">    struct NumA num;</span><br><span class="line">    num.a &#x3D; a;</span><br><span class="line">    num.b &#x3D; b;</span><br><span class="line">    num.c &#x3D; c;</span><br><span class="line">    num.d &#x3D; d;</span><br><span class="line">    num.e &#x3D; e;</span><br><span class="line">    num.f &#x3D; f;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    struct NumA num &#x3D; getStructA(1,2,3,4,5,6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里呢，我们返回一个结构体，正常来说，结构体的大小是根据结构体中的变量决定的。这里有6个int类型的变量也就是24个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#96;getStructA:</span><br><span class="line">-&gt;  0x1025424a0 &lt;+0&gt;:  sub    sp, sp, #0x20    ; &#x3D;0x20 开辟栈空间</span><br><span class="line">    0x1025424a4 &lt;+4&gt;:  str    w0, [sp, #0x1c]</span><br><span class="line">    0x1025424a8 &lt;+8&gt;:  str    w1, [sp, #0x18]</span><br><span class="line">    0x1025424ac &lt;+12&gt;: str    w2, [sp, #0x14]</span><br><span class="line">    0x1025424b0 &lt;+16&gt;: str    w3, [sp, #0x10]</span><br><span class="line">    0x1025424b4 &lt;+20&gt;: str    w4, [sp, #0xc]</span><br><span class="line">    0x1025424b8 &lt;+24&gt;: str    w5, [sp, #0x8]</span><br><span class="line">    0x1025424bc &lt;+28&gt;: ldr    w9, [sp, #0x1c]</span><br><span class="line">    0x1025424c0 &lt;+32&gt;: str    w9, [x8]</span><br><span class="line">    0x1025424c4 &lt;+36&gt;: ldr    w9, [sp, #0x18]</span><br><span class="line">    0x1025424c8 &lt;+40&gt;: str    w9, [x8, #0x4]</span><br><span class="line">    0x1025424cc &lt;+44&gt;: ldr    w9, [sp, #0x14]</span><br><span class="line">    0x1025424d0 &lt;+48&gt;: str    w9, [x8, #0x8]</span><br><span class="line">    0x1025424d4 &lt;+52&gt;: ldr    w9, [sp, #0x10]</span><br><span class="line">    0x1025424d8 &lt;+56&gt;: str    w9, [x8, #0xc]</span><br><span class="line">    0x1025424dc &lt;+60&gt;: ldr    w9, [sp, #0xc]</span><br><span class="line">    0x1025424e0 &lt;+64&gt;: str    w9, [x8, #0x10]</span><br><span class="line">    0x1025424e4 &lt;+68&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1025424e8 &lt;+72&gt;: str    w9, [x8, #0x14]</span><br><span class="line">    0x1025424ec &lt;+76&gt;: add    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x1025424f0 &lt;+80&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这里我们又看到了一个熟悉的x8寄存器。然后通过w9寄存器，不断的赋值给x8寄存器对应的空间里。那这个x8寄存器是怎么个情况呢，我们返回<code>viewDidLoad</code>对应的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#96;-[ViewController viewDidLoad]:</span><br><span class="line">...</span><br><span class="line">... ;这里也是截取部分代码</span><br><span class="line">0x1025425ac &lt;+64&gt;:  bl     0x1025429b4               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    0x1025425b0 &lt;+68&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 </span><br><span class="line">    0x1025425b4 &lt;+72&gt;:  mov    w0, #0x1</span><br><span class="line">    0x1025425b8 &lt;+76&gt;:  mov    w1, #0x2</span><br><span class="line">    0x1025425bc &lt;+80&gt;:  mov    w2, #0x3</span><br><span class="line">    0x1025425c0 &lt;+84&gt;:  mov    w3, #0x4</span><br><span class="line">    0x1025425c4 &lt;+88&gt;:  mov    w4, #0x5</span><br><span class="line">    0x1025425c8 &lt;+92&gt;:  mov    w5, #0x6</span><br><span class="line">    0x1025425cc &lt;+96&gt;:  bl     0x1025424a0               ; getStructB at ViewController.m:46</span><br><span class="line">-&gt;  0x1025425d0 &lt;+100&gt;: ldp    x29, x30, [sp, #0x40]</span><br><span class="line">    0x1025425d4 &lt;+104&gt;: add    sp, sp, #0x50             ; &#x3D;0x50 </span><br><span class="line">    0x1025425d8 &lt;+108&gt;: ret</span><br></pre></td></tr></table></figure>

<p>我们看到x8寄存器的位置是sp偏移8个字节。也就是返回值所在的空间是在<code>viewDidLoad</code>开辟的栈空间里。</p>
<p>这里会当前返回值存放在<code>viewDidLoad</code>所开辟的栈空间里，因为知道返回的是什么类型的数据，在<code>viewDidLoad</code>开辟空间时，就已经把返回值所需要的空间给预留出来了。通过x8寄存器来定位返回值所在的空间。</p>
<p>那么，这里为什么要偏移8个字节？</p>
<p>我们知道，ARM64对栈的操作是16个字节进行对齐的。而结构体占有24个字节，我们只能通过补齐来确保是16个字节的倍数来开辟空间。</p>
<p>执行对应的方法，对返回值的变量进行存储（根据x8寄存器来定位相应的地址存储变量的值）。</p>
<h1 id="5-函数的局部变量"><a href="#5-函数的局部变量" class="headerlink" title="5. 函数的局部变量"></a>5. 函数的局部变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sumC(int a, int b) &#123;</span><br><span class="line">    int c &#x3D; 10;</span><br><span class="line">    return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    sumC(1,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，进入汇编模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    0x1026ae45c &lt;+68&gt;: mov    w0, #0x1</span><br><span class="line">    0x1026ae460 &lt;+72&gt;: mov    w1, #0x2</span><br><span class="line">-&gt;  0x1026ae464 &lt;+76&gt;: bl     0x1026ae3e8               ; sumC at ViewController.m:75</span><br><span class="line">    0x1026ae468 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x1026ae46c &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30 </span><br><span class="line">    0x1026ae470 &lt;+88&gt;: ret</span><br></pre></td></tr></table></figure>

<p>sumC(1, 2)：1和2分别放在了w0、w1寄存器中。然后执行bl，进入函数sumC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;sumC:</span><br><span class="line">-&gt;  0x1026ae3e8 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x1026ae3ec &lt;+4&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    0x1026ae3f0 &lt;+8&gt;:  str    w1, [sp, #0x8]</span><br><span class="line">    0x1026ae3f4 &lt;+12&gt;: mov    w8, #0xa</span><br><span class="line">    0x1026ae3f8 &lt;+16&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x1026ae3fc &lt;+20&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    0x1026ae400 &lt;+24&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1026ae404 &lt;+28&gt;: add    w8, w8, w9</span><br><span class="line">    0x1026ae408 &lt;+32&gt;: ldr    w9, [sp, #0x4]</span><br><span class="line">    0x1026ae40c &lt;+36&gt;: add    w0, w8, w9</span><br><span class="line">    0x1026ae410 &lt;+40&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x1026ae414 &lt;+44&gt;: ret</span><br></pre></td></tr></table></figure>

<ol>
<li>开辟16个字节的内存空间</li>
<li>把w0放在[sp+0xc]，w1放在[sp+0x8]</li>
<li>w8赋值等于0xa，这里就是我们的局部变量c=10</li>
<li>然后把w8放在[sp+0x4]里头</li>
<li>一堆操作，ret</li>
</ol>
<p>看到了吧，函数的参数和局部变量都是放在栈里的。</p>
<h1 id="6-函数嵌套"><a href="#6-函数嵌套" class="headerlink" title="6. 函数嵌套"></a>6. 函数嵌套</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int funcSum(int a, int b, int c) &#123;</span><br><span class="line">    int d &#x3D; a + b + c;</span><br><span class="line">    printf(&quot;%d&quot;, d);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int totalSum(int a, int b) &#123;</span><br><span class="line">    int c &#x3D; 10;</span><br><span class="line">    int d &#x3D; funcSum(a, b, c);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    totalSum(1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行上面的含有局部变量的嵌套函数，看是怎么在汇编下执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    0x1002fa43c &lt;+64&gt;: bl     0x1002fa8d0               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    &#x2F;&#x2F; totalSum(1, 2)</span><br><span class="line">    0x1002fa440 &lt;+68&gt;: mov    w0, #0x1  &#x2F;&#x2F; 将1存在w0寄存器里</span><br><span class="line">    0x1002fa444 &lt;+72&gt;: mov    w1, #0x2  &#x2F;&#x2F; 2存放在w1寄存器里</span><br><span class="line">-&gt;  0x1002fa448 &lt;+76&gt;: bl     0x1002fa3bc               ; totalSum at ViewController.m:86</span><br><span class="line">    0x1002fa44c &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]     ; x29、x30寄存器取值（lr寄存器获取回家的路）</span><br><span class="line">    0x1002fa450 &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30 </span><br><span class="line">    0x1002fa454 &lt;+88&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这一坨汇编代码，已经看过无数次了，这里不细说了，直接走totalSum看看是怎么处理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;totalSum:</span><br><span class="line">-&gt;  0x1002fa3bc &lt;+0&gt;:  sub    sp, sp, #0x20             ; &#x3D;0x20 </span><br><span class="line">    0x1002fa3c0 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x1002fa3c4 &lt;+8&gt;:  add    x29, sp, #0x10            ; &#x3D;0x10 </span><br><span class="line">    0x1002fa3c8 &lt;+12&gt;: stur   w0, [x29, #-0x4]  ; 把totalSum的参数w0存放在栈底的位置</span><br><span class="line">    0x1002fa3cc &lt;+16&gt;: str    w1, [sp, #0x8]    ; 把w1的值放在栈顶+8个字节的位置</span><br><span class="line">    0x1002fa3d0 &lt;+20&gt;: mov    w8, #0xa          ; 获取局部变量10，放在w8寄存器</span><br><span class="line">    0x1002fa3d4 &lt;+24&gt;: str    w8, [sp, #0x4]    ; w8的值放在sp+4个字节的位置</span><br><span class="line">    0x1002fa3d8 &lt;+28&gt;: ldur   w0, [x29, #-0x4]  ; 重新对w0赋值，取值的位置就是之前w0存放的位置 w0&#x3D;1</span><br><span class="line">    0x1002fa3dc &lt;+32&gt;: ldr    w1, [sp, #0x8]    ; w1取值w1&#x3D;2</span><br><span class="line">    0x1002fa3e0 &lt;+36&gt;: ldr    w2, [sp, #0x4]    ; w2 &#x3D; 10</span><br><span class="line">    0x1002fa3e4 &lt;+40&gt;: bl     0x1002fa35c       ; funcSum at ViewController.m:80 ;执行嵌套函数 funcSum。</span><br><span class="line">    0x1002fa3e8 &lt;+44&gt;: str    w0, [sp]          ; 把w0的值存在sp对应的位置。</span><br><span class="line">    0x1002fa3ec &lt;+48&gt;: ldr    w0, [sp]          ; 获取w0</span><br><span class="line">    0x1002fa3f0 &lt;+52&gt;: ldp    x29, x30, [sp, #0x10] ; 找到回家的路</span><br><span class="line">    0x1002fa3f4 &lt;+56&gt;: add    sp, sp, #0x20     ; &#x3D;0x20 释放</span><br><span class="line">    0x1002fa3f8 &lt;+60&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>stur</code>和<code>ldur</code>。这两个的本质与<code>str</code>和<code>ldr</code>没有区别，只是带<code>u</code>的偏移的是一个负值。</p>
<p>这里也有用到x29寄存器，还有印象吗？x29寄存器就是fp寄存器，指向的是栈底的位置。从栈的存储空间来看，栈底的地址比栈顶大，所以sp栈顶开辟空间都是减去一个值，而用栈底fp做关键值时，要想获取数据都必须在sp-fp之间拿值，所以基于fp的操作都是【减】。</p>
<p>这里为什么把局部变量的值存在w8里面，就是因为w0-w7是存放函数参数的参数，之前说过，w8用来获取局部变量。</p>
<p>funcSum函数的汇编就不说了，与之前的没什么区别。</p>
<p>这里需要提一句的是，为啥要把参数先存放在内存里，然后再取出来，难道就不嫌麻烦吗？其主要目的就是为了保护参数，防止被改变。</p>
<p>到最后w0/x0寄存器还是用来存放返回值。</p>
<h1 id="7-补充内容"><a href="#7-补充内容" class="headerlink" title="7. 补充内容"></a>7. 补充内容</h1><ol>
<li><p>一个函数的参数，在函数执行完毕之后，是否能拿到这个参数的值？我们用4.2小结的代码来解释一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个test函数有9个参数，我们知道，x0-x7（w0-w7）这个8个寄存器是存放函数变量的，如果超过8个参数，则会存放在viewDidLoad函数开辟的栈空间内，也就是说1-8这8个参数是在test函数开辟的栈空间。这8个参数在test函数执行完毕之后，随着空间的释放就拿不到了，而9这个参数存放在<code>viewDidLoad</code>的栈空间，我们还可以拿到。</p>
</li>
<li><p>在4.3小结，我们返回的是一个结构体，而不是一个指针，假如，我们添加一个函数，来调用这个返回的结构体，这个结构体能不能用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;</span><br><span class="line">    struct NumA num;</span><br><span class="line">    num.a &#x3D; a;</span><br><span class="line">    num.b &#x3D; b;</span><br><span class="line">    num.c &#x3D; c;</span><br><span class="line">    num.d &#x3D; d;</span><br><span class="line">    num.e &#x3D; e;</span><br><span class="line">    num.f &#x3D; f;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct NumA returnStruct() &#123;</span><br><span class="line">    struct NumA num &#x3D; getStructA(1,2,3,4,5,6);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    struct NumB num &#x3D; returnStruct();</span><br><span class="line">    printf(&quot;a &#x3D; %d\n&quot;, num.a);  &#x2F;&#x2F; 这里是否能输出，还是会crash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 肯定是可以输出的，在<code>viewDidLoad</code>函数执行时，就已经创建了<code>struct NumB</code>所需要的空间了，返回的数据都存在于<code>viewDidLoad</code>的栈空间里，所以还是可以正常执行的。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>栈：引出SP、FP寄存器。SP：保存栈顶地址，FP：保存栈底的地址。（栈顶的地址比栈底的地址小，所以获取栈顶的值都是通过sub sp, sp #0x10,是减去一个空间，在存值的时候一般都是[sp+#0x08]）</li>
<li>stp/str 存值（16个字节/8个字节）</li>
<li>ldp/ldr 取值（16个字节/8个字节）</li>
<li>stur/ldur 本质上与str/ldr没有区别，带【u】的操作的是一个负值。</li>
<li>bl指令：通过lr(x30)寄存器，保存回家的路，bl跳转到对应的方法</li>
<li>lr寄存器的值会通过保存在栈空间，来确保能够正确的返回。</li>
<li>函数的参数：存放在x0-x7寄存器，超过8个，则放在栈里。</li>
<li>返回值：使用x0寄存器保存，如果大于8个字节，会利用栈空间传递。</li>
<li>函数的局部变量放在栈里，嵌套函数的值也是放在栈里</li>
<li>会把变量的值放在内存里保护起来，用的时候在去取值</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/11/%E9%80%86%E5%90%91/nx-1-iPhone%E8%B6%8A%E7%8B%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/11/%E9%80%86%E5%90%91/nx-1-iPhone%E8%B6%8A%E7%8B%B1/" class="post-title-link" itemprop="url">iPhone越狱</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 11:30:03" itemprop="dateCreated datePublished" datetime="2021-04-11T11:30:03+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><ol>
<li>我们需要一台iPhone手机，根据自己的条件，要求系统是iOS11.0 - 14.3，写这篇博客时所能处理的越狱系统是这个，过期之后请自行查找资料。</li>
<li>越狱的网站：<a href="https://unc0ver.dev/" target="_blank" rel="noopener">https://unc0ver.dev/</a>，下载安装包（ipa文件），可以按照对应的步奏进行操作，本篇所说的有另外一种，使用重签名的机制，比较简单。</li>
</ol>
<h1 id="2-开始越狱"><a href="#2-开始越狱" class="headerlink" title="2. 开始越狱"></a>2. 开始越狱</h1><ol>
<li><p>打开我们的工程文件，请自行下载。</p>
</li>
<li><p>在”Signing &amp; Capabilities” 下，修改”Bundle Identifier”为自己的，修改”Team” 使用”personal team”。</p>
</li>
<li><p>在”Build Phases” - “Run Script”下，先将script运行代码注释掉。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重签名机制的脚本文件</span><br><span class="line">#.&#x2F;appSign.sh</span><br></pre></td></tr></table></figure></li>
<li><p>运行当前的空工程文件到手机上。</p>
</li>
<li><p>运行完成之后，在回到”Build Phases” - “Run Script”下，将注释打开，重新运行。</p>
</li>
<li><p>“unc0ver”这个APP已经出现在手机上，点击APP，直接开始”Jailbreak”。手机重启几次之后，就可以了。</p>
</li>
<li><p>在”Setting”中，可以选择自己想使用的选项。其中 “Restore RootFS”可以回到未越狱状态。</p>
</li>
</ol>
<h1 id="3-为什么使用unc0ver"><a href="#3-为什么使用unc0ver" class="headerlink" title="3. 为什么使用unc0ver"></a>3. 为什么使用unc0ver</h1><ol>
<li>它可以在越狱之后，通过简单的操作回到当初未越狱的状态，对系统侵扰是最低的。</li>
<li>这个是一个安装在手机上的APP，可以随时删除。</li>
<li>开发者更新比较及时。写本篇时，iOS系统可更新的版本是14.4.2，而unc0ver已经支持到14.3版本了。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/10/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-1/" class="post-title-link" itemprop="url">ARM汇编-1 初识汇编</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 22:47:53" itemprop="dateCreated datePublished" datetime="2021-04-10T22:47:53+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-初识汇编"><a href="#1-初识汇编" class="headerlink" title="1. 初识汇编"></a>1. 初识汇编</h1><blockquote>
<p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p>
</blockquote>
<p>一个APP安装在手机上面的可执行文件本质上是二进制文件。因为iPhone手机本质上执行的指令是二进制，是由手机上的CPU执行的。所以静态分析是建立在分析二进制上面。</p>
<h1 id="2-发展历程"><a href="#2-发展历程" class="headerlink" title="2. 发展历程"></a>2. 发展历程</h1><h2 id="2-1-编程语言"><a href="#2-1-编程语言" class="headerlink" title="2.1 编程语言"></a>2.1 编程语言</h2><p>从1946年第一台电子计算机问世，人类和机器的交流方式和语言就成为了软件工程师和计算机从业者的主要研究方向。在过去的几十年，编程语言有了长足的发展。</p>
<h2 id="2-2-机器语言"><a href="#2-2-机器语言" class="headerlink" title="2.2 机器语言"></a>2.2 机器语言</h2><p>计算机的硬件作为一种电路元件，它的输出和输入只能是有电或者没电，也就是所说的高电平和低电平，所以计算机传递的数据是由“0” 和“1”组成的二进制数，所以说二进制的语言是计算机语言的本质。</p>
<h2 id="2-3-汇编语言"><a href="#2-3-汇编语言" class="headerlink" title="2.3 汇编语言"></a>2.3 汇编语言</h2><p>不难看出机器语言作为一种编程语言，灵活性较差可阅读性也很差，为了减轻机器语言带给软件工程师的不适应，人们对机器语言进行了升级和改进：用一些容易理解和记忆的字母，单词来代替一个特定的指令。这就是助记符。</p>
<h2 id="2-4-高级语言"><a href="#2-4-高级语言" class="headerlink" title="2.4 高级语言"></a>2.4 高级语言</h2><p>人们需要设计一个能够不依赖于计算机硬件，能够在不同机器上运行的程序。这样可以免去很多编程的重复过程，提高效率，同时这种语言又要接近于数学语言或人的自然语言。这就诞生了高级编程语言。比如：C、C++、Java、OC、Swift。</p>
<p>我们的代码在终端设备上的执行过程，如下图：<br><img src="media/1171618126145_.pic_hd.jpg" alt="1171618126145_.pic_hd"></p>
<ul>
<li>汇编语言与机器语言一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到汇编语言\机器语言，但汇编语言\机器语言几乎不可能还原成高级语言</li>
</ul>
<h2 id="2-5-汇编语言的特点"><a href="#2-5-汇编语言的特点" class="headerlink" title="2.5 汇编语言的特点"></a>2.5 汇编语言的特点</h2><ul>
<li>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</li>
<li>能够不受编译器的限制，对生成的二进制代码进行完全的控制</li>
<li>目标代码简短，占用内存少，执行速度快</li>
<li>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</li>
<li>不区分大小写，比如mov和MOV是一样的</li>
<li>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</li>
</ul>
<h2 id="2-6-用途"><a href="#2-6-用途" class="headerlink" title="2.6 用途"></a>2.6 用途</h2><ul>
<li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li>
<li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li>
<li>软件安全<ul>
<li>病毒分析与防治</li>
<li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li>
</ul>
</li>
<li>理解整个计算机系统的最佳起点和最有效途径</li>
<li>为编写高效代码打下基础</li>
<li>弄清代码的本质</li>
</ul>
<p>越底层越单纯，但是使用起来越困难，同时也是程序员都需要了解的非常重要的语言。</p>
<h2 id="2-7-汇编语言的分类"><a href="#2-7-汇编语言的分类" class="headerlink" title="2.7 汇编语言的分类"></a>2.7 汇编语言的分类</h2><ul>
<li>8086汇编 （8086处理器时16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（Mac，iOS）</li>
</ul>
<p>在iPhone里面，用的的ARM汇编，又根据CPU的架构不同而有差异。</p>
<table>
<thead>
<tr>
<th align="center">架构</th>
<th align="center">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">armv6</td>
<td align="center">古老的iPhone3G之前，iPod Touch（第一代，第二代）</td>
</tr>
<tr>
<td align="center">armv7</td>
<td align="center">iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3, iPad Mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td align="center">armv7s</td>
<td align="center">iPhone5, iPhone5C, iPad4</td>
</tr>
<tr>
<td align="center">armv64</td>
<td align="center">iPhone5S及以后的设备，iPad Air，iPad Mini2以后</td>
</tr>
</tbody></table>
<h1 id="3-几个必要的知识点"><a href="#3-几个必要的知识点" class="headerlink" title="3. 几个必要的知识点"></a>3. 几个必要的知识点</h1><h2 id="3-1-bit"><a href="#3-1-bit" class="headerlink" title="3.1 bit"></a>3.1 bit</h2><p>bit：表示『位』或者『比特』，是计算机运算的基础单位，是二进制数的最小单元。1 bit就是1位二进制数，只能存放0或者1。</p>
<h2 id="3-2-Byte"><a href="#3-2-Byte" class="headerlink" title="3.2 Byte"></a>3.2 Byte</h2><p>Byte：表示『字节』，是计算机文件大小的基本单位。1Byte = 8bit，表示一个字节可以存放8位无符号数。一个汉子是2个字节，16位。一个英文字母是1个字节。</p>
<p>1个字节可以表示为：0000 0000，1111 1111。</p>
<h2 id="3-3-总线"><a href="#3-3-总线" class="headerlink" title="3.3 总线"></a>3.3 总线</h2><p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p>
<p>总线是一种内部结构，它是cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</p>
<p>在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。</p>
<p>简单来说</p>
<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件交互。</li>
<li>总线就是一根根导线的集合</li>
</ul>
<h3 id="3-3-1-总线分类"><a href="#3-3-1-总线分类" class="headerlink" title="3.3.1 总线分类"></a>3.3.1 总线分类</h3><p>一般情况下分为5大类：</p>
<ol>
<li>数据总线：在CPU与RAM之间来回传送需要处理或需要存储的数据。它的宽度决定了CPU单次数据传送量，也就是数据传送的速度。例如：8086微处理器子长16位，其数据总线宽度也是16位，所以单次最大传递2个字节的数据。</li>
<li>地址总线：用来指定在RAM之中存储的数据的地址。它的宽度决定了CPU的寻址能力。例如8086的地址总线宽度是20位，那么它的寻址能力是1M（2^20）。</li>
<li>控制总线：将微处理器控制单元的信号，传送到周边设备。它的宽度决定了CPU对其他器件的控制能力。</li>
<li>扩展总线：外部设备和计算机主机进行数据通信的总线，例如ISA，PCI总线。</li>
<li>局部总线：取代更高速数据传输的扩展总线。</li>
</ol>
<p>其中数据总线、地址总线、控制总线也统称为系统总线。</p>
<h2 id="3-4-进制"><a href="#3-4-进制" class="headerlink" title="3.4 进制"></a>3.4 进制</h2><p>常用的进制有2进制，8进制，10进制，16进制。<br>2进制：00 11 11 100 101，逢2进1<br>8进制 0 1 2 3 4 5 6 7 10， 逢8进1<br>16进制 0 1 2 3 4 5 6 7 8 9 A B C D E F 10， 逢16进1</p>
<p>还有一些可以自己定义的进制，约定几个符合来表示对应的数据：<br>比如3进制 我们用a 3 1表示，通常约定好一些符合来表示对应的数据，以此来达到加密的效果。</p>
<p>运算等一些列就不说了<del>~</del></p>
<h2 id="3-5-数据的宽度"><a href="#3-5-数据的宽度" class="headerlink" title="3.5 数据的宽度"></a>3.5 数据的宽度</h2><p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int test() &#123;</span><br><span class="line">    int cTemp &#x3D; 0x1FFFFFFFF;</span><br><span class="line">    return cTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个int类型的变量，但是赋值的是9位16进制数。但是这里打印cTemp的值发现是-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p cTemp</span><br><span class="line">(int) $0 &#x3D; -1</span><br><span class="line">(lldb) p &amp;cTemp</span><br><span class="line">(int *) $1 &#x3D; 0x000000016f8e926c</span><br><span class="line">(lldb) x 0x000000016f8e926c</span><br><span class="line">0x16f8e926c: ff ff ff ff b0 92 8e 6f 01 00 00 00 88 a5 51 00  .......o......Q.</span><br><span class="line">0x16f8e927c: 01 00 00 00 10 00 00 00 00 00 00 00 02 00 00 00  ................</span><br><span class="line">(lldb) p (uint)cTemp</span><br><span class="line">(uint) $0 &#x3D; 4294967295</span><br></pre></td></tr></table></figure>

<p>通过上面的打印，发现cTemp所在的地址钟存放的是ff ff ff ff，而前面的1没有了，这就是发生了溢出。但是通过转换无符号数，发现是可以正常打印的。这就说明了，地址钟存放的数据是没有发生变化的，只是由于位数的限制导致的有符号和无符号的区别，导致的数据不一致。</p>
<p>在通常的二进制中，第一位表示正负，0表示正 1表示负。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; int 4个字节，表示32位。第一位为符号为。</span><br><span class="line"> F    F    F    F    F    F    F    F</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>这里提一嘴我们经常用的宽带，都是100M的，200M的，但是这个的意思是100Mbps，说的也是宽度，除以8才是对应的数据传输速度。</p>
<h1 id="4-CPU-amp-寄存器"><a href="#4-CPU-amp-寄存器" class="headerlink" title="4. CPU &amp; 寄存器"></a>4. CPU &amp; 寄存器</h1><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<ul>
<li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制。</li>
<li>不同的CPU，寄存器的个数、结构是不相同的。</li>
</ul>
<h2 id="4-1-浮点和向量寄存器"><a href="#4-1-浮点和向量寄存器" class="headerlink" title="4.1 浮点和向量寄存器"></a>4.1 浮点和向量寄存器</h2><p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p>
<ul>
<li>浮点寄存器 64位: D0 - D31 32位: S0 - S31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<ul>
<li>向量寄存器 128位:V0-V31</li>
</ul>
<h2 id="4-2-通用寄存器"><a href="#4-2-通用寄存器" class="headerlink" title="4.2 通用寄存器"></a>4.2 通用寄存器</h2><p>通用寄存器也称数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。</p>
<p>ARM64拥有有32个64位的通用寄存器 x0 到 x30，以及XZR(零寄存器),这些通用寄存器有时也有特定用途。</p>
<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!</li>
</ul>
<p><img src="arm-register.jpg" alt=""></p>
<p>图片上标注了1、2、3、4分别有所对应。<br>1 - 点击进入汇编<br>2 - 进入汇编之后，选择『All Variables, register』，会显示如图所示<br>3 - 浮点和向量寄存器，存放对应的v0-v31，d0-d31，s0-s31<br>4 - 通用寄存器，存放x0-x28，fp，lr，sp，pc，w0-w28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov x0, #0xa0           ; x0 &#x3D; 0xa0</span><br><span class="line">mov x1,#0x00            ; x1 &#x3D; 0x00</span><br><span class="line">add x1, x0, #0x14       ; x1 &#x3D; x0 + 0x14</span><br><span class="line">mov x0,x1               ; x0 &#x3D; x1</span><br></pre></td></tr></table></figure>

<h2 id="4-3-pc寄存器-program-counter"><a href="#4-3-pc寄存器-program-counter" class="headerlink" title="4.3 pc寄存器(program counter)"></a>4.3 pc寄存器(program counter)</h2><ul>
<li><p>为指令指针寄存器，它指示了CPU当前要读取指令的地址</p>
</li>
<li><p>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</p>
</li>
<li><p>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义</p>
<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010</li>
<li>可以当做数据 0xE003008AA</li>
<li>也可以当做指令 mov x0, x8</li>
</ul>
</li>
<li><p>CPU根据什么将内存中的信息看做指令？</p>
<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul>
</li>
</ul>
<h2 id="4-4-高速缓存"><a href="#4-4-高速缓存" class="headerlink" title="4.4 高速缓存"></a>4.4 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
<h2 id="4-5-bl指令"><a href="#4-5-bl指令" class="headerlink" title="4.5 bl指令"></a>4.5 bl指令</h2><p>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令。</p>
<p>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<br>mov x0,#10、mov x1,#20。但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p>
<p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p>
<h3 id="4-5-1-bl指令-–-练习"><a href="#4-5-1-bl指令-–-练习" class="headerlink" title="4.5.1 bl指令 – 练习"></a>4.5.1 bl指令 – 练习</h3><p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _A,_B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">    mov x0,#0xa0</span><br><span class="line">    mov x1,#0x00</span><br><span class="line">    add x1, x0, #0x14</span><br><span class="line">    mov x0,x1</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0,#0x0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>打开Xcode，新建一个工程，在新建文件是选择 『Assembly File』，生成的是『.s』文件。然后将上面的代码复制粘贴。</p>
</li>
<li><p>在ViewController中，进行函数声明。这里需要注意的是，方法明需要一致。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数的声明~~</span><br><span class="line">int A();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>viewDidLoad</code>中直接调用<code>A()</code>，打断点，然后跳转到汇编。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0, #0xa0       ; x0 &#x3D; a0</span><br><span class="line">    mov x1,#0x00        ; x1 &#x3D; 0</span><br><span class="line">    add x1, x0, #0x14   ; x1 &#x3D; x0 + 0x14</span><br><span class="line">    mov x0,x1           ; x0 &#x3D; x1</span><br><span class="line">    bl _B               ; 跳转到方法 _B --&gt; 执行B</span><br><span class="line">    mov x0, #0x0        ; 从B回来之后执行 x0 &#x3D; 0</span><br><span class="line">    ret                 ; return, 继续点击会发现啥？</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10   ; x0 +&#x3D; 10</span><br><span class="line">    ret                 ; return，方法结束回到A继续执行</span><br></pre></td></tr></table></figure>

<p>这里会有一点问的哈~会导致循环了。为啥会导致循环了呢？翻下一章。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ol>
<li>汇编基础知识，发展、用途、特点</li>
<li>几个知识点：bit，Byte，总线，数据宽度</li>
<li>CPU 寄存器。浮点寄存器（64位: D0 - D31 32位: S0 - S31）；向量寄存器（128位:V0-V31）；通用寄存器（32位w0-w28，64位x0-x28），PC寄存器。</li>
<li>bl指令</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/10/%E9%80%86%E5%90%91/mima-1-RSA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E9%80%86%E5%90%91/mima-1-RSA/" class="post-title-link" itemprop="url">密码学_RSA</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 15:25:44" itemprop="dateCreated datePublished" datetime="2021-04-10T15:25:44+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-密码学"><a href="#1-密码学" class="headerlink" title="1. 密码学"></a>1. 密码学</h1><h2 id="1-1-密码学概述"><a href="#1-1-密码学概述" class="headerlink" title="1.1 密码学概述"></a>1.1 密码学概述</h2><p>密码学是指研究信息加密，破解密码的技术科学。密码学的起源可追溯到2000年前。而当今的密码学是以数学为基础的。</p>
<h2 id="1-2-发展"><a href="#1-2-发展" class="headerlink" title="1.2 发展"></a>1.2 发展</h2><ol>
<li>在1976年以前，所有的加密方法都是同一种模式：加密、解密使用同一种算法。在交互数据的时候，彼此通信的双方就必须将规则告诉对方，否则没法解密。那么加密和解密的规则（简称密钥），它保护就显得尤其重要。传递密钥就成为了最大的隐患。这种加密方式被成为对称加密算法（symmetric encryption algorithm）</li>
<li>1976年，两位美国计算机学家 迪菲（W.Diffie）、赫尔曼（ M.Hellman ） 提出了一种崭新构思，可以在不直接传递密钥的情况下，完成密钥交换。这被称为“<B>迪菲赫尔曼密钥交换</B>”算法。开创了密码学研究的新方向。</li>
<li>1977年三位麻省理工学院的数学家 <B>罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）</B>一起设计了一种算法，可以实现<B>非对称加密</B>。这个算法用他们三个人的名字命名，叫做<B>RSA算法</B>。</li>
</ol>
<h1 id="2-RSA"><a href="#2-RSA" class="headerlink" title="2. RSA"></a>2. RSA</h1><p>RSA加密方式比较特殊，需要两个密钥：公开密钥简称公钥（publickey）和私有密钥简称私钥（privatekey）。公钥加密，私钥解密；私钥加密，公钥解密。这个加密算法就是伟大的RSA。</p>
<h2 id="2-1-欧拉函数"><a href="#2-1-欧拉函数" class="headerlink" title="2.1 欧拉函数"></a>2.1 欧拉函数</h2><p>首先考虑什么是离散对数：在整数中，离散对数（英语：Discrete logarithm）是一种基于同余运算和<a href="https://baike.baidu.com/item/%E5%8E%9F%E6%A0%B9" target="_blank" rel="noopener">原根</a>的一种对数运算。</p>
<p>互质关系：如果两个正整数，除了1以外，没有其他公因数，我们就称这两个数是互质关系（coprime）。</p>
<p>有一个正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？<br>计算这个值的方式就是<b>欧拉函数</b>。用φ(n)来表示。φ -&gt; phi</p>
<p>例如：</p>
<blockquote>
<p>计算8的欧拉函数，和8互质的数有1、3、5、7<br>φ(8) = 4</p>
<p>例如计算7的欧拉函数，和7互质的数有1、2、3、4、5、6<br>φ(7) = 6</p>
<p>例如计算56的欧拉函数<br>φ(56) = φ(8) * φ(7) = 4 * 6 = 24</p>
</blockquote>
<h3 id="2-2-1-欧拉函数的特性："><a href="#2-2-1-欧拉函数的特性：" class="headerlink" title="2.2.1 欧拉函数的特性："></a>2.2.1 欧拉函数的特性：</h3><ol>
<li>当n是质数的时候，φ(n)=n-1。</li>
<li>如果n可以分解成两个互质的整数之积，如n=A<em>B则：φ(A*B)=φ(A)</em> φ(B)</li>
</ol>
<p>根据以上两点得到：<br>如果N是两个质数P1 和 P2的乘积则φ(N)=φ(P1)* φ(P2)=(P1-1)*(P2-1)</p>
<h2 id="2-2-欧拉定理"><a href="#2-2-欧拉定理" class="headerlink" title="2.2 欧拉定理"></a>2.2 欧拉定理</h2><p>如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。</p>
<p>m^φ(n) % n = 1</p>
<p>也就是说，m的φ(n)次方减去1，能被n整出。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; m &#x3D; 3， n &#x3D; 11, φ(n) &#x3D; 10</span><br><span class="line">&#x2F;&#x2F; 再Python3的环境下，快速输出结果，如下</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3**10%11</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-费马小定理"><a href="#2-2-1-费马小定理" class="headerlink" title="2.2.1 费马小定理"></a>2.2.1 费马小定理</h3><p>欧拉定理的特殊情况：如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1。</p>
<p>m^(n-1) % n = 1</p>
<p>这就是一开始所说的那种情况，如果n为质数，则φ(n)= n-1</p>
<h2 id="2-3-模反元素"><a href="#2-3-模反元素" class="headerlink" title="2.3 模反元素"></a>2.3 模反元素</h2><p>如果两个正整数e和x互质，那么一定可以找到整数d，使得 ed-1 被x整除。那么d就是e对于x的“模反元素”。<br>e*d % x = 1</p>
<h2 id="2-4-公式推导过程："><a href="#2-4-公式推导过程：" class="headerlink" title="2.4 公式推导过程："></a>2.4 公式推导过程：</h2><ol>
<li><p>1^k = 1, 1的k次方等于1</p>
</li>
<li><p>1 * m = m</p>
</li>
<li><p>根据欧拉定理：m^φ(n) % n = 1，公式两边分别执行k次方。</p>
</li>
<li><p>(m^φ(n) % n)^k = 1^k 公式简化后：</p>
</li>
<li><p>m^k*φ(n) % n = 1，等式两边分别乘以m</p>
</li>
<li><p>(m^k*φ(n) % n) * m = 1 * m 简化后：</p>
</li>
<li><p>m^k*φ(n)+1 % n = m</p>
</li>
<li><p>根据模反元素的公式：e<em>d % x = 1，则 e</em>d = k*x + 1</p>
</li>
</ol>
<p>到这里，有没有发现什么？看推导的第7步和第8步的公式，k<em>φ(n)+1 和 k</em>x+1是不是很相似。则 e * d = k*φ(n)+1</p>
<p>那最后是不是可以得出：m^ed % n = m</p>
<p>这就是大名鼎鼎的<b>迪菲赫尔曼密钥交换</b>。<br>我们假设 m = 3，n = 17，<br>服务器生成随机数 e = 15，客户端生成随机数 d = 13</p>
<p>服务器 m^e % n，结果是 3^15 % 17 = 6， 把明文6传给客户端。<br>客户端 m^d % n，结果是 3^13 % 17 = 12， 把明文12传给服务器。</p>
<p>两端拿到的数据分别进行解密：<br>客户端 6^13 % 17 = 10<br>服务器 12^15 % 17 = 10</p>
<p><b>迪菲赫尔曼密钥交换</b>:<br>3^15<em>12 % n = 3^13</em>15 % n<br>m^e<em>d % n = 10 = m^d</em>e % n</p>
<p>从这个时候开始，开创了密码学研究的新方向，也为RSA加密打下了基础。RSA对上面的公式进行了拆分：</p>
<p>m^e % n = c<br>c^d % n = m</p>
<p>这就是RSA诞生的原理。其中<br>m^e % n = c 进行加密<br>c^d % n = m 进行解密</p>
<p>n、e是公钥，n、d是私钥，m是明文，c是密文。</p>
<p>验证： m = 4， n = 15， φ(n) = 8， e = 3，<br>求出d（d是e对于φ(n)的“模反元素”） d = 11，19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; python3环境</span><br><span class="line">&gt;&gt;&gt; 4**33%15</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加入m &#x3D; 5</span><br><span class="line">&gt;&gt;&gt; 5**33%15</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加入m &#x3D; 15</span><br><span class="line">&gt;&gt;&gt; 15**33%15</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>到此，就看到了整个的RAS的基本过程。</p>
<h1 id="3-RSA总结"><a href="#3-RSA总结" class="headerlink" title="3. RSA总结"></a>3. RSA总结</h1><h2 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h2><ol>
<li>n会非常大，长度一般为1024个二进制位。（目前人类已经分解的最大整数，232个十进制位，768个二进制位）</li>
<li>由于需要求出φ(n)，所以根据欧函数特点，最简单的方式n 由两个质数相乘得到: 质数：p1、p2，Φ(n) = (p1 -1) * (p2 - 1)</li>
<li>最终由φ(n)得到e 和 d。总共生成6个数字：p1、p2、n、φ(n)、e、d</li>
</ol>
<h2 id="3-2-关于RSA的安全："><a href="#3-2-关于RSA的安全：" class="headerlink" title="3.2 关于RSA的安全："></a>3.2 关于RSA的安全：</h2><p>除了公钥用到了n和e 其余的4个数字是不公开的。目前破解RSA得到d的方式如下：</p>
<ol>
<li>要想求出私钥 d。由于e<em>d = φ(n)</em>k + 1。要知道e和φ(n);</li>
<li>e是知道的，但是要得到 φ(n)，必须知道p1 和 p2。</li>
<li>由于 n=p1*p2。只有将n因数分解才能算出。</li>
</ol>
<h2 id="3-3-RSA特点"><a href="#3-3-RSA特点" class="headerlink" title="3.3 RSA特点"></a>3.3 RSA特点</h2><ol>
<li>相对来说比较安全（非对称加密）</li>
<li>效率低 </li>
<li>加密小数据，一般加密核心数据</li>
</ol>
<h1 id="4-终端演示"><a href="#4-终端演示" class="headerlink" title="4. 终端演示"></a>4. 终端演示</h1><p>由于Mac系统内置OpenSSL(开源加密库)，所以我们可以直接在终端上使用命令来玩RSA。OpenSSL中RSA算法常用指令主要有三个：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">genrsa</td>
<td align="left">生成并输入一个RSA密钥</td>
</tr>
<tr>
<td align="left">rsatul</td>
<td align="left">使用RSA密钥进行加密、解密、签名和验证等运算</td>
</tr>
<tr>
<td align="left">rsa</td>
<td align="left">处理RSA密钥的格式转化等问题</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用命令行演示</span><br><span class="line">&#x2F;&#x2F; 1. 生成RSA密钥，密钥长度为1024bit</span><br><span class="line">&gt; openssl genrsa -out private.pem 1024</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 从私钥中提取公钥</span><br><span class="line">&gt; openssl rsa -in private.pem -pubout -out public.pem</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 将私钥转换为明文信息</span><br><span class="line">&gt; openssl rsa -in private.pem -text -out private.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 通过公钥加密 首先创建一个message.txt文件，并输入内容</span><br><span class="line">&gt; vi message.txt </span><br><span class="line">&gt; openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5. 通过私钥解密</span><br><span class="line">&gt; openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6. 通过私钥加密数据</span><br><span class="line">&gt; openssl rsautl -sign -in message.txt -inkey private.pem -out penc.txt</span><br><span class="line">&#x2F;&#x2F; 7. 公钥解密数据</span><br><span class="line">&gt; openssl rsautl -verify -in penc.txt -inkey public.pem -pubin -out pdec.txt</span><br></pre></td></tr></table></figure>

<h1 id="5-代码演示"><a href="#5-代码演示" class="headerlink" title="5. 代码演示"></a>5. 代码演示</h1><p>由于Xcode是没有办法直接使用pem文件的，所以需要转化，首先需要生成请求的cer文件（可以理解为证书请求文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl req -new -key private.pem -out rsacert.csr</span><br><span class="line">-----</span><br><span class="line">&gt; Country Name (2 letter code) []:CN</span><br><span class="line">&gt; State or Province Name (full name) []:Beijing</span><br><span class="line">&gt; Locality Name (eg, city) []:Chaoyang</span><br><span class="line">&gt; Organization Name (eg, company) []:Wangjing</span><br><span class="line">&gt; Organizational Unit Name (eg, section) []:alan.com</span><br><span class="line">&gt; Common Name (eg, fully qualified host name) []:alan.com</span><br><span class="line">&gt; Email Address []:alan@163.com</span><br><span class="line"></span><br><span class="line">&gt; Please enter the following &#39;extra&#39; attributes</span><br><span class="line">&gt; to be sent with your certificate request</span><br><span class="line">&#x2F;&#x2F; 这里不使用密码，其他根据要求自己填写。</span><br><span class="line">&gt; A challenge password []:</span><br></pre></td></tr></table></figure>

<p>拿到csr文件之后，需要去请求签名文件，一般用于服务器，下发证书，比如https</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt</span><br></pre></td></tr></table></figure>

<p>然后我们通过crt证书生成Xcode可用的p12证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt</span><br><span class="line">&#x2F;&#x2F; 注意这里需要输入密码，123456</span><br></pre></td></tr></table></figure>

<p>在iOS系统钟，ctr文件是无法直接使用的，所以还需要把ctr文件转化为der文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl x509 -outform der -in rsacert.crt -out rsacert.der</span><br></pre></td></tr></table></figure>


<p>生成的rsacert.der和p.p12文件就相当于我们要使用的公钥和私钥。</p>
<p>正常情况下，客户端不会同时存在公钥和私钥，因为这样做没有意义。客户端一般存放的是公钥，私钥在服务端。代码使用就不放了，这里有一套<a href="https://github.com/ideawu/Objective-C-RSA" target="_blank" rel="noopener">Github Objective-c-RSA</a>代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>RSA终端命令</li>
<li>RSA特点<ul>
<li>RSA安全系数非常高（整个业务逻辑非常安全）</li>
<li>加密效率非常低（不能做大数据加密）</li>
<li>用来加密关键数据</li>
</ul>
</li>
</ul>
<p>感谢~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/15/OC%E5%85%B6%E5%AE%83/Universal-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/OC%E5%85%B6%E5%AE%83/Universal-Link/" class="post-title-link" itemprop="url">Universal Link</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 17:33:57" itemprop="dateCreated datePublished" datetime="2020-03-15T17:33:57+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Universal-Links？"><a href="#什么是Universal-Links？" class="headerlink" title="什么是Universal Links？"></a>什么是Universal Links？</h2><p>iOS9之后，Apple推出的一种通用链接，能够方便的通过https链接来启动APP，通过唯一的网址，不需要特别的schema就可以链接一个特定的视图到APP。<br>这也就设计到universal links的几个特性：</p>
<ol>
<li>Unique：唯一性，不像自定义Url schemes那样，因为他使用到了你网站的http或者https链接</li>
<li>Secure：安全性，当用户安装应用时，iOS会检测你上传到服务器上的文件，以确保你的网站允许其代表应用打开你的应用。</li>
<li>Flexible：灵活性，当没有安装你的app时universal links也是可以正常使用的，当点击link时会直接在safari中打开url。</li>
<li>Simple：一个url可以为app和web提供服务。</li>
<li>Private：其他app可以与你的app通信，不需要知道你的应用程序是否安装。</li>
</ol>
<h2 id="配置Universal-links"><a href="#配置Universal-links" class="headerlink" title="配置Universal links"></a>配置Universal links</h2><p>配置Universal links需要网站与app协同处理，两端都需要做一些工作。</p>
<h3 id="创建并上传关联文件"><a href="#创建并上传关联文件" class="headerlink" title="创建并上传关联文件"></a>创建并上传关联文件</h3><p>首先，你的网站必须支持https。<br><br>然后，创建apple-app-site-association文件，注意一定是没有.json后缀的，在未压缩的情况下，文件大小不能超过128KB。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;&#x2F;wwdc&#x2F;news&#x2F;&quot;, &quot;&#x2F;videos&#x2F;wwdc&#x2F;2015&#x2F;*&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>appID：</b>是由TeamID+BundleId组成，TeamID可以通过开发者账号来查看，Bundle ID可以直接在工程里查看。<br></p>
<p><b>paths：</b>是一个数组类型用来指定网站路径，并且是大小写敏感的：<br>使用* 指定整个网站，在域名下的任何地址都可以打开App。<br><br>“/wwdc/news/”指定链接，以指定网站的某些部分.<br><br>还可以使用“?”匹配任何单个字符，”/foo/*/bar/201?/mypage”</p>
<p>创建好apple-app-site-association文件后，将其上传到web服务器的跟目录下或者<code>.well-known</code>子目录下。<b>文件是通过https访问不需要有任何重定向。</b>然后你可以直接在浏览器中输入domain/apple-app-site-association或者domain/.well-known/apple-app-site-association访问你所上传的文件。</p>
<p>通过Apple的测试网站可以检测你上传的文件是否正确。<a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">传送门</a></p>
<p><b>注意：</b></p>
<blockquote>
<p>在用Nginx处理文件的MIME Type配置时，在域名下针对该文件进行处理，也就是说response的Content-Type必须设置为”application/json“。<br>使用Nginx处理文件的MIME Type配置，在server的某个域名下针对该文件处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;apple-app-site-association &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><ol>
<li><p>需要支持Universal links的话，需要将开发者中心的配置APPlication Services列表中的ASSociated Domains变成Enabled。</p>
</li>
<li><p>在项目targets-&gt;Capabilities-&gt;Associated Domains中配置App link。在这里需要注意一下，有的域名为<a href="http://www.abc.com和abc.com，这两个对于Universal" target="_blank" rel="noopener">www.abc.com和abc.com，这两个对于Universal</a> links来说是不同的域名，所以，如果你的网站是这两个都需要做处理的话，需要将这两个域名都放在associate domains列表下。在添加时都要将<code>applinks:</code>放在域名前面。<br> 例如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applinks:www.abc.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要手动的添加<code>entitlements</code>，当添加domain之后，系统会自动添加相应的文件到工程，如果没有的情况下，只能通过手动添加。 </p>
</li>
<li><p>在AppDelegate中调用方法来处理Universal links的回调。</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> * _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ([userActivity.activityType isEqualToString:<span class="built_in">NSUserActivityTypeBrowsingWeb</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *webUrl = userActivity.webpageURL;</span><br><span class="line">        <span class="keyword">if</span> ([webUrl.host isEqualToString:<span class="string">@"domain"</span>]) &#123;</span><br><span class="line">            <span class="comment">//打开对应页面</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不能打开，使用Safari 打开</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication]openURL:webUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里回传过来一个<code>NSUserActivity</code>类型的数据，对该数据处理来跳转相应的界面。也就不再多说了。<br>到此整体的流程就已经处理完了。相关的内容介绍还是推荐看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2" target="_blank" rel="noopener">官方文档</a>，写的比较细致。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>apple-app-site-association文件上传一定不要有<code>.json</code>后缀，那些隐藏后缀名的需要注意。</li>
<li>web server必须支持https</li>
<li>上传文件最好在根目录下，官方说也可以在根目录下的<code>.well-known</code>目录下。</li>
<li>Xcode中配置Associated Domians时，一定要添加<code>applinks:</code>前缀。最多添加20-30条。</li>
<li>app在<b>安装</b>的时候会访问<code>domain</code>获取<code>apple-app-site-association</code>文件,这个可以通过抓包来获取。不是在打开app时访问。</li>
<li>直接dev打包到手机上应该就可以测试，保证网络畅通。</li>
<li>最简单的方式检测Universal links是否有效，将那个链接拷贝的备忘录中（imessage、邮件），直接点击链接会跳转到App，或者长按，会在弹出的ActionSheet中第二个显示<code>在xxx中打开</code>。</li>
<li>一定是从上级页面（网页）<b>点击触发</b> 的Universal links。</li>
<li>用 Safari 打开目标域名，或者在其他 App 里用 SFSafariViewController, WKWebView, UIWebView 打开目标域名，都可以达到效果。</li>
</ol>
<h2 id="那些坑"><a href="#那些坑" class="headerlink" title="那些坑"></a>那些坑</h2><h3 id="1-跨域跳转：饿了么遇到的一个问题"><a href="#1-跨域跳转：饿了么遇到的一个问题" class="headerlink" title="1. 跨域跳转：饿了么遇到的一个问题"></a>1. 跨域跳转：<a href="http://mobilists.eleme.io/2016/01/10/%E7%AA%81%E7%A0%B4%E5%BE%AE%E4%BF%A1%E8%B7%B3%E8%BD%AC%E9%99%90%E5%88%B6%EF%BC%8DUniversal-Links%E9%82%A3%E4%BA%9B%E5%9D%91/" target="_blank" rel="noopener">饿了么遇到的一个问题</a></h3><p>这里的问题，就是我们将链接复制在备忘录里发现可以拉起App，但是放在网页里，点击却是没有任何效果，这个几乎就是跨域的锅。</p>
<p>这个应该是在iOS9.2之后出现的问题。假设当前网页是abc.com/a，在这里有一个链接跳转到abc.com/b,还是在同一个域名abc.com下。这时点击，系统将不会进行拉起App的操作，必须在不同的域名下比如abcd.com/b，这样才会根据关联文件去判断是否要拉起app。这个时候就需要在Xcode中添加一个域名在碰到跨域问题不能拉起App时，链接改为其他的域名。<br><a href="https://stackoverflow.com/questions/32751225/ios9-universal-links-does-not-work/32751734#32751734" target="_blank" rel="noopener">这里也有解释</a></p>
<h3 id="2-选择性跳转"><a href="#2-选择性跳转" class="headerlink" title="2. 选择性跳转"></a>2. 选择性跳转</h3><p>这个也是一个坑，苹果会通过Universal links记录用户的行为习惯，当你通过一个Universal links成功的拉起了App，这时你发现在status bar右上角有一个小按钮（带一个小箭头）。当你点击了之后会成功的在Safari中打开，这时，苹果就认为你不需要这个Universal links拉起App，此后在通过这个Universal links点击时，都是在safari或者网页中打开，不会再拉起App。这个是有办法补救的，通过在Safari中点击链接长按，在app中打开。此后通过Universal links就可以拉起App了。也就说，苹果会记录最后一次Universal links的跳转情况来判断是否需要拉起app。</p>
<p>这里感觉第一个的跨域跳转与第二个的选择性跳转是很类似的，第一个在当前域名下点击Universal links不能拉起app就相当于当前系统认为你这个universal links本身就在浏览器中打开的，认为不需要拉起app。</p>
<blockquote>
<p>When a user taps a universal link that you handle, iOS also examines the user’s recent choices to determine whether to open your app or your website. For example, a user who has tapped a universal link to open your app can later choose to open your website in Safari by tapping a breadcrumb button in the status bar. After the user makes this choice, iOS continues to open your website in Safari until the user chooses to open your app by tapping OPEN in the Smart App Banner on the webpage.</p>
</blockquote>
<h3 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h3><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2" target="_blank" rel="noopener">官方文档</a></p>
<p>通过Apple的测试网站可以检测你上传的文件是否正确。<a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">传送门</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
