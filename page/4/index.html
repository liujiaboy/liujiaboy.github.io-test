<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/page/4/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content=" Swift">
<meta property="article:tag" content=" GitHub">
<meta property="article:tag" content=" CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/10/%E9%80%86%E5%90%91/mima-2-Hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E9%80%86%E5%90%91/mima-2-Hash/" class="post-title-link" itemprop="url">Hash</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-10 17:38:40" itemprop="dateCreated datePublished" datetime="2021-05-10T17:38:40+08:00">2021-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 10:29:59" itemprop="dateModified" datetime="2021-05-31T10:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="base64-补充"><a href="#base64-补充" class="headerlink" title="base64 补充"></a>base64 补充</h1><blockquote>
<p>Base64就是一种基于64个字符来表示二进制数据的方法。没6个比特为一个单元，</p>
</blockquote>
<p>具体可以查看<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">base64的解释</a></p>
<p>64个字符包括 <code>A-Z a-z 0-9 + /</code>，再加上<code>=</code>用来补位，加上【等号】就是65个。<br>64个字符分别对应 <code>0 - 63</code> 这64个数字，64个数字对应着4个6位二进制数。</p>
<p><img src="base64.jpg" alt=""></p>
<p>下方代码是在iOS中的一种编码、解码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;编码</span><br><span class="line">- (NSString *)base64Encode:(NSString *)string&#123;</span><br><span class="line">    NSData *data &#x3D; [string dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    return [data base64EncodedStringWithOptions: 0];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;解码</span><br><span class="line">- (NSString *)base64Decode:(NSString *)string&#123;</span><br><span class="line">    NSData *data &#x3D; [[NSData alloc] initWithBase64EncodedString:string options:0];</span><br><span class="line">    return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>base64只适用于表示二进制文件。</li>
<li>base64编码后，文件数量变多，不使用与大型数据。</li>
<li>base64和数据一一对应，不安全。</li>
</ol>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。</p>
<p>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>hash不是加密算法。</p>
<h2 id="Hash特点"><a href="#Hash特点" class="headerlink" title="Hash特点"></a>Hash特点</h2><ul>
<li>算法公开</li>
<li>对相同数据运算，得到的结果是一样的</li>
<li>对不同数据运算，得到的结果是定长的，如MD5得到的结果默认是128位,32个字符（16进制标识）。</li>
<li>无法逆运算</li>
<li>信息摘要，信息“指纹”，是用来做数据识别的</li>
</ul>
<h2 id="常见的散列算法"><a href="#常见的散列算法" class="headerlink" title="常见的散列算法"></a>常见的散列算法</h2><p>常见的就是MD5，SHA等等。</p>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。</p>
<p>MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。</p>
<p>1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的资料，专家一般建议改用其他算法。</p>
<p>2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</p>
<p>md5现常用于文件校验。</p>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><blockquote>
<p>安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的几率很高。</p>
</blockquote>
<p>SHA家族的算法分别为：</p>
<ol>
<li>SHA-0：1993年发布，是SHA-1的前身。</li>
<li>SHA-1：1995年发布，SHA-1在许多安全协议中广为使用，包括TLS、GnuPG、SSH、S/MIME和IPsec，是MD5的后继者。但SHA-1的安全性在2010年以后已经不被大多数的加密场景所接受。</li>
<li>SHA-2：2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。SHA-2目前没有出现明显的弱点。虽然至今尚未出现对SHA-2有效的攻击，但它的算法跟SHA-1基本上仍然相似。</li>
<li>SHA-3：2015年正式发布，由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。</li>
</ol>
<h2 id="MD5-SHA对比"><a href="#MD5-SHA对比" class="headerlink" title="MD5 - SHA对比"></a>MD5 - SHA对比</h2><p><img src="hash.jpg" alt=""></p>
<h2 id="Hash-用途"><a href="#Hash-用途" class="headerlink" title="Hash 用途"></a>Hash 用途</h2><ul>
<li>用户密码加密</li>
<li>搜索引擎</li>
<li>版权</li>
<li>数字签名</li>
</ul>
<h3 id="密码加密逻辑："><a href="#密码加密逻辑：" class="headerlink" title="密码加密逻辑："></a>密码加密逻辑：</h3><p>客户端在注册账号密码时，是必须加密的，但是怎么能保证密码的安全，那最好就是所有人都不知道，前后端都不知道密码，所以之前说的RSA加密就不行了，只要知道公钥或者私钥就可以破解了。</p>
<p>常用的加密方式有以下4种：</p>
<ol>
<li>直接使用MD5</li>
<li>MD5加盐</li>
<li>HMAC加密</li>
<li>在HAC加密方案上添加时间戳等方案</li>
</ol>
<h4 id="直接使用MD5"><a href="#直接使用MD5" class="headerlink" title="直接使用MD5"></a>直接使用MD5</h4><p>将密码等重要的文本内容直接使用md5进行加密，但是md5现在也不安全，大部分md5加密之后都可以被破解。<a href="https://www.cmd5.com/" target="_blank" rel="noopener">md5在线破解</a></p>
<p>md5现在常用于文件校验。</p>
<p>所以有了第二种方式：</p>
<h4 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h4><p>直接使用md5加密不算安全，那么就在文本上直接拼接一串字符串（盐、salt值），这样就可以防止被破解，但是如果添加的字符串泄露了，也通用会造成数据泄露的风险。</p>
<p>所以通常情况下，这个salt值都是由服务端生成的，每一个用户过来就对应的生成一个salt值，这种方式已经比第一种安全很多了。</p>
<p>那如果用户更换了设备，就需要先拿到salt值，然后再次输入密码，还是有可能被暴利破解。</p>
<p>所以有了第三种方式：</p>
<h4 id="HMAC加密"><a href="#HMAC加密" class="headerlink" title="HMAC加密"></a>HMAC加密</h4><p>HMAC被称为：<a href="https://zh.wikipedia.org/wiki/%E9%87%91%E9%91%B0%E9%9B%9C%E6%B9%8A%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC" target="_blank" rel="noopener">密钥散列消息认证码</a>。英语：Keyed-hash message authentication code），又称散列消息认证码（Hash-based message authentication code，缩写为HMAC）。</p>
<p>是一种通过特别计算方式之后产生的消息认证码（MAC），使用密码散列函数，同时结合一个加密密钥。它可以用来保证资料的完整性，同时可以用来作某个消息的身份验证。</p>
<p>通俗来讲，类似于我们现在的授权认证，比如当我们在新设备上登录微信，就需要老设备点击确认或者扫码操作，这种就是获取授权的一个操作。认证流程如下：</p>
<ol>
<li>先由客户端向服务器发出一个验证请求。</li>
<li>服务器接到此请求后生成一个随机数并通过网络传输给客户端（此为挑战）。</li>
<li>客户端将收到的随机数提供给ePass，由ePass使用该随机数与存储在ePass中的密钥进行HMAC-MD5运算并得到一个结果作为认证证据传给服务器（此为响应）。</li>
<li>与此同时，服务器也使用该随机数与存储在服务器数据库中的该客户密钥进行HMAC-MD5运算，如果服务器的运算结果与客户端传回的响应结果相同，则认为客户端是一个合法用户。</li>
</ol>
<p>这个过程是通过Hash运算得到一个值进行服务器端的验证。这种方式已经基于完美了，但还不够完美。</p>
<h4 id="HMAC-时间戳"><a href="#HMAC-时间戳" class="headerlink" title="HMAC+时间戳"></a>HMAC+时间戳</h4><p>如果非法分子使用这种授权，模拟用户登录，那就会有问题了。通常会加上时间戳验证，这个授权认证需要在某一个时间范围内进行，超过了时间就会失败。从而大大增加安全性。</p>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>我们经常使用百度搜索、谷歌搜索也会，有时候搜索出来的东西都是一样的。比如：</p>
<p>搜索：<code>iOS NSString</code> 和 <code>NSString iOS</code>是一样的。首先对这两个进行md5加密，得到一个结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;iOS&quot; &#x3D; 1bdf605991920db11cbdf8508204c4eb</span><br><span class="line"></span><br><span class="line">&quot;NSString&quot; &#x3D; e4263c36f49e2d937749bb3c6c7bbadb</span><br></pre></td></tr></table></figure>

<p>这两个字符通过md5加密之后，相加得到的一个结果，所以不管顺序如何，得到的结果都是一样的。</p>
<h3 id="版权问题"><a href="#版权问题" class="headerlink" title="版权问题"></a>版权问题</h3><p>比如图片类型的网站，上传的第一份图片，就会生成一份原始的hash值。之后其他人下载之后使用，但是他们下载的不会是源文件，而是平台在内部做了处理重新生成的。</p>
<p>如果有人说我这个是正版的图片，你这个是盗版的，那就用原始文件进行对比处理。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><blockquote>
<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D" target="_blank" rel="noopener">数字签名</a>（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。</p>
<p>数字签名是非对称密钥加密技术与数字摘要技术的应用。</p>
</blockquote>
<h4 id="数字签名的实现"><a href="#数字签名的实现" class="headerlink" title="数字签名的实现"></a>数字签名的实现</h4><p>数字签名算法是依靠公钥加密技术来实现的。在公钥加密技术里，每一个使用者有一对密钥：一把公钥和一把私钥。公钥可以自由发布，但私钥则秘密保存；还有一个要求就是要让通过公钥推算出私钥的做法不可能实现。</p>
<p>普通的数字签名算法包括三种算法：</p>
<ol>
<li>一种密码生成算法</li>
<li>标记算法</li>
<li>验证算法</li>
</ol>
<p>通常情况下，使用Hash+RSA的方式实现数字签名。需要注意的是，私钥是保密的，公钥可以自由发布。</p>
<p><img src="signature.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>base64部分的补充</li>
<li>RSA终端命令</li>
<li>RSA特点<ul>
<li>RSA安全系数非常高（整个业务逻辑非常安全）</li>
<li>加密效率非常低（不能做大数据加密）</li>
<li>用来加密关键数据</li>
</ul>
</li>
<li>HASH特点<ul>
<li>不可逆运算</li>
<li>相同的数据，结果相同</li>
<li>不同的数据，长度相同</li>
<li>一般用于做数据的识别（密码、版权）</li>
</ul>
</li>
<li>md5及SHA</li>
<li>hash的应用：<ul>
<li>密码加密（HMAC + 时间戳）</li>
<li>数字签名<ul>
<li>算法：RSA+HASH</li>
<li>目的：验证数据的完整性，不被篡改</li>
<li>步奏：1.原始数据的hash值，2.使用rsa加密hash值，3.将原始数据+数字签名一起打包发送传递。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">散列函数</a><br><a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="noopener">SHA家族</a><br><a href="https://www.cmd5.com/" target="_blank" rel="noopener">md5在线破解</a><br><a href="https://zh.wikipedia.org/wiki/%E9%87%91%E9%91%B0%E9%9B%9C%E6%B9%8A%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC" target="_blank" rel="noopener">密钥散列消息认证码</a><br><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">数字签名-维基百科</a><br><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D" target="_blank" rel="noopener">数字签名-百度百科</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/09/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%985%E5%A4%A7%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/OC%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%985%E5%A4%A7%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">内存5大分区</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 22:23:17" itemprop="dateCreated datePublished" datetime="2021-05-09T22:23:17+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存主要分为5大区：</p>
<ol>
<li>栈 stack</li>
<li>对 heap</li>
<li>全局区/静态区</li>
<li>常量区</li>
<li>代码区</li>
</ol>
<p><img src="memory.jpg" alt=""></p>
<p>这张图详细的介绍了5大分区的分配情况。</p>
<p>栈是从高地址向低地址开始分配，了解汇编的同学应该知道栈顶和栈底，这两个寄存器，栈顶处与低地址区，栈底处于高地址区。</p>
<p>堆是从低地址向高地址开始分配。在堆中获取数据相对比较麻烦，所以都是在栈中开辟空间指向堆。</p>
<p>当栈和堆有一方不断开辟空间，导致两个处于临界点时，就会发生堆栈溢出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/08/OC%E5%8E%9F%E7%90%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/OC%E5%8E%9F%E7%90%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 08:40:32" itemprop="dateCreated datePublished" datetime="2021-05-08T08:40:32+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2" target="_blank" rel="noopener">官方文档：线程编程指南</a></p>
<blockquote>
<p>线程是在应用程序内部实现多个执行路径的相对轻量的方法。在系统级别，程序并排运行，系统根据每个程序的需求和其他程序的需求为每个程序分配执行时间。但是，每个程序中都存在一个或多个执行线程，这些线程可用于同时或以几乎同时的方式执行不同的任务。系统本身实际上管理着这些执行线程，调度它们在可用内核上运行，并根据需要抢先中断它们以允许其他线程运行。</p>
</blockquote>
<ul>
<li>多个线程可以提高应用程序的感知响应能力。</li>
<li>多线程可以提高应用程序在多核系统上的实时性能。</li>
</ul>
<h2 id="2-什么是进程"><a href="#2-什么是进程" class="headerlink" title="2. 什么是进程"></a>2. 什么是进程</h2><p>进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</p>
<h2 id="3-两者的关系"><a href="#3-两者的关系" class="headerlink" title="3. 两者的关系"></a>3. 两者的关系</h2><ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</li>
<li>进程要想执行任务，必须得有线程，进程至少要有一条线程。</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程。</li>
<li>同一进程的线程共享本进程的地址空间，而进程之间则时独立的。</li>
<li>同一进程内的线程共享进程的资源，如：内存、I/O、CPU等，而进程之间是独立的。</li>
<li>一个进程崩溃后，保护模式下，不会对其他进程产生影响。一个线程崩溃则整个进程死掉。进程比线程健壮。</li>
<li>进程切换时，消耗的资源大，效率低。设计频繁切换时，是哦那个线程好于进程。</li>
<li>线程不能独立执行，必须依存于进程（应用程序）。</li>
<li>线程时处理器调度的基本单位，进程不是。</li>
<li>线程没有地址空间，线程保护在进程地址空间中。</li>
</ul>
<h2 id="4-多线程的优点"><a href="#4-多线程的优点" class="headerlink" title="4. 多线程的优点"></a>4. 多线程的优点</h2><ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源的利用率(CPU，内存)</li>
<li>线程上的任务执行完成后，线程会自动销毁</li>
</ul>
<h2 id="5-多线程的缺点"><a href="#5-多线程的缺点" class="headerlink" title="5. 多线程的缺点"></a>5. 多线程的缺点</h2><ul>
<li>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占512KB) </li>
<li>如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU 在调用线程上的开销就越大</li>
<li>程序设计更加复杂，比如线程间的通信、多线程的数据共享</li>
<li>多线程操作增加代码复杂度</li>
</ul>
<h2 id="6-时间片"><a href="#6-时间片" class="headerlink" title="6. 时间片"></a>6. 时间片</h2><p>CPU在多个任务之间进行快速的切换，这个时间间隔就是时间片。</p>
<ul>
<li>单核CPU同一时间，CPU只能处理1个线程（只能有一个线程执行）</li>
<li>多线程同时执行，是CPU快速在多个线程直接的切换，因为CPU调度线程的时间足够快，就造成了多线程的”同时“执行的效果。</li>
<li>如果线程数非常多，CPU会在N个线程之间切换，消耗大量的CPU资源，线程的执行效率会降低。</li>
</ul>
<h2 id="7-线程的声明周期"><a href="#7-线程的声明周期" class="headerlink" title="7. 线程的声明周期"></a>7. 线程的声明周期</h2><p><img src="thread-life.jpg" alt=""></p>
<h2 id="8-线程池的调度"><a href="#8-线程池的调度" class="headerlink" title="8. 线程池的调度"></a>8. 线程池的调度</h2><p><img src="thread-used.jpg" alt=""></p>
<p>4种饱和策略</p>
<ul>
<li>AbortPolicy 直接抛出RejectedExecutionExeception异常来阻止系统正常运行 </li>
<li>CallerRunsPolicy 将任务回退到调用者</li>
<li>DisOldestPolicy 丢掉等待最久的任务</li>
<li>DisCardPolicy 直接丢弃任务</li>
</ul>
<p>那么这里有一个问题，是不是创建的线程优先级越高，执行的就越快呢？</p>
<p>答案是不一定，需要根据线程要使用的资源，已经线程池的饱和程度来判断。</p>
<ol>
<li>如果这个线程需要很大的资源，比如处理几个G和处理几KB效率肯定是不一样的。</li>
<li>如果线程池处于饱和状态，并且都在执行状态，是没有办法把正在执行的线程取消掉的。</li>
</ol>
<p>这就需要锁来解决，</p>
<h1 id="多线程解决方案："><a href="#多线程解决方案：" class="headerlink" title="多线程解决方案："></a>多线程解决方案：</h1><p>常见的多线程有pthread、NSThread、GCD、NSOperation：</p>
<p><img src="" alt=""></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>两个人买票，同一时间相同的操作，A买的时候有100张，B买的时候也有100张，那AB都买完的时候应该只剩下998张才对，但是如果不处理的情况下，会出现资源抢占的问题。</p>
<p>这就需要锁来解决。</p>
<h2 id="1-atomic与nonatomic"><a href="#1-atomic与nonatomic" class="headerlink" title="1. atomic与nonatomic"></a>1. atomic与nonatomic</h2><p>atomic：原子属性(线程安全)，针对多线程设计的，使用属性时默认是atomic，保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值)。atomic本身就有一把锁(自旋锁) 单写多读:单个线程写入，多个线程可以读取。<br>nonatomic：非原子属性，非线程安全，适合内存小的移动设备。</p>
<blockquote>
<p>iOS开发建议：<br>所有属性都声明为 nonatomic<br>尽量避免多线程抢夺同一块资源，尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</p>
</blockquote>
<p>自旋锁 与 互斥锁的区别</p>
<p>两个都是进行同步操作而产生的。</p>
<p>自旋锁：发现其他线程在执行，当前线程会一直询问（忙等），直到当前线程开始执行。消耗性能比较高。适用于任务复杂度较低的。<br>互斥锁：发现其他线程在执行，当前线程即刻进入休眠（就绪状态），已知等待被唤醒执行。对于任务复杂度较高，资源较大使用互斥锁。</p>
<p>之后会有详细的描述，这里只是引出相关内容。</p>
<h1 id="NSPort通信"><a href="#NSPort通信" class="headerlink" title="NSPort通信"></a>NSPort通信</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 创建主线程的port</span><br><span class="line">&#x2F;&#x2F; 子线程通过此端口发送消息给主线程</span><br><span class="line">self.myPort &#x3D; [NSMachPort port];</span><br><span class="line">&#x2F;&#x2F;2. 设置port的代理回调对象</span><br><span class="line">self.myPort.delegate &#x3D; self;</span><br><span class="line">&#x2F;&#x2F;3. 把port加入runloop，接收port消息</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:self.myPort forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>

<p>创建了NSPort之后，一定要加入到NSRunLoop中包活，否则没有效果。</p>
<ol>
<li>runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心 的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局 的字典里。 </li>
<li>runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休 眠状态，有了任务就会被唤醒去执行任务。 </li>
<li>runloop在第一次获取时被创建，在线程结束时被销毁。 </li>
<li>对于主线程来说，runloop在程序一启动就默认创建好了。 </li>
<li>对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线 程用定时器要注意:确保子线程的runloop被创建，不然定时器不会回调。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/08/OC%E5%8E%9F%E7%90%86/KVO%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/OC%E5%8E%9F%E7%90%86/KVO%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">KVO原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 08:39:59" itemprop="dateCreated datePublished" datetime="2021-05-08T08:39:59+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 19:35:47" itemprop="dateModified" datetime="2021-05-10T19:35:47+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="noopener">Key-Value Observing</a></p>
<blockquote>
<p><b>Important:</b> In order to understand key-value observing, you must first understand key-value coding.</p>
</blockquote>
<p>在官方的文档中，有这么一句话，要理解KVO，必须先知道KVC。</p>
<h1 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h1><p>下面创建一个<code>Person</code>类，并添加几个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void *PersonNameContext &#x3D; &amp;PersonNameContext;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">@property (nonatomic, copy) NSString *fullName;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *mArray;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><p>KVO对实例变量是不起作用的。可以试一下，即使添加了set方法、添加了<code>didChangeValueForKey:</code>方法也不行，即使使用了KVC也监听不到。正常使用来说，还是针对属性。</p>
<h3 id="1-1-添加监听"><a href="#1-1-添加监听" class="headerlink" title="1.1 添加监听"></a>1.1 添加监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure>

<p>被监听者进行调用，添加一个监听对象，监听某一个属性的变化。context是上下文，在官方文档中，推荐使用<code>context</code>，不使用这个，也可以使用<code>NULL</code>代替。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当前对象监听person对象的name属性的变化</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:PersonNameContext]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-监听变化"><a href="#1-2-监听变化" class="headerlink" title="1.2 监听变化"></a>1.2 监听变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    &#x2F;&#x2F;if (context &#x3D;&#x3D; PersonNameContext) &#123;&#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以通过<code>keyPath</code>来判断某一个属性发生变化，如果监听了多个对象，并且有相同的属性，则在这里会添加一堆判断条件，会使代码变得臃肿，所以还是推荐使用context来判断。</p>
<h3 id="1-3-移除KVO"><a href="#1-3-移除KVO" class="headerlink" title="1.3 移除KVO"></a>1.3 移除KVO</h3><p>添加了监听之后，再<code>dealloc</code>时一定要移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<h2 id="2-KVO中属性依赖"><a href="#2-KVO中属性依赖" class="headerlink" title="2. KVO中属性依赖"></a>2. KVO中属性依赖</h2><p>比如我们要监听<code>fullName</code>属性的变化，当<code>name</code>和<code>nickName</code>中的一个发生变化时，都需要改变<code>fullName</code>的值，需要怎么处理？如果同时监听两个属性也不是不行，但是肯定还有其他更简便的方法。这就需要添加依赖。</p>
<p>在<code>Person.m</code>中实现如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line">    </span><br><span class="line">    NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys &#x3D; @[@&quot;name&quot;, @&quot;nickName&quot;];</span><br><span class="line">        keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现依赖监听了，也不用实现重复代码。</p>
<h2 id="3-KVO监听数组"><a href="#3-KVO监听数组" class="headerlink" title="3. KVO监听数组"></a>3. KVO监听数组</h2><p>我们实现对person.mArray的监听，但是当我们执行添加和删除操作时，方法并不会触发监听事件。</p>
<p>这也就时开始的时候所说的，KVO是基于KVC的，这个时候，我们利用KVC的方式获取数组就可以实现了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [self.person.mArray addObject:@&quot;1&quot;];</span><br><span class="line">[[self.person mutableArrayValueForKey:@&quot;mArray&quot;] addObject:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>

<h2 id="4-自动、手动实现监听"><a href="#4-自动、手动实现监听" class="headerlink" title="4. 自动、手动实现监听"></a>4. 自动、手动实现监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动开关</span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</span><br></pre></td></tr></table></figure>
<p>这是一个系统方法，只需要重写即可，默认是YES，如果针对某些key返回了NO，则需要手动实现set方法。没有实现则不会监听到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    _name &#x3D; name;</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="KVO底层原理"><a href="#KVO底层原理" class="headerlink" title="KVO底层原理"></a>KVO底层原理</h1><p>我们通过监听一个中的<code>name</code>属性的变化来判断监听前后会出现什么不同，来查看KVO的底层实现原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.person &#x3D; [Person new];</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br></pre></td></tr></table></figure>

<p>我们在这一行代码添加一个断点，分别通过lldb打印当前person的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self.person</span><br><span class="line">&lt;Person: 0x60000294a010&gt;</span><br><span class="line">(lldb) po self.person-&gt;isa</span><br><span class="line">Person</span><br><span class="line">(lldb) po [self.person class]</span><br><span class="line">Person</span><br><span class="line">(lldb) po [self.person superclass]</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">(lldb) po self.person</span><br><span class="line">&lt;Person: 0x60000294a010&gt;</span><br><span class="line">(lldb) po self.person-&gt;isa</span><br><span class="line">NSKVONotifying_Person</span><br><span class="line">(lldb) po [self.person class]</span><br><span class="line">Person</span><br><span class="line">(lldb) po [self.person superclass]</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>我们发现虽然两次<code>po self.person</code>输出的都是Person类，指向的内存地址也是一样的，两次输出class和superClass确都相同。但是<code>isa</code>的指向却是完全不同，竟然变成了<code>NSKVONotifying_Person</code>。</p>
<p>那<code>NSKVONotifying_Person</code>是什么呢？怎么会创建一个这个东西，难道是<code>Person</code>的子类？<br>猜测应该是Person的子类。</p>
<p>为什么两次输出class和superClass都是一样的？<br>我们猜测可能是改写了class方法。</p>
<p>带着疑问，我们输出一下监听前后的方法列表，已经两个class的superClass。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过使用字符串的方式获取Class</span><br><span class="line">    Class cls1 &#x3D; class_getSuperclass(objc_getClass(&quot;Person&quot;));</span><br><span class="line">    [self printClassAllMethod:objc_getClass(&quot;Person&quot;)];</span><br><span class="line">    NSLog(@&quot;cls1 &#x3D; %@&quot;, cls1);</span><br><span class="line">        </span><br><span class="line">    self.person &#x3D; [[Person alloc] init];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line">        </span><br><span class="line">    [self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_Person&quot;)];</span><br><span class="line">    Class cls2 &#x3D; class_getSuperclass(objc_getClass(&quot;NSKVONotifying_Person&quot;));</span><br><span class="line">    NSLog(@&quot;cls2 &#x3D; %@&quot;, cls2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 遍历方法-ivar-property</span><br><span class="line">- (void)printClassAllMethod:(Class)cls &#123;</span><br><span class="line">    NSLog(@&quot;----%@----&quot;, cls);</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methodList[i];</span><br><span class="line">        SEL sel &#x3D; method_getName(method);</span><br><span class="line">        IMP imp &#x3D; class_getMethodImplementation(cls, sel);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听前</span><br><span class="line">KVODemo[74347:5007124] ----Person----</span><br><span class="line">KVODemo[74347:5007124] name-0x105ec6550</span><br><span class="line">KVODemo[74347:5007124] .cxx_destruct-0x105ec6580</span><br><span class="line">KVODemo[74347:5007124] setName:-0x105ec64f0</span><br><span class="line">KVODemo[74347:5007124] cls1 &#x3D; NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听后</span><br><span class="line">KVODemo[74347:5007124] ----NSKVONotifying_Person----</span><br><span class="line">KVODemo[74347:5007124] setName:-0x7fff207bab57</span><br><span class="line">KVODemo[74347:5007124] class-0x7fff207b9662</span><br><span class="line">KVODemo[74347:5007124] dealloc-0x7fff207b940b</span><br><span class="line">KVODemo[74347:5007124] _isKVOA-0x7fff207b9403</span><br><span class="line">KVODemo[74347:5007124] cls2 &#x3D; Person</span><br></pre></td></tr></table></figure>

<p>我们发现:</p>
<ul>
<li>监听前Person类中有3个方法，super是<code>NSObject</code></li>
<li>监听后Person类中有4个方法，super是<code>Person</code></li>
</ul>
<p>进一步验证了我们之前的猜测，<code>NSKVONotifying_Person</code>是<code>Person</code>的子类，并且重些了<code>setName:, class, dealloc</code>方法，因为地址都已经发生了变化。</p>
<p>打印一下对应的IMP地址，看看所在的调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (IMP)0x105ec64f0</span><br><span class="line">(KVODemo&#96;-[Person setName:] at Person.m:12)</span><br><span class="line"></span><br><span class="line">(lldb) po (IMP)0x7fff207bab57</span><br><span class="line">(Foundation&#96;_NSSetObjectValueAndNotify)</span><br><span class="line">return class_getSuperclass(object_getClass(self));</span><br></pre></td></tr></table></figure>

<p>也说明了，根本不是同一个IMP。当然<code>_NSSetObjectValueAndNotify</code>也不仅仅只有一种，使用<code>~ nm Foundation | grep ValueAndNotify</code>命令可以在iTerm2上查看对应的方法。比如：NSSetBoolValueAndNotify、NSSetIntValueAndNotify等等，根据当前属性的类型来判断的。</p>
<p>也正是因为重写了，<code>setName:</code>才会在外部调用时，person.name也会同时改变。<br>重新<code>class</code>方法，是为了不暴露<code>NSKVONotifying_Person</code>类，在外界调用时防止混淆。</p>
<p><img src="person-isa.jpg" alt=""></p>
<h1 id="自定义KVO"><a href="#自定义KVO" class="headerlink" title="自定义KVO"></a>自定义KVO</h1><p>根据上面的分析，如果自定义KVO的话，我们需要从下面几个方面入手：</p>
<ol>
<li><p>先判断key有没有set方法，有set方法才行。</p>
</li>
<li><p>动态生成子类：</p>
<ol>
<li>判断是否已经存在子类，没有创建新的子类。</li>
<li>注册类</li>
<li>添加class方法，重新class方法</li>
<li>添加setter方法，重新set方法，这里需要处理消息，发送给父类，通知修改值。</li>
</ol>
</li>
<li><p>修改isa指向</p>
</li>
<li><p>保存信息，方便回调。</p>
</li>
<li><p>remove时，重新设置isa指向父类。</p>
</li>
</ol>
<p>代码就不贴了，哪都有~</p>
<h1 id="通过GNU解析"><a href="#通过GNU解析" class="headerlink" title="通过GNU解析"></a>通过GNU解析</h1><p><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">gnu源码</a></p>
<p>gnu源码可以清晰的看到整体的流程，只是读起来可能会稍微费力一点，查看代码中的重要逻辑其实就可以了。</p>
<h1 id="FBKVOController"><a href="#FBKVOController" class="headerlink" title="FBKVOController"></a>FBKVOController</h1><p>稍微说一下这个，内部实现还是很值得学习的。</p>
<p>我们直接看源码实现：</p>
<p>首先创建一个<code>FBKVOController</code>类型的实例变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved</span><br><span class="line">&#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  if (nil !&#x3D; self) &#123;</span><br><span class="line">    _observer &#x3D; observer;</span><br><span class="line">    NSPointerFunctionsOptions keyOptions &#x3D; retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality;</span><br><span class="line">    _objectInfosMap &#x3D; [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0];</span><br><span class="line">    pthread_mutex_init(&amp;_lock, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会生成一个<code>NSMapTable</code>类型的数据，里面存放的是&lt;id, NSMutableSet&lt;_FBKVOInfo *&gt; *&gt;这种格式的数据。</p>
<p>然后走到添加监听的方法，这里也没啥好说的，就是创建了一个<code>_FBKVOInfo</code>，存放系统KVO需要的所有东西，重点再下一句代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">  NSAssert(0 !&#x3D; keyPath.length &amp;&amp; NULL !&#x3D; block, @&quot;missing required parameters observe:%@ keyPath:%@ block:%p&quot;, object, keyPath, block);</span><br><span class="line">  if (nil &#x3D;&#x3D; object || 0 &#x3D;&#x3D; keyPath.length || NULL &#x3D;&#x3D; block) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; create info</span><br><span class="line">  _FBKVOInfo *info &#x3D; [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options block:block];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; observe object with info</span><br><span class="line">  [self _observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，重点来了。会从map表中查找对应的object是否有对应的数据。然后与新创建的info进行比较，没有则添加到map表中。</p>
<p><code>_FBKVOSharedController</code>是一个单利，所有的观察者都通过它来进行监听，内部使用的系统的KVO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)_observe:(id)object info:(_FBKVOInfo *)info</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; lock</span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  NSMutableSet *infos &#x3D; [_objectInfosMap objectForKey:object];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; check for info existence</span><br><span class="line">  _FBKVOInfo *existingInfo &#x3D; [infos member:info];</span><br><span class="line">  if (nil !&#x3D; existingInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F; observation info already exists; do not observe it again</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; unlock and return</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lazilly create set of infos</span><br><span class="line">  if (nil &#x3D;&#x3D; infos) &#123;</span><br><span class="line">    infos &#x3D; [NSMutableSet set];</span><br><span class="line">    [_objectInfosMap setObject:infos forKey:object];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; add info and oberve</span><br><span class="line">  [infos addObject:info];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unlock prior to callout</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  [[_FBKVOSharedController sharedController] observe:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在系统方法接收到改变时，会通过block、方法或者系统方法来返回数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath</span><br><span class="line">                      ofObject:(nullable id)object</span><br><span class="line">                        change:(nullable NSDictionary&lt;NSString *, id&gt; *)change</span><br><span class="line">                       context:(nullable void *)context</span><br></pre></td></tr></table></figure>

<p>最后就是移除。需要注意的是，添加的时候是新创建了一个info，移除的时候，为啥也是新创建了一个info？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)unobserve:(nullable id)object keyPath:(NSString *)keyPath</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; create representative info</span><br><span class="line">  _FBKVOInfo *info &#x3D; [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unobserve object property</span><br><span class="line">  [self _unobserve:object info:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_unobserve:info:</code>的内部实现与添加的时候有点类似，都是通过map去找对应的<code>_FBKVOInfo</code>。那新创建一个info能起到移除的效果吗？答案是肯定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)_unobserve:(id)object info:(_FBKVOInfo *)info</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; lock</span><br><span class="line">  pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; get observation infos</span><br><span class="line">  NSMutableSet *infos &#x3D; [_objectInfosMap objectForKey:object];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lookup registered info instance</span><br><span class="line">  _FBKVOInfo *registeredInfo &#x3D; [infos member:info];</span><br><span class="line"></span><br><span class="line">  if (nil !&#x3D; registeredInfo) &#123;</span><br><span class="line">    [infos removeObject:registeredInfo];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; remove no longer used infos</span><br><span class="line">    if (0 &#x3D;&#x3D; infos.count) &#123;</span><br><span class="line">      [_objectInfosMap removeObjectForKey:object];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unlock</span><br><span class="line">  pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; unobserve</span><br><span class="line">  [[_FBKVOSharedController sharedController] unobserve:object info:registeredInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为创建的临时变量info，是通过NSMutableSet获取<code>member</code>来获取的，是怎么获取到的。</p>
<blockquote>
<p>Each element of the set is checked for equality with object until a match is found or the end of the set is reached. Objects are considered equal if isEqual: returns YES.</p>
</blockquote>
<p><code>member:</code>方法是通过<code>isEqual:</code>来判断是否是对应的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;_FBKVOInfo</span><br><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">  return [_keyPath hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object</span><br><span class="line">&#123;</span><br><span class="line">  if (nil &#x3D;&#x3D; object) &#123;</span><br><span class="line">    return NO;</span><br><span class="line">  &#125;</span><br><span class="line">  if (self &#x3D;&#x3D; object) &#123;</span><br><span class="line">    return YES;</span><br><span class="line">  &#125;</span><br><span class="line">  if (![object isKindOfClass:[self class]]) &#123;</span><br><span class="line">    return NO;</span><br><span class="line">  &#125;</span><br><span class="line">  return [_keyPath isEqualToString:((_FBKVOInfo *)object)-&gt;_keyPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写了<code>hash</code>方法和<code>isEqual:</code>方法，这样就可以直接通过member获取了。这源码的设计思路简直爽的一批<del>~</del>网上找到FBKVO流程图：</p>
<p><img src="FBKVOController.png" alt="网上找到FBKVO流程图"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>KVO的变量依赖</li>
<li>KVO的原理：<ol>
<li>动态生成子类<code>NSKVONotifying_A</code></li>
<li>注册类</li>
<li>动态添加class方法，返回父类</li>
<li>动态添加set方法，消息回传给父类，通知修改值</li>
<li>修改isa指向子类</li>
<li>移除KVO，修改isa执行父类</li>
</ol>
</li>
<li>GNU源码</li>
<li>FBKVOController源码设计思路。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/08/OC%E5%8E%9F%E7%90%86/KVC%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/OC%E5%8E%9F%E7%90%86/KVC%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">KVC原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 08:39:49" itemprop="dateCreated datePublished" datetime="2021-05-08T08:39:49+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">About Key-Value Coding</a></p>
<blockquote>
<p>Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to provide indirect access to their properties. When an object is key-value coding compliant, its properties are addressable via string parameters through a concise, uniform messaging interface. This indirect access mechanism supplements the direct access afforded by instance variables and their associated accessor methods.</p>
</blockquote>
<p>键值编码是由<code>NSKeyValueCoding</code>非正式协议启用的一种机制，对象采用这种机制来提供对其属性的间接访问。当对象是键值编码兼容的对象时，可以通过简洁，统一的消息传递接口通过字符串参数来访问其属性。这种间接访问机制补充了实例变量及其关联的访问器方法提供的直接访问。</p>
<h1 id="KVC-API"><a href="#KVC-API" class="headerlink" title="KVC - API"></a>KVC - API</h1><h2 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1. 常用方法"></a>1. 常用方法</h2><ul>
<li><p>获取key对应的value：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过key来设置value：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过路径取值，一般情况下是model1中有一个model2，获取model2的属性值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取对应路径的值，一般情况下是model1中有一个model2，设置model2的属性值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个可变类型：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认返回YES，如果当前没有设置key对应的属性（没有找到set<key>方法），会按照_key, _iskey, key, iskey的顺序搜索变量。如果返回NO，则不查询。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你在SetValue方法时面给Value传nil，则会调用这个方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Key不存在，且KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="2-set、get流程"><a href="#2-set、get流程" class="headerlink" title="2. set、get流程"></a>2. set、get流程</h2><p>声明一个Person类，声明4个变量。注意这里没有添加属性（添加属性默认会生成set、get方法），就是为了验证set、get流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_name;    &#x2F;&#x2F; 1.</span><br><span class="line">    NSString *_isName;  &#x2F;&#x2F; 2.</span><br><span class="line">    NSString *name;     &#x2F;&#x2F; 3.</span><br><span class="line">    NSString *isName;   &#x2F;&#x2F; 4.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>调用<code>setValue:forKey</code>方法，然后打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">&#x2F;&#x2F; KVC - 设置值的过程 setValue 分析调用过程</span><br><span class="line">[person setValue:@&quot;kvc&quot; forKey:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1.</span><br><span class="line">NSLog(@&quot;%@-%@-%@-%@&quot;,person-&gt;_name,person-&gt;_isName,person-&gt;name,person-&gt;isName);</span><br><span class="line">&#x2F;&#x2F; 2.</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;%@-%@-%@&quot;,person-&gt;_isName,person-&gt;name,person-&gt;isName);</span><br><span class="line">&#x2F;&#x2F; 3.</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;%@-%@&quot;,person-&gt;name,person-&gt;isName);</span><br><span class="line">&#x2F;&#x2F; 4.</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;%@&quot;,person-&gt;isName);</span><br></pre></td></tr></table></figure>

<p>分别按照顺序1-2-3-4，每次注释一个变量，每次只执行一句<code>NSLog</code>，看看打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.</span><br><span class="line">kvc-(nill)-(nill)-(nill)</span><br><span class="line">&#x2F;&#x2F; 2.</span><br><span class="line">kvc-(nill)-(nill)</span><br><span class="line">&#x2F;&#x2F; 3.</span><br><span class="line">kvc-(nill)</span><br><span class="line">&#x2F;&#x2F; 4.</span><br><span class="line">kvc</span><br></pre></td></tr></table></figure>

<p>为了进一步验证，可以在<code>Person.m</code>中，实现对应的set和get方法，分别打断点，按照1-2-3-4的顺序分别注释，可以进一步验证，set、get的流程。</p>
<p><code>setValue:forKey:</code>：按照<code>set&lt;key&gt;, _set&lt;key&gt;, setIs&lt;key&gt;</code>进行设置。有一个执行，其他的不执行。</p>
<blockquote>
<p>注意：<code>_setIs&lt;key&gt;</code>这个方法不会执行。</p>
</blockquote>
<p><code>valueForKey</code>：按照<code>get&lt;key&gt;, &lt;key&gt;, is&lt;key&gt;, _&lt;key&gt;</code>顺序进行查找。有一个执行，不执行其他的。</p>
<p>这里有官方的设置key-value的流程：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">Accessor Search Patterns</a>，写的很详细。</p>
<h3 id="2-1-Get-流程"><a href="#2-1-Get-流程" class="headerlink" title="2.1 Get 流程"></a>2.1 Get 流程</h3><ol>
<li>按照访问方法<code>-get&lt;Key&gt;，-&lt;key&gt;，-is&lt;Key&gt;，-_&lt;key&gt;</code>的顺序进行查找，如果找到执行步奏【5】。否则执行步奏【2】。</li>
<li>在实例中搜索①<code>countOf&lt;Key&gt;</code>，②<code>objectIn&lt;Key&gt;AtIndex:</code>（与<code>NSArray</code>类定义的原始方法<code>&lt;key&gt;AtIndexes:</code>相对应）或③<code>objectsAtIndexes:</code>（与NSArray方法相对应）。如果找到①，再找到②或③中的一个，则创建一个响应所有NSArray方法的集合代理对象并将其返回。否则，请继续执行步骤【3】。</li>
<li>如果找到了①<code>countOf&lt;Key&gt;</code>，没有找到②或③，那么会去找<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf&lt;Key&gt;:</code>（对应NSSet类）。如果找到了所有三个方法，则创建一个响应所有NSSet方法的集合代理对象并将其返回。否则，请继续执行步骤【4】。</li>
<li>如果接收器的类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，则按照<code>_&lt;key&gt;，_is&lt;Key&gt;，&lt;key&gt;，is&lt;Key&gt;</code>的顺序搜索实例变量。如果找到，直接获取实例变量的值，然后继续执行步骤【5】。否则，继续执行步骤【6】。</li>
<li>如果获取到的变量是对象指针，则只需返回结果。<br> 如果该值是可以转换位<code>NSNumber</code>类型，则将其存储在NSNumber实例中并返回该实例。<br> 如果结果是<code>NSNumber</code>不支持的类型，请转换为<code>NSValue</code>对象并返回该对象。</li>
<li>如果其他所有方法均失败，则调用<code>valueForUndefinedKey:</code>。默认情况下会引发异常。</li>
</ol>
<h3 id="2-2-Set流程"><a href="#2-2-Set流程" class="headerlink" title="2.2 Set流程"></a>2.2 Set流程</h3><ol>
<li>按此顺序查找第一个名为<code>set&lt;Key&gt;:, _set&lt;Key&gt;:, setIsName:</code>的set方法。如果找到，调用它并完成。</li>
<li>如果没有找到，如果类方法<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，则按照顺序<code>_&lt;key&gt;，_is&lt;Key&gt;，&lt;key&gt;，is&lt;Key&gt;</code>查找实例变量。如果找到，则直接对变量进行赋值。</li>
<li>如果步奏【1】和【2】都失败了，则调用<code>setValue:forUndefinedKey:</code>。默认情况下会引发异常。</li>
</ol>
<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><h2 id="1-集合类型"><a href="#1-集合类型" class="headerlink" title="1. 集合类型"></a>1. 集合类型</h2><p>在<code>Person</code>类中，声明一个不可变数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSArray *array;</span><br></pre></td></tr></table></figure>

<p>对不可变类型进行赋值时，可以使用<code>mutableArrayValueForKey</code>先获取一个可变数组，然后直接赋值就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person.array &#x3D; @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">&#x2F;&#x2F; 修改数组</span><br><span class="line">&#x2F;&#x2F; person.array[0] &#x3D; @&quot;100&quot;;&#x2F;&#x2F; 这种方式不可用</span><br><span class="line">&#x2F;&#x2F; 1. 获取一个新的数组 - KVC 赋值</span><br><span class="line">NSArray *array &#x3D; [person valueForKey:@&quot;array&quot;];</span><br><span class="line">array &#x3D; @[@&quot;100&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">[person setValue:array forKey:@&quot;array&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;array&quot;]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 使用mutableArrayValueForKey</span><br><span class="line">NSMutableArray *mArray &#x3D; [person mutableArrayValueForKey:@&quot;array&quot;];</span><br><span class="line">mArray[0] &#x3D; @&quot;200&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;array&quot;]);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-05-09 10:17:58.004460+0800 KVCDemo[70852:4744247] (</span><br><span class="line">    100,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br><span class="line">2021-05-09 10:17:58.005523+0800 KVCDemo[70852:4744247] (</span><br><span class="line">    200,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果声明的是一个可变数组，那通过<code>[person valueForKey:@&quot;mArray&quot;];</code>获取到的就是一个可变数组。</p>
<h2 id="2-集合类型set、get流程补充"><a href="#2-集合类型set、get流程补充" class="headerlink" title="2. 集合类型set、get流程补充"></a>2. 集合类型set、get流程补充</h2><p>直接上代码：这里使用的key是一个没有在类中声明的变量/属性<code>pens</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person.arr &#x3D; @[@&quot;pen0&quot;, @&quot;pen1&quot;, @&quot;pen2&quot;, @&quot;pen3&quot;];</span><br><span class="line">&#x2F;&#x2F; 直接运行，在这里会发生crash</span><br><span class="line">NSArray *array &#x3D; [person valueForKey:@&quot;pens&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[array objectAtIndex:1]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[array containsObject:@&quot;pen1&quot;]);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; set 集合</span><br><span class="line">person.set &#x3D; [NSSet setWithArray:person.arr];</span><br><span class="line">NSSet *set &#x3D; [person valueForKey:@&quot;books&quot;];</span><br><span class="line">[set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    NSLog(@&quot;set遍历 %@&quot;,obj);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>直接运行，会发生crash。</p>
<blockquote>
<p>*** Terminating app due to uncaught exception ‘NSUnknownKeyException’, reason: ‘[&lt;LGPerson 0x6000024610c0&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key pens.’</p>
</blockquote>
<p>按照上面的流程分析，我们需要对NSArray和NSSet类型提供方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MARK: - NSArray</span><br><span class="line">&#x2F;&#x2F; 个数</span><br><span class="line">- (NSUInteger)countOfPens&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.arr count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取值</span><br><span class="line">- (id)objectInPensAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [NSString stringWithFormat:@&quot;pens %lu&quot;, index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MARK: - set</span><br><span class="line">&#x2F;&#x2F; 个数</span><br><span class="line">- (NSUInteger)countOfBooks&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.set count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否包含这个成员对象</span><br><span class="line">- (id)memberOfBooks:(id)object &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.set containsObject:object] ? object : nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 迭代器</span><br><span class="line">- (id)enumeratorOfBooks &#123;</span><br><span class="line">    &#x2F;&#x2F; objectEnumerator</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [self.arr reverseObjectEnumerator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充完整上述方法，即可正常运行，对数组进行操作。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>声明一个结构体类型的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    float x, y, z;</span><br><span class="line">&#125; ThreeFloats;</span><br><span class="line"></span><br><span class="line">@property (nonatomic) ThreeFloats threeFloats;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreeFloats floats &#x3D; &#123;1.,2.,3.&#125;;</span><br><span class="line">NSValue *value     &#x3D; [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</span><br><span class="line">[person setValue:value forKey:@&quot;threeFloats&quot;];</span><br><span class="line">NSValue *value1    &#x3D; [person valueForKey:@&quot;threeFloats&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,value1);</span><br><span class="line">    </span><br><span class="line">ThreeFloats th;</span><br><span class="line">[value1 getValue:&amp;th];</span><br><span class="line">NSLog(@&quot;%f-%f-%f&quot;,th.x,th.y,th.z);</span><br></pre></td></tr></table></figure>

<p>对于结构体类型的数据，需要先转化成<code>NSValue</code>类型。常量类型会先转化成<code>NSNumber</code>类型</p>
<h1 id="自定义KVC"><a href="#自定义KVC" class="headerlink" title="自定义KVC"></a>自定义KVC</h1><p>根据set、get流程分析，自定义主要分为以下几个流程，需要注意的是要做安全判断，防止发生异常。</p>
<h2 id="1-kvc自定义set"><a href="#1-kvc自定义set" class="headerlink" title="1. kvc自定义set"></a>1. kvc自定义set</h2><ol>
<li>判断key，value的情况</li>
<li>通过传进来的key生成对应的set方法。</li>
<li>判断生成的3种set方法是否可以被响应，可以被响应直接return。</li>
<li>判断accessInstanceVariablesDirectly是否返回YES。</li>
<li>判断4种实例变量是否存在，存在则赋值，否则crash异常处理。</li>
</ol>
<h2 id="2-KVC-自定义Get"><a href="#2-KVC-自定义Get" class="headerlink" title="2. KVC 自定义Get"></a>2. KVC 自定义Get</h2><ol>
<li>判断key的值。</li>
<li>生成对应的<code>-get&lt;Key&gt;，-&lt;key&gt;，-is&lt;Key&gt;，-_&lt;key&gt;</code>方法。判断是否可以响应。</li>
<li>不响应判断get流程种NSArray的处理。</li>
<li>不想要判断get流程种NSSet的处理。</li>
<li>判断accessInstanceVariablesDirectly是否返回YES。</li>
<li>判断变量是否存在，存在直接返回。</li>
<li>异常处理。</li>
</ol>
<p>自定义set、get完全是按照set和get的流程处理的。代码就不上了，太占地方。</p>
<h1 id="补充，KVC的高级使用"><a href="#补充，KVC的高级使用" class="headerlink" title="补充，KVC的高级使用"></a>补充，KVC的高级使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arrStr &#x3D; @[@&quot;1&quot;, @&quot;10&quot;, @&quot;100&quot;];</span><br><span class="line">NSArray *arrCapStr &#x3D; [arrStr valueForKey:@&quot;capitalizedString&quot;];</span><br><span class="line">    </span><br><span class="line">for (NSString *str in arrCapStr) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSArray *arrCapStrLength &#x3D; [arrCapStr valueForKeyPath:@&quot;capitalizedString.length&quot;];</span><br><span class="line">for (NSNumber *length in arrCapStrLength) &#123;</span><br><span class="line">    NSLog(@&quot;%ld&quot;, (long)length.integerValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出来的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br><span class="line">100</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>还有关于model中嵌套model的也差不多类似，大家探索一下吧。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>KVC可以间接访问私有变量。</li>
<li><code>valueForKey</code>返回key对应的类型数据。如果是不可变数组，通过<code>mutableArrayValueForKey</code>获取的也会是可变类型。</li>
<li><code>setValue:forKey:, valueForKey:</code>的流程。</li>
<li>自定义KVC。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/28/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-5/" class="post-title-link" itemprop="url">ARM汇编-5 OC反汇编</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-28 14:30:30" itemprop="dateCreated datePublished" datetime="2021-04-28T14:30:30+08:00">2021-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OC代码的精髓其实就是<code>objc_msgSend</code>。而OC的反汇编其实就是查看其中的方法调用。</p>
<p>objc_msgSend有两个参数，第一个是id类型，第二个是SEL类型。id、SEL其实都是一个结构体，内部有isa指针，所以这两个在内存中占有8个字节。</p>
<h1 id="1-OC汇编"><a href="#1-OC汇编" class="headerlink" title="1. OC汇编"></a>1. OC汇编</h1><p>声明一个Person类，并添加两个属性，一个类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic, copy) NSString * name;</span><br><span class="line">@property(nonatomic, assign) int age;</span><br><span class="line"></span><br><span class="line">+(instancetype)person;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (instancetype)person &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    Person * p &#x3D; [Person person];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放在main函数里，直接调用类方法，生成一个临时变量。<br>打上断点，直接在汇编模式下进行debug。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;main:</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    0x10405a16c &lt;+24&gt;:  adrp   x8, 3</span><br><span class="line">    0x10405a170 &lt;+28&gt;:  add    x8, x8, #0x648            ; &#x3D;0x648 </span><br><span class="line">-&gt;  0x10405a174 &lt;+32&gt;:  ldr    x0, [x8]</span><br><span class="line"></span><br><span class="line">    0x10405a178 &lt;+36&gt;:  adrp   x8, 3</span><br><span class="line">    0x10405a17c &lt;+40&gt;:  add    x8, x8, #0x638            ; &#x3D;0x638 </span><br><span class="line">    0x10405a180 &lt;+44&gt;:  ldr    x1, [x8]</span><br><span class="line">    0x10405a184 &lt;+48&gt;:  bl     0x10405a4d4               ; symbol stub for: objc_msgSend</span><br><span class="line">    0x10405a188 &lt;+52&gt;:  mov    x29, x29</span><br><span class="line">    0x10405a18c &lt;+56&gt;:  bl     0x10405a4f8               ; symbol stub for: objc_retainAutoreleasedReturnValue</span><br><span class="line">    0x10405a190 &lt;+60&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 </span><br><span class="line">    0x10405a194 &lt;+64&gt;:  str    x0, [sp, #0x8]</span><br><span class="line">    0x10405a198 &lt;+68&gt;:  stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x10405a19c &lt;+72&gt;:  mov    x0, x8</span><br><span class="line">    0x10405a1a0 &lt;+76&gt;:  mov    x8, #0x0</span><br><span class="line">    0x10405a1a4 &lt;+80&gt;:  mov    x1, x8</span><br><span class="line">    0x10405a1a8 &lt;+84&gt;:  bl     0x10405a510               ; symbol stub for: objc_storeStrong</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这里隐藏了开辟栈空间和回收相关的代码。</p>
<p><code>objc_msgSend</code>需要两个参数id和SEL，从上面的代码可以初步判断两个参数的值分别在x0、x1寄存器中。</p>
<p>首先我们看一下x0寄存器中的数据。按照老方法，adrp计算x8的地址是<code>0x010405d648</code>。x0的值存放在<code>0x010405d648</code>所指向的内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x010405d648</span><br><span class="line">&lt;Person: 0x10405d648&gt;</span><br><span class="line">(lldb) x 0x010405d648</span><br><span class="line">0x10405d648: 30 d7 05 04 01 00 00 00 68 d6 05 04 01 00 00 00  0.......h.......</span><br><span class="line">0x10405d658: 08 00 00 00 08 00 00 00 10 00 00 00 08 00 00 00  ................</span><br><span class="line"></span><br><span class="line">(lldb) po 0x010405d730</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>我们确定了第一个参数是Person类。在看第二个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x 0x10405d638</span><br><span class="line">0x10405d638: 05 3d 42 8f 01 00 00 00 00 00 00 00 00 00 00 00  .&#x3D;B.............</span><br><span class="line">0x10405d648: 30 d7 05 04 01 00 00 00 68 d6 05 04 01 00 00 00  0.......h.......</span><br><span class="line">(lldb) po (SEL)0x018f423d05</span><br><span class="line">&quot;person&quot;</span><br></pre></td></tr></table></figure>

<p>没有毛病，就是一个方法<code>person</code>。</p>
<p>不同的系统版本，实现的汇编是不一样，iOS11下，汇编对objc_alloc进行了优化，但是没有对init处理。</p>
<p>iOS14 ：没有消息发送，直接objc_alloc_init<br>iOS11 ： 一次消息发送，objc_alloc, objc_msgSend(self, init)<br>iOS9  ： 两次消息发送，objc_msgSend(alloc),objc_msgSend(self, init)</p>
<h2 id="1-1-objc-storeStrong"><a href="#1-1-objc-storeStrong" class="headerlink" title="1.1 objc_storeStrong"></a>1.1 objc_storeStrong</h2><p>这里还看到一个这个东西，这个设计到oc源码的逻辑，我们稍微看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev &#x3D; *location;</span><br><span class="line">    if (obj &#x3D;&#x3D; prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location &#x3D; obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数需要两个参数，第一个是id *类型，这就是一个地址，第二个是id类型。我们反过来看汇编代码，看这两个变量，正常来说还是在x0、x1寄存器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x8中存地址</span><br><span class="line">0x10405a190 &lt;+60&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 </span><br><span class="line">&#x2F;&#x2F; 把x0寄存器的值放在x8中。</span><br><span class="line">0x10405a194 &lt;+64&gt;:  str    x0, [sp, #0x8]</span><br><span class="line">&#x2F;&#x2F; 把0存起来</span><br><span class="line">0x10405a198 &lt;+68&gt;:  stur   wzr, [x29, #-0x4]</span><br><span class="line">&#x2F;&#x2F; x0 &#x3D; x8，是一个地址。</span><br><span class="line">0x10405a19c &lt;+72&gt;:  mov    x0, x8</span><br><span class="line">&#x2F;&#x2F; x8置空</span><br><span class="line">0x10405a1a0 &lt;+76&gt;:  mov    x8, #0x0</span><br><span class="line">&#x2F;&#x2F; x1 &#x3D; 0</span><br><span class="line">0x10405a1a4 &lt;+80&gt;:  mov    x1, x8</span><br><span class="line">&#x2F;&#x2F; 这里x0是一个地址， x1是个nil，两个变量</span><br><span class="line">0x10405a1a8 &lt;+84&gt;:  bl     0x10405a510  ; symbol stub for: objc_storeStrong</span><br></pre></td></tr></table></figure>

<p>通过分析汇编，objc_storeStrong两个变量分别是一个地址，一个是nil。然后看一些源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; location有值， obj &#x3D; nil</span><br><span class="line">    id prev &#x3D; *location;</span><br><span class="line">    &#x2F;&#x2F; 不相等</span><br><span class="line">    if (obj &#x3D;&#x3D; prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对nil进行retain</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    &#x2F;&#x2F; 寻址之后置空，也就是把id对象置空</span><br><span class="line">    *location &#x3D; obj;</span><br><span class="line">    &#x2F;&#x2F; 释放</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个函数不仅仅只是用来强引用的，还可以进行释放操作，在这里就是一个很明显的例子。</p>
<h1 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2 属性"></a>1.2 属性</h1><p>我们在mian函数中，对实例对象p的两个属性进行赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    Person * p &#x3D; [Person person];</span><br><span class="line">    p.name &#x3D; @&quot;name&quot;;</span><br><span class="line">    p.age &#x3D; 18;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在真机上执行一下，然后我们使用之前的Hopper工具进行看一下。</p>
<p><img src="arm-5-property.jpg" alt=""></p>
<p>这里就很详细的标注了整个内容，看起来比读汇编代码省事很多。</p>
<h1 id="3-block的汇编"><a href="#3-block的汇编" class="headerlink" title="3. block的汇编"></a>3. block的汇编</h1><p>在main函数中直接声明一个栈区的block，全局区的也是一样的道理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^() &#123;</span><br><span class="line">    NSLog(@&quot;block--%d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>然后真机上运行。这里省去了很大一部分的代码，只拿了关键部分的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;main:</span><br><span class="line">    0x10052a0cc &lt;+36&gt;:  adrp   x10, 2</span><br><span class="line">    0x10052a0d0 &lt;+40&gt;:  ldr    x10, [x10]</span><br><span class="line">-&gt;  0x10052a0d4 &lt;+44&gt;:  str    x10, [sp, #0x8]</span><br></pre></td></tr></table></figure>

<p>先获取x10寄存器的值，也就是<code>0x10052c000</code>,lldb调试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x 0x10052c000</span><br><span class="line">0x10052c000: 20 9a 44 29 02 00 00 00 0c c8 66 ef 01 00 00 00   .D)......f.....</span><br><span class="line">0x10052c010: 18 a5 52 00 01 00 00 00 24 a5 52 00 01 00 00 00  ..R.....$.R.....</span><br><span class="line">&#x2F;&#x2F; 这是一个栈block</span><br><span class="line">(lldb) po 0x10052c000</span><br><span class="line">&lt;__NSStackBlock__: 0x10052c000&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里拿到的是0x10052c010地址指向的内存区域，这个就是block的invoke。</span><br><span class="line">(lldb) dis -s 0x010052a518</span><br><span class="line">    0x10052a518: ldr    w16, 0x10052a520</span><br><span class="line">    0x10052a51c: b      0x10052a500</span><br><span class="line">    0x10052a520: udf    #0x0</span><br><span class="line">    0x10052a524: ldr    w16, 0x10052a52c</span><br><span class="line">    0x10052a528: b      0x10052a500</span><br><span class="line">    0x10052a52c: udf    #0xd</span><br><span class="line">    0x10052a530: ldr    w16, 0x10052a538</span><br><span class="line">    0x10052a534: b      0x10052a500</span><br></pre></td></tr></table></figure>

<p>这里看一下block的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;      &#x2F;&#x2F; 8个字节</span><br><span class="line">    volatile int32_t flags; &#x2F;&#x2F; contains ref count   &#x2F;&#x2F;4个字节</span><br><span class="line">    int32_t reserved;   &#x2F;&#x2F; 4个字节</span><br><span class="line">    BlockInvokeFunction invoke;</span><br><span class="line">    struct Block_descriptor_1 *descriptor;</span><br><span class="line">    &#x2F;&#x2F; imported variables</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>block也是一个结构体，invoke所在的位置，就是isa之后的16个字节。所以我在内存中取的invoke的实现就是偏移了0x10。</p>
<p>接下来，我们用hopper看一下:</p>
<p><img src="arm-5-block.jpg" alt=""></p>
<p><img src="arm-5-block-invoke.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/25/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-4/" class="post-title-link" itemprop="url">ARM汇编-4 指针</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 23:34:37" itemprop="dateCreated datePublished" datetime="2021-04-25T23:34:37+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 16:35:30" itemprop="dateModified" datetime="2021-05-10T16:35:30+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h1><blockquote>
<p>指针也就是内存地址，指针变量是用来存放内存地址的变量。不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。<br>可使用 &amp; 运算符访问地址。</p>
</blockquote>
<p>之前的文章中有过说明，指针在内存中占8个字节。<br>可以是用sizeof来打印指针的size。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    a ++;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义一个int类型的指针a，然后赋值位100，我们知道指针的size是8个字节，a++之后打印多少？</p>
<p>答案是104。是的，没有看错，这里是因为指针的自增和自减操作，与执行的数据类型的宽度有关。</p>
<p>如果<code>a = (char *)100</code>,则打印的就是101。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    a &#x3D; a + 1;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个不是指针的自增、自减了，这个时候就跟指针的size有关了，打印108。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func_add() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    a &#x3D; (int *)100;</span><br><span class="line">    </span><br><span class="line">    int *b;</span><br><span class="line">    b &#x3D; (int *)200;</span><br><span class="line">    </span><br><span class="line">    int x &#x3D; a - b;</span><br><span class="line">    printf(&quot;x &#x3D; %d&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先说答案，打印的结果是<code>x = -25</code>。</p>
<p>a - b = -100, 然后除以4就得到了这个结果。</p>
<blockquote>
<p>指针的运算单位是执行的数据类型的宽度。</p>
</blockquote>
<h2 id="1-1-二级指针"><a href="#1-1-二级指针" class="headerlink" title="1.1 二级指针"></a>1.1 二级指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int **a;</span><br><span class="line">    a &#x3D; (int **)100;</span><br><span class="line">    a &#x3D; a + 1;</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候a运算时，执行的类型就是 <code>char *</code>类型，这是一个指针，8个字节。所以结果就是108。</p>
<h1 id="2-指针的汇编"><a href="#2-指针的汇编" class="headerlink" title="2. 指针的汇编"></a>2. 指针的汇编</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int *a;</span><br><span class="line">    int b &#x3D; 10;</span><br><span class="line">    a &#x3D; &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我们正常的理解，上述代码的意思就是把b的地址给到a，这个时候<code>*a=10</code>。</p>
<p>看一下上面的代码汇编之后是什么样子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">    0x100206130 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. x8 &#x3D; sp + 0x4，x8指向这个位置</span><br><span class="line">    0x100206134 &lt;+4&gt;:  add    x8, sp, #0x4              ; &#x3D;0x4 </span><br><span class="line">    &#x2F;&#x2F; 2. 局部变量，w9&#x3D;10</span><br><span class="line">    0x100206138 &lt;+8&gt;:  mov    w9, #0xa</span><br><span class="line">    &#x2F;&#x2F; 3. 把w9的值放在x8所在的地址上。</span><br><span class="line">    0x10020613c &lt;+12&gt;: str    w9, [sp, #0x4]</span><br><span class="line">    &#x2F;&#x2F; 4. 把x8存储的地址放在sp + 0x8的位置上。</span><br><span class="line">-&gt;  0x100206140 &lt;+16&gt;: str    x8, [sp, #0x8]</span><br><span class="line">    0x100206144 &lt;+20&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100206148 &lt;+24&gt;: ret</span><br></pre></td></tr></table></figure>

<p>通过lldb打印一下相关数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read sp</span><br><span class="line">      sp &#x3D; 0x000000016fbff880</span><br><span class="line"></span><br><span class="line">(lldb) register read x8</span><br><span class="line">      x8 &#x3D; 0x000000016fbff884</span><br><span class="line">   </span><br><span class="line">(lldb) register read x9</span><br><span class="line">      x9 &#x3D; 0x000000000000000a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印一下x8寄存器里的内存地址情况，里头存的值是0xa</span><br><span class="line">(lldb) x 0x000000016fbff884</span><br><span class="line">0x16fbff884: 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x16fbff894: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x8的地址放在了sp+0x8的位置，打印一下内存，就是x8存储的地址。</span><br><span class="line">(lldb) x 0x000000016fbff888</span><br><span class="line">0x16fbff888: 84 f8 bf 6f 01 00 00 00 00 00 00 00 00 00 00 00  ...o............</span><br><span class="line">0x16fbff898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>


<h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int arr[5] &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, *(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    char *p;</span><br><span class="line">    char a &#x3D; *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码，我们知道，只是把*p的值给了a<br>为什么会发生野指针呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Demo&#96;func:</span><br><span class="line">    0x100812134 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    &#x2F;&#x2F; 1. 因为p是指针。把sp + 0x8的地址中的值给x8</span><br><span class="line">-&gt;  0x100812138 &lt;+4&gt;:  ldr    x8, [sp, #0x8]</span><br><span class="line">    &#x2F;&#x2F; 2. 把x8寄存器中存的地址的值给w9</span><br><span class="line">    0x10081213c &lt;+8&gt;:  ldrb   w9, [x8]</span><br><span class="line">    0x100812140 &lt;+12&gt;: strb   w9, [sp, #0x7]</span><br><span class="line">    0x100812144 &lt;+16&gt;: add    sp, sp, #0x10             ; &#x3D;0x10 </span><br><span class="line">    0x100812148 &lt;+20&gt;: ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步寻址操作，获取x8寄存器的值的地址</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read sp</span><br><span class="line">      sp &#x3D; 0x000000016f5f3880</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sp + 0x8 &#x3D; 0x000000016f5f3888</span><br><span class="line">(lldb) x 0x000000016f5f3888</span><br><span class="line">0x16f5f3888: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x16f5f3898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line"></span><br><span class="line">(lldb) register read x8</span><br><span class="line">  x8 &#x3D; 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p> 这里发现 x8寄存器中存的地址是空，全是0。</p>
</li>
<li><p>把x8寄存器中地址所在的值给w9。寻址操作<br> 这里寻址是从0x00000000上找值，从空地址上找值，就会发生crash。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/18/OC%E5%8E%9F%E7%90%86/oc-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/OC%E5%8E%9F%E7%90%86/oc-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">3.对象的本质</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 13:39:47" itemprop="dateCreated datePublished" datetime="2021-04-18T13:39:47+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-18 10:12:01" itemprop="dateModified" datetime="2021-06-18T10:12:01+08:00">2021-06-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本篇使用的objc源码版本位818.2</p>
</blockquote>
<h1 id="1-clang介绍"><a href="#1-clang介绍" class="headerlink" title="1. clang介绍"></a>1. clang介绍</h1><p>Clang是一个由Apple主导的使用C++编写、基于LLVM、发布于LLVM BSD许可证下的C/C++/Objective-C/Objective-C++编译器。它与GNU C语言规范几乎完全兼容(当然，也有部分不兼容的内容， 包括编译命令选项也会有点差异)，并在此基础上增加了额外的语法特性，比如C函数重载 (通过<strong>attribute</strong>((overloadable))来修饰函数)，其目标(之一)就是超越GCC。</p>
<p>2013年4月,Clang已经全面支持C++11标准，并开始实现C++1y特性(也就是C++14，这是 C++的下一个小更新版本)。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。 </p>
<h2 id="1-1-clang的简单使用"><a href="#1-1-clang的简单使用" class="headerlink" title="1.1 clang的简单使用"></a>1.1 clang的简单使用</h2><p>我们通常想看代码的内部实现逻辑，通常会把源文件转换成cpp文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li>main.m 目标文件</li>
<li>main.cpp 转换后的文件</li>
</ul>
<h2 id="1-2-UIKit报错问题"><a href="#1-2-UIKit报错问题" class="headerlink" title="1.2 UIKit报错问题"></a>1.2 UIKit报错问题</h2><p>当我们想转化带有UIKit相关的的东西时，上面的命令就会报错了。使用如下命令即可</p>
<p>clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.3.sdk ViewController.m</p>
<p>如果还会报错，多数是因为<code>iPhoneSimulator14.3.sdk</code>没有找到，则通过xcode-contents找到对应的sdk即可。 </p>
<h2 id="1-3-xcrun"><a href="#1-3-xcrun" class="headerlink" title="1.3 xcrun"></a>1.3 xcrun</h2><p>xcode安装的时候顺带安装了<code>xcrun</code>命令，<code>xcrun</code>命令在<code>clang</code>的基础上进行了一些封装，要更好用一些。</p>
<ul>
<li><p>模拟器 - 使用如下命令<br>xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp </p>
</li>
<li><p>真机<br>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp</p>
</li>
</ul>
<h1 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h1><p>在main.m下创建一个Person类，然后通过上面的clang命令，找到我们需要的cpp文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#x2F;&#x2F; 添加一个属性，方便确认这就是我们要找的类</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>转化之后，在cpp文件里，我们找到了如下的结构体。</p>
<h2 id="2-1-类的声明"><a href="#2-1-类的声明" class="headerlink" title="2.1 类的声明"></a>2.1 类的声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @interface Person : NSObject。声明</span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现，一个对象，它本身就是一个结构体，内部有一个变量<code>Class isa</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>

<p>通过objc的源码，我们找到了<code>objc_object</code>的定义，其内部就是一个<code>Class isa</code>。与我们clang编译之后的<code>NSObject_IMPL</code>是一致的。所以<code>NSObject_IVARS</code>就是我们经常说的isa指针。</p>
<p>我们经常使用id类型来声明变量时不用带<code>*</code>，就是因为在底层已经做了处理。</p>
<h2 id="2-2-类的实现"><a href="#2-2-类的实现" class="headerlink" title="2.2 类的实现"></a>2.2 类的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @implementation Person</span><br><span class="line"></span><br><span class="line">static NSString * _I_Person_name(Person * self, SEL _cmd) </span><br><span class="line">&#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Person$_name)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Person_setName_(Person * self, SEL _cmd, NSString *name) </span><br><span class="line">&#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _name), (id)name, 0, 1); &#125;</span><br><span class="line">&#x2F;&#x2F; @end</span><br></pre></td></tr></table></figure>

<p>我们在上面的代码里，看到了两个方法</p>
<ol>
<li><code>_I_Person_name</code>：这是一个get方法，直接做了一个return操作。</li>
<li><code>_I_Person_setName_</code>：这是一个set方法，调用了<code>objc_setProperty</code>。</li>
</ol>
<h3 id="2-2-1-set方法"><a href="#2-2-1-set方法" class="headerlink" title="2.2.1 set方法"></a>2.2.1 set方法</h3><p>通过objc的源码，我们查找<code>objc_setProperty</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) </span><br><span class="line">&#123;</span><br><span class="line">    bool copy &#x3D; (shouldCopy &amp;&amp; shouldCopy !&#x3D; MUTABLE_COPY);</span><br><span class="line">    bool mutableCopy &#x3D; (shouldCopy &#x3D;&#x3D; MUTABLE_COPY);</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部判断是通过copy还是mutableCopy，然后调用<code>reallySetProperty</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue &#x3D; [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot &#x3D;&#x3D; newValue) return;</span><br><span class="line">        newValue &#x3D; objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最主要的操作，就是对oldvalue进行release操作，新值进行retain操作。</p>
<p>这也是经常在面试时，经常会问的，声明一个@property内部有哪些操作的的答案：</p>
<ol>
<li>自动创建带有<code>_</code>的变量。</li>
<li>自动实现set、get方法。</li>
</ol>
<p><img src="set_property.jpg" alt=""></p>
<p>苹果的这种设计思路很值得我们学习。它提供了一个对外的接口供上层调用，其内部调用底层的方法。这样上层无论怎么变化，都不会影响底层接口及实现。</p>
<h1 id="3-isa"><a href="#3-isa" class="headerlink" title="3. isa"></a>3. isa</h1><p>我们应该还记得在【alloc、init、new】这一节中有<code>callAlloc</code>这个方法，这个方法有一步操作是进行对象关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    ASSERT(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就看看这里是怎么搞的。对代码进行了简化，如果有需要请自行查看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    &#x2F;&#x2F; 这个是重点，创建一个isa_t，这个isa_t是啥呢？我们点进去看一下。</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下代码可以等先看我isa_t之后再回过头来看。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对bits内容赋默认值</span><br><span class="line">    newisa.bits &#x3D; ISA_MAGIC_VALUE;      </span><br><span class="line">    &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">    &#x2F;&#x2F; 这里是关联对象，就是本节的重点内容，我们进去看这个setClass是怎么实现的。</span><br><span class="line">    newisa.setClass(cls, this);</span><br><span class="line">    newisa.extra_rc &#x3D; 1;</span><br><span class="line">    isa &#x3D; newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先看下isa_t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">private: &#x2F;&#x2F;这是个私有的，不会主动赋值，而是通过赋值别的变量(bits)时给的。</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    void setClass(Class cls, objc_object *obj);</span><br><span class="line">    Class getClass(bool authenticated);</span><br><span class="line">    Class getDecodedClass(bool authenticated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码做了精简处理，看起来会容易点，这个其实就是一个<b>【联合位域】</b>。<br>union是联合体。里面有一个struct。这种方式就是为了优化内存空间，在极少的内存情况下，来使用。举个例子来看一下：</p>
<p>如果我们需要声明一个car的类，定义4个属性，前后左右行驶。如果是int类型的数据，那就是需要4 * 4 = 16个字节的空间，也就是128位。但是如果使用联合位域的话，就可以极大的减少空间。只需要4位就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union car &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        char forward;   &#x2F;&#x2F;1</span><br><span class="line">        char back;      &#x2F;&#x2F;1</span><br><span class="line">        char left;      &#x2F;&#x2F;1</span><br><span class="line">        char right;     &#x2F;&#x2F;1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是<code>0000</code>，第一个0代表的是前，第二个0代表后，依次类推。</p>
<p>知道了联合位域的大概情况，我们就看一下这个<code>ISA_BITFIELD</code>是个什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">        uintptr_t magic             : 6;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t unused            : 1;                                       \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">#     define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#     define RC_HALF  (1ULL&lt;&lt;18)</span><br></pre></td></tr></table></figure>

<p><img src="isa_t.jpg" alt=""></p>
<p>注意：这个是ARM64下的存储，而使用（非M1芯片）电脑本地运行的的都是基于x86_64的，所以这里面的值存储的位置是有些变化的。</p>
<p>特别提一下shiftcls，在ARM64下是33位，在x86下是44位，导致magic开始的位置分别是36和47，这个位置一会有用到。</p>
<ul>
<li>nonpointer:表示是否对 isa 指针开启指针优化 0:纯isa指针，1:不止是类对象地址,isa 中包含了类信息、对象的引用计数等，在iOS中，正常情况下生成的对象nonpointer都等于1。</li>
<li>has_assoc:关联对象标志位，0没有，1存在</li>
<li>has_cxx_dtor:该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象。oc中的<code>dealloc</code></li>
<li>shiftcls:存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li>
<li>magic:用于调试器判断当前对象是真的对象还是没有初始化的空</li>
<li>weakly_referenced:志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。 </li>
<li>unsed:不同版本的是<code>deallocating</code>，标志对象是否正在释放内存</li>
<li>has_sidetable_rc:当对象引用技术大于 10 时，则需要借用该变量存储进位</li>
<li>extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li>
</ul>
<p>我们了解了isa是啥东西了之后，在回过头看看是怎么进行管理对象的。了解上面的代码之后，我们继续看setCalss是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对代码进行了简化，</span><br><span class="line">inline void</span><br><span class="line">isa_t::setClass(Class newCls, UNUSED_WITHOUT_PTRAUTH objc_object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    shiftcls &#x3D; (uintptr_t)newCls &gt;&gt; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很不可思议，只是通过newCls向右偏移了3位。为啥偏移3位？<br>我们知道isa-&gt;shiftcls存储类指针的值。是从isa的内存里面第3位开始的。就这么简单。因为在内存里没有办法直接存储类名，所以通过存储数字替带。</p>
<h2 id="3-1-验证isa指针的关联过程"><a href="#3-1-验证isa指针的关联过程" class="headerlink" title="3.1 验证isa指针的关联过程"></a>3.1 验证isa指针的关联过程</h2><p><code>Person *p = [[Person alloc] init];</code> 运行objc源码工程。<br>断点进入<code>objc_object::initIsa</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    &#x2F;&#x2F; ① 创建newisa</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ② 对bits内容赋默认值</span><br><span class="line">    newisa.bits &#x3D; ISA_MAGIC_VALUE;      </span><br><span class="line">    &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    &#x2F;&#x2F; ③ </span><br><span class="line">    newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">    &#x2F;&#x2F; ④ 这里是关联对象，就是本节的重点内容，我们进去看这个setClass是怎么实现的。</span><br><span class="line">    newisa.setClass(cls, this);</span><br><span class="line">    newisa.extra_rc &#x3D; 1;</span><br><span class="line">    isa &#x3D; newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当断点走到②的时候。我们输出一些newisa的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p newisa</span><br><span class="line">(isa_t) $1 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 0</span><br><span class="line">  cls &#x3D; nil</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 0</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 0</span><br><span class="line">    magic &#x3D; 0</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续执行下一步，仍然输出newisa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p newisa</span><br><span class="line">(isa_t) $5 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 8303511812964353</span><br><span class="line">  cls &#x3D; 0x001d800000000001</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 1</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 0</span><br><span class="line">    magic &#x3D; 59</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有了变化，bits有初值了，cls也被赋值了，而且magic也被赋值了。这些都是默认值，我们上面说了isa的内部是64位的数据。我们把cls的值，放在二进制的计算器里，看看是什么内容。第一位1对应的是nonpointer=1</p>
<p><img src="magic_47.png" alt=""></p>
<p>看这个图，第47位开始的6位数据是110111，这个二进制数是什么？正好是59。</p>
<p>之后，继续断点下一步。走到④。然后进到setClass方法内部，我们执行语句，看看cls偏移后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (uintptr_t)newCls</span><br><span class="line">(uintptr_t) $15 &#x3D; 4295000320</span><br><span class="line">(lldb) po (uintptr_t)newCls &gt;&gt; 3</span><br><span class="line">536875040</span><br></pre></td></tr></table></figure>

<p>然后继续下一步，打印newisa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lldb) p newisa</span><br><span class="line">(isa_t) $11 &#x3D; &#123;</span><br><span class="line">  bits &#x3D; 8303516107964673</span><br><span class="line">  cls &#x3D; Person</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">    nonpointer &#x3D; 1</span><br><span class="line">    has_assoc &#x3D; 0</span><br><span class="line">    has_cxx_dtor &#x3D; 0</span><br><span class="line">    shiftcls &#x3D; 536875040</span><br><span class="line">    magic &#x3D; 59</span><br><span class="line">    weakly_referenced &#x3D; 0</span><br><span class="line">    unused &#x3D; 0</span><br><span class="line">    has_sidetable_rc &#x3D; 0</span><br><span class="line">    extra_rc &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯哼。。。。。是不是，就是这么牛。shiftcls是啥，存储类指针的值。也验证了我们上面说的，是从isa的内存里面第3位开始的。就这么简单。因为在内存里没有办法直接存储类名，所以通过存储数字替带。</p>
<p>我们继续执行，返回到<code>_class_createInstanceFromZone</code>这个函数里，<br>然后先停一停哈，不要走断点了哈~我们来通过<code>object_getClass</code>在来验证一下。</p>
<h2 id="3-2-反向验证-ISA-MASK"><a href="#3-2-反向验证-ISA-MASK" class="headerlink" title="3.2 反向验证 ISA_MASK"></a>3.2 反向验证 ISA_MASK</h2><p>我们通过object_getClass来反向验证isa指向。这里全部对代码进行了简化。如有需要请自行查看源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">objc_object::getIsa() </span><br><span class="line">&#123;</span><br><span class="line">    if (fastpath(!isTaggedPointer())) return ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">objc_object::ISA(bool authenticated)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return isa.getDecodedClass(authenticated);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Class</span><br><span class="line">isa_t::getClass(MAYBE_UNUSED_AUTHENTICATED_PARAM bool authenticated) &#123;</span><br><span class="line">    uintptr_t clsbits &#x3D; bits;</span><br><span class="line">    clsbits &amp;&#x3D; ISA_MASK;</span><br><span class="line">    return (Class)clsbits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到了结果了，最后就是通过<code>bits &amp; ISA_MASK</code>来返回当前class的。还记得bits是啥吗？往上翻一下，bits是isa指针内部的第一个元素。所以我们按照这个&amp;运算来验证一些，返回的数据是不是person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;4gx obj</span><br><span class="line">0x10060d9b0: 0x011d800100008101 0x0000000000000000</span><br><span class="line">0x10060d9c0: 0x0000000000000000 0x86c8f7c495bce30f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿第一位的地址进行&amp;运算，注意这里是在mac上，所以使用x86下的ISA_MASK值</span><br><span class="line">(lldb) po 0x011d800100008101 &amp; 0x00007ffffffffff8ULL</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>以上就是isa的全部内容了。但是isa里面的这些东西是真的有用吗？肯定是有用的啊，我们从dealloc的函数实现去找到蛛丝马迹。</p>
<h1 id="4-补充-dealloc"><a href="#4-补充-dealloc" class="headerlink" title="4.补充 dealloc"></a>4.补充 dealloc</h1><p>在objc源码中找到dealloc的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，见证奇迹的时候到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  &#x2F;&#x2F; fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer                     &amp;&amp;</span><br><span class="line">         !isa.weakly_referenced             &amp;&amp;</span><br><span class="line">         !isa.has_assoc                     &amp;&amp;</span><br><span class="line">#if ISA_HAS_CXX_DTOR_BIT</span><br><span class="line">         !isa.has_cxx_dtor                  &amp;&amp;</span><br><span class="line">#else</span><br><span class="line">         !isa.getClass(false)-&gt;hasCxxDtor() &amp;&amp;</span><br><span class="line">#endif</span><br><span class="line">         !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>objc_object::rootDealloc</code>中对isa的各个属性的值来判断是执行<code>free</code>操作或者<code>object_dispose</code>。free函数就不用多说了，来看看dispose操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是整个的dealloc的流程。通过源码只是来加深对这些流程的印象。<br>到这里，对象的alloc、init、dealloc都已经出现了，接下来就是类相关了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">oc-2-内存对齐</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 18:34:07" itemprop="dateCreated datePublished" datetime="2021-04-17T18:34:07+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 11:47:21" itemprop="dateModified" datetime="2021-06-09T11:47:21+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h1><p>在上一节中，我们知道开辟空间会用到<code>calloc</code>这个函数，那我们就追一下这个函数的内部逻辑。</p>
<p>但是发现<code>calloc</code>这个方法没有办法继续下一步追踪了，如图：</p>
<p><img src="calloc-1.jpg" alt=""></p>
<p>我们发现<code>calloc</code>定义在<code>malloc/_malloc.h</code>文件下，我们也找到了对应的<a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">源码</a>。我这里用的是一份可运行的源码。</p>
<p>接下来，直接上代码，在main函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 开辟40个字节的空间</span><br><span class="line">void *p &#x3D; calloc(1, 40);</span><br><span class="line">NSLog(@&quot;%lu&quot;,malloc_size(p));</span><br></pre></td></tr></table></figure>

<p>直接运行，查看<code>malloc.c -&gt; calloc</code>的内部实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">calloc(size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	return _malloc_zone_calloc(default_zone, num_items, size, MZ_POSIX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>calloc</code>只是调用了<code>_malloc_zone_calloc</code>方法，其它啥也没做，这里需要注意的是，<code>default_zone</code>参数，它是一个虚拟的默认zone，通过它可以做一些事情，如下：</p>
<h2 id="malloc-zone-calloc"><a href="#malloc-zone-calloc" class="headerlink" title="_malloc_zone_calloc"></a>_malloc_zone_calloc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size,</span><br><span class="line">		malloc_zone_options_t mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	if (malloc_check_start) &#123;</span><br><span class="line">		internal_check();</span><br><span class="line">	&#125;</span><br><span class="line">	ptr &#x3D; zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line">	if (os_unlikely(malloc_logger)) &#123;</span><br><span class="line">		malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,</span><br><span class="line">				(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);</span><br><span class="line">	if (os_unlikely(ptr &#x3D;&#x3D; NULL)) &#123;</span><br><span class="line">		malloc_set_errno_fast(mzo, ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>calloc</code>直接调用的是<code>_malloc_zone_calloc</code>。我们看一下这个函数的实现。通过返回值，我们确定重点代码应该与<code>ptr</code>有关。所以<code>_malloc_zone_calloc</code>精简如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size,</span><br><span class="line">		malloc_zone_options_t mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	&#x2F;&#x2F; ptr初始化，这里打一个断点</span><br><span class="line">	ptr &#x3D; zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行到这里，发现<code>zone-&gt;calloc</code>进去是一个函数的声明，有没有下文了。这是，我们用lldb调试，打印一下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p zone-&gt;calloc</span><br><span class="line">(void *(*)(_malloc_zone_t *, size_t, size_t)) $0 &#x3D; 0x00000001002f4b93 (.dylib&#96;default_zone_calloc at malloc.c:385)</span><br></pre></td></tr></table></figure>

<p>感觉发现了新大陆：<code>default_zone_calloc</code>在<code>malloc.c</code>文件的第385行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	zone &#x3D; runtime_default_zone();</span><br><span class="line">	</span><br><span class="line">	return zone-&gt;calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，又有一个<code>zone</code>。这个才是创建的runtime时的default zone。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_NOEXPORT malloc_zone_t* lite_zone &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">MALLOC_ALWAYS_INLINE</span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">runtime_default_zone() &#123;</span><br><span class="line">  &#x2F;&#x2F; lite_zone &#x3D; null，所以会执行创建</span><br><span class="line">	return (lite_zone) ? lite_zone : inline_malloc_default_zone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⬇️</span><br><span class="line"></span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">inline_malloc_default_zone(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 只创建一次，内部是一个os_once</span><br><span class="line">    _malloc_initialize_once();</span><br><span class="line">    &#x2F;&#x2F; malloc_report(ASL_LEVEL_INFO, &quot;In inline_malloc_default_zone with %d %d\n&quot;, malloc_num_zones, malloc_has_debug_zone);</span><br><span class="line">    &#x2F;&#x2F; 可以看到malloc_zones是一个(malloc_zone_t **)类型的数据</span><br><span class="line">    &#x2F;&#x2F; malloc_zone_t **malloc_zones &#x3D; (malloc_zone_t **)0xdeaddeaddeaddead;</span><br><span class="line">    return malloc_zones[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看一下<code>malloc_zones</code>的内容：</p>
<p><img src="malloc_zones.png" alt=""></p>
<h2 id="malloc-zone-t"><a href="#malloc-zone-t" class="headerlink" title="_malloc_zone_t"></a>_malloc_zone_t</h2><p>上面的大部分内容都是围绕着<code>_malloc_zone_t</code>展开的。</p>
<p>这里可以看到<code>malloc_zones[0]</code>的元素就是一个<code>malloc_zone_t *</code>类型的数据，根据lldb打印出来的数据和查看到的内容可以看到<code>malloc_zone_t</code>中存放的就是一些我们在开辟空间时需要调用的方法。</p>
<p>看一下<code>_malloc_zone_t</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define MALLOC_ZONE_FN_PTR(fn) fn</span><br><span class="line"></span><br><span class="line">typedef struct _malloc_zone_t &#123;</span><br><span class="line">    &#x2F;* Only zone implementors should depend on the layout of this structure;</span><br><span class="line">    Regular callers should use the access functions below *&#x2F;</span><br><span class="line">    void	*reserved1;	&#x2F;* RESERVED FOR CFAllocator DO NOT USE *&#x2F;</span><br><span class="line">    void	*reserved2;	&#x2F;* RESERVED FOR CFAllocator DO NOT USE *&#x2F;</span><br><span class="line">    size_t 	(* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); </span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);</span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); </span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); &#x2F;* same as malloc, but block returned is set to zero and is guaranteed to be page aligned *&#x2F;</span><br><span class="line">    void 	(* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);</span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);</span><br><span class="line">    void 	(* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone);</span><br><span class="line">    const char	*zone_name;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);</span><br><span class="line">&#125; malloc_zone_t;</span><br></pre></td></tr></table></figure>

<p>结构体中的数据与我们图片上的内容是一样的，定义了很多的方法。以<code>calloc</code>为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void 	*(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size);</span><br><span class="line"></span><br><span class="line">转换之后的方法为：</span><br><span class="line"></span><br><span class="line">calloc(_malloc_zone_t *zone, size_tnum_items, size_t size) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用.dylib中的方法，nano_malloc.c : 878</span><br><span class="line">    nano_calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用同样的方式打印一下看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po zone-&gt;calloc</span><br><span class="line">(.dylib&#96;nano_calloc at nano_malloc.c:878)</span><br></pre></td></tr></table></figure>

<p>打印出来的信息已经很全面了，同样告诉我们了<code>nano_calloc</code>方法在<code>nano_malloc.c</code>文件中。</p>
<h2 id="nano-calloc"><a href="#nano-calloc" class="headerlink" title="nano_calloc"></a>nano_calloc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	size_t total_bytes;</span><br><span class="line">   &#x2F;&#x2F; alloc之前需要先判断申请的空间大小是否合理</span><br><span class="line">	if (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果获取到的大小在系统约定的最大值范围内则，直接进行malloc。</span><br><span class="line">	if (total_bytes &lt;&#x3D; NANO_MAX_SIZE) &#123;</span><br><span class="line">	   &#x2F;&#x2F; 所以一定会走这里</span><br><span class="line">		void *p &#x3D; _nano_malloc_check_clear(nanozone, total_bytes, 1);</span><br><span class="line">		if (p) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;* FALLTHROUGH to helper zone *&#x2F;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_zone_t *zone &#x3D; (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line">	&#x2F;&#x2F; 如果初始化失败，则继续执行。</span><br><span class="line">	return zone-&gt;calloc(zone, 1, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>nano_calloc</code>中，我们同样的先看返回值，最底部的是又继续调用了<code>zone-&gt;calloc</code>，感觉不太对，上面就找到了还有一个返回<code>p</code>的位置。运行也确实会走到这里。</p>
<p>接下来就是重点了哈~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	size_t slot_key;   &#x2F;&#x2F; 插槽的key</span><br><span class="line">	&#x2F;&#x2F; 获取真正的内存大小，以及slot_key</span><br><span class="line">	size_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key); &#x2F;&#x2F; Note slot_key is set here</span><br><span class="line">	&#x2F;&#x2F; 拿到插槽的index</span><br><span class="line">	mag_index_t mag_index &#x3D; nano_mag_index(nanozone);</span><br><span class="line">  &#x2F;&#x2F;  </span><br><span class="line">	nano_meta_admin_t pMeta &#x3D; &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line"></span><br><span class="line">	ptr &#x3D; OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));</span><br><span class="line">	if (ptr) &#123;</span><br><span class="line">		&#x2F;&#x2F; 这里都是error的判断</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	   &#x2F;&#x2F; 死循环获取内存指针，拿到返回</span><br><span class="line">		ptr &#x3D; segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (cleared_requested &amp;&amp; ptr) &#123;</span><br><span class="line">		memset(ptr, 0, slot_bytes); &#x2F;&#x2F; TODO: Needs a memory barrier after memset to ensure zeroes land first?</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来看一下开辟空间的算法：segregated_size_to_fit</p>
<h2 id="segregated-size-to-fit"><a href="#segregated-size-to-fit" class="headerlink" title="segregated_size_to_fit"></a>segregated_size_to_fit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static MALLOC_INLINE size_t</span><br><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span><br><span class="line">&#123;</span><br><span class="line">	size_t k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	if (0 &#x3D;&#x3D; size) &#123;</span><br><span class="line">		size &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior</span><br><span class="line">	&#125;</span><br><span class="line">	k &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta</span><br><span class="line">	slot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;							&#x2F;&#x2F; multiply by power of two quanta size</span><br><span class="line">	*pKey &#x3D; k - 1;													&#x2F;&#x2F; Zero-based!</span><br><span class="line"></span><br><span class="line">	return slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法在上一节中计算<code>alignedInstanceSize</code>类似。这里的主要逻辑是先右移4位，再左移4位。相当于把后4位抹零。拿我们开辟空间传进来的40为例计算一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(size + NANO_REGIME_QUANTA_SIZE - 1) &#x3D; 40 + 15 -1</span><br><span class="line">54 -&gt; 0011 0110</span><br><span class="line">&gt;&gt; 4  0000 0011         &#x2F;&#x2F; 右移4位</span><br><span class="line">&lt;&lt; 4  0011 0000 &#x3D; 48    &#x2F;&#x2F; 左移4位</span><br></pre></td></tr></table></figure>

<p>这里计算出来的大小就是48。而<code>slot_key=47</code>。之后就是获取内存指针。</p>
<p><img src="calloc-2.jpg" alt=""></p>
<p>这就是<code>calloc</code>的流程，同时，再一次验证了，iOS在内存中是16字节对齐。</p>
<h1 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h1><p>结构体内存对齐3打原则：</p>
<blockquote>
<ol>
<li>数据成员对⻬规则：结构体(struct)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始(比如int为4字节,则要从4的整数倍地址开始存储。</li>
<li>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a里存有struct b，b里有char，int, double等元素，那b应该从8的整数倍开始存储)</li>
<li>收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍。不足的要补⻬。</li>
</ol>
</blockquote>
<p>开始代码之前，先了解一下各种数据类型所占的内存大小：</p>
<p><img src="calloc-3.jpg" alt=""></p>
<p>接下来上代码，看看结构体的内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   </span><br><span class="line">    char b;     </span><br><span class="line">    int c;      </span><br><span class="line">    short d;    </span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a; </span><br><span class="line">    int b;    </span><br><span class="line">    char c;   </span><br><span class="line">    short d;  </span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str1 &#x3D; %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>输出的结果很明白的哈。<code>str1 = 24, str2-16</code></p>
<p>我们分析一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F; 8 (0-7)</span><br><span class="line">    char b;     &#x2F;&#x2F; 1 [8 1] (8)</span><br><span class="line">    int c;      &#x2F;&#x2F; 4 [9 10 11 12] 9不是4的整数倍(12 13 14 15)</span><br><span class="line">    short d;    &#x2F;&#x2F; 2 [16 17]</span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部需要的大小为: 17</span><br><span class="line">&#x2F;&#x2F; 最大属性 : 8</span><br><span class="line">&#x2F;&#x2F; 结构体整数倍: 24</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F;8 (0-7)</span><br><span class="line">    int b;      &#x2F;&#x2F;4 (8 9 10 11)</span><br><span class="line">    char c;     &#x2F;&#x2F;1 (12)</span><br><span class="line">    short d;    &#x2F;&#x2F;2 (13 14) 13不是2的整数倍，从14开始(14 15)</span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部需要的大小为: 15</span><br><span class="line">&#x2F;&#x2F; 最大属性 : 8</span><br><span class="line">&#x2F;&#x2F; 结构体整数倍: 16</span><br><span class="line">NSLog(@&quot;str1 &#x3D; %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>如果结构体内部套用结构体呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Struct3 &#123;</span><br><span class="line">    double a;   &#x2F;&#x2F;8 (0-7)</span><br><span class="line">    int b;      &#x2F;&#x2F;4 (8 9 10 11)</span><br><span class="line">    char c;     &#x2F;&#x2F;1 (12)</span><br><span class="line">    struct Struct2 str_2;   &#x2F;&#x2F; 13 14 15 (16 - 31)</span><br><span class="line">&#125;str3;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str3 &#x3D; %lu&quot;, sizeof(str3));</span><br></pre></td></tr></table></figure>

<p>按照内存对齐第二条原则，结构体成员从其内部最大成员的size的整数倍开始。c的位置是12，接下来的位置是13，不满足8的整数倍。所以按照原则，前面补齐，从16位开始。所以str3结构体的大小为32。</p>
<h1 id="对象的内存对齐"><a href="#对象的内存对齐" class="headerlink" title="对象的内存对齐"></a>对象的内存对齐</h1><p>老样子，先看代码哈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int score;</span><br><span class="line">@property (nonatomic, assign) long height;</span><br><span class="line">@property (nonatomic) char c1;</span><br><span class="line">@property (nonatomic) char c2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">Person *person &#x3D; [Person alloc];</span><br><span class="line">person.name &#x3D; @&quot;name&quot;;</span><br><span class="line">person.age &#x3D; 18;</span><br><span class="line">person.score &#x3D; 20;</span><br><span class="line">person.height &#x3D; 180;</span><br><span class="line">person.c1 &#x3D; &#39;a&#39;;</span><br><span class="line">person.c2 &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,person,sizeof(person),class_getInstanceSize([Person class]),malloc_size((__bridge const void *)(person)));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在NSLog上打个断点。有时间的话，可以把属性先注释掉，从0开始，一个属性一个属性的加起来看输出的是什么结果。</p>
<ol>
<li><p>po 这里直接输出person指向的对象的内存地址。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po person</span><br><span class="line">&lt;Person: 0x600002adbcf0&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里有一个需要介绍的点，上一章中有用到x person命令，输出的内容与<code>View Memory</code>中显示的是一致的。而<code>x/8gx</code>就是进行排序。8代表的是输出8组内存。如果是4那就是输出4组内容。每一块都是8个字节。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8gx person</span><br><span class="line">0x600002adbcf0: 0x0000000103930808 0x0000001200006261</span><br><span class="line">0x600002adbd00: 0x0000000000000014 0x000000010392b038</span><br><span class="line">0x600002adbd10: 0x00000000000000b4 0x0000000000000000</span><br><span class="line">0x600002adbd20: 0x0000c1c5c19bbd20 0x00000000000007fb</span><br></pre></td></tr></table></figure>
<p> 0x600002adbcf0：是person指向的首地址。后面存放的都是属性的值。内存都是连续的。</p>
</li>
<li><p>我们分别输出内存里的内容。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0000000103930808</span><br><span class="line">Person  &#x2F;&#x2F; isa指针</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000012</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">(lldb) 0x61是十进制的97 -&gt; a</span><br><span class="line"></span><br><span class="line">(lldb) po 0x0000000000000014</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">(lldb) po 0x000000010392b038</span><br><span class="line">name</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000000000000b4</span><br><span class="line">180</span><br></pre></td></tr></table></figure>

<p> 0x0000001200006261：这一块地址上内容是被拆开的。我们知道int是4个字节，char是1个字节，所以前面的几位是int的值，后面的再进行拆分，分别是两个char类型的数据。</p>
<p> 苹果在内存上也是做了足够多的优化，虽然在内存上是16个字节对齐的，以空间换时间，提高读取效率，但是在内部实现上，还是进行了大量的优化，这样做的目的是最大限度的节约内存同时保证数据的安全性，但是一定要注意的是，属性是按8个字节对齐的。</p>
<p> 但是为啥两个int类型的数据没有放在一起呢？可能是系统内部做的优化，可以试一下，把所有的char类型注释掉，两个int类型的数据就会存放在一起。可能是会将char类型的数据优先进行填充吧。另外可以多试一下，3个char类型的会怎么样，等等…</p>
</li>
<li><p>最后输出的结果是</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600002adbcf0&gt; - 8 - 40 - 48</span><br></pre></td></tr></table></figure>
<p> 我们分析一下输出的内容：</p>
<ul>
<li>person：当前的类对象，存放的指针，指向的内存地址。</li>
<li>sizeof(person)：person存放的就是一个指针，8个字节。</li>
<li>class_getInstanceSize([Person class])：这个类真正需要的空间。属性是8个字节对齐的。</li>
<li>malloc_size((__bridge const void *)(person))：内存中需要开辟的空间。内存空间是16个字节对齐的。</li>
</ul>
</li>
</ol>
<h2 id="float、double"><a href="#float、double" class="headerlink" title="float、double"></a>float、double</h2><p>加如改变其中的一个属性位double类型的，又会是什么情况呢？我这里把上面的height改为了double类型。看一下输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8gx person</span><br><span class="line">0x600000045530: 0x000000010626d808 0x0000001200006261</span><br><span class="line">0x600000045540: 0x0000000000000014 0x0000000106268038</span><br><span class="line">0x600000045550: 0x4066800000000000 0x0000000000000000</span><br><span class="line">0x600000045560: 0x0000000000000000 0x0000000000000000</span><br><span class="line">(lldb) po 0x4066800000000000</span><br><span class="line">4640537203540230144</span><br></pre></td></tr></table></figure>

<p>诶<del>~</del> 怎么没有输出180呢？是因为对于float、double类型的数据，系统会做一次特殊的转换处理。我们没有办法直接从内存中读出double类型的值。</p>
<p>但是我们可以通过转化double类型的数据来看是否位上面对应的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x (double)180.0</span><br><span class="line">(double) $4 &#x3D; 0x4066800000000000</span><br></pre></td></tr></table></figure>
<p>转换后，发现正好是对应的数据。</p>
<p>这里当然有读取浮点数的方法<code>p/f [0x000000123]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;f 0x4066800000000000</span><br><span class="line">(long) $5 &#x3D; 180</span><br></pre></td></tr></table></figure>

<p>这就是内存补齐的内容</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>calloc的流程。</li>
<li>结构体的对齐规则。</li>
<li>类对象的属性是8个字节对齐的，但是在内存空间是16个字节对齐。</li>
<li>x/4gx的使用</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">libmalloc源码</a><br><a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">苹果更多源码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-1-alloc-init-new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-1-alloc-init-new/" class="post-title-link" itemprop="url">OC-1-alloc、init、new</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 09:20:25" itemprop="dateCreated datePublished" datetime="2021-04-17T09:20:25+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 10:10:02" itemprop="dateModified" datetime="2021-06-09T10:10:02+08:00">2021-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-先看一个问题"><a href="#1-先看一个问题" class="headerlink" title="1. 先看一个问题"></a>1. 先看一个问题</h1><p>我们先看一段代码，打印一下输出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 &#x3D; [Person alloc];</span><br><span class="line">Person *p2 &#x3D; [p1 init];</span><br><span class="line">Person *p3 &#x3D; [p1 init];</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p1,p1,&amp;p1);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p2,p2,&amp;p2);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p3,p3,&amp;p3);</span><br></pre></td></tr></table></figure>

<p>看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114068</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114060</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114058</span><br></pre></td></tr></table></figure>

<p>前两个打印的都是当前对象的指针地址，而最后一个为啥会不一样？<br>首先需要明白p和&amp;p的区别：p是当前变量指向的地址。&amp;p是存放当前变量所在的地址。<br>这里第一个%p打印就是[Person alloc]生成的地址。第二个%p是存放的是指向【生成的对象】的地址。</p>
<p>也就是当前alloc生成一个对象开辟了一块内存空间。p1、p2、p3分别开辟一块地址指向alloc开辟的空间。</p>
<p><img src="oc-address.png" alt=""></p>
<p>我们可以通过汇编模式或者符号断点查看源码所在的位置。这里不细说了，比较简单。最后定位的源码位置在<code>libobjc.A.dylib-&gt;objc_init</code>。</p>
<h1 id="2-alloc的执行过程"><a href="#2-alloc的执行过程" class="headerlink" title="2. alloc的执行过程"></a>2. alloc的执行过程</h1><p>那我们接下来要看alloc是怎么执行的。需要看objc的源码。<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4源码</a>是可以直接下载的。我们这里用的是最新的818.2版本的。</p>
<p>通过一系列风骚的操作，我们让源码可以运行起来。通过断点和源码我们分析一下alloc的执行过程。</p>
<h2 id="2-1-objc-rootAlloc"><a href="#2-1-objc-rootAlloc" class="headerlink" title="2.1 _objc_rootAlloc"></a>2.1 _objc_rootAlloc</h2><p>在main.m中，创建一个对象，打上断点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p &#x3D; [Person alloc];</span><br><span class="line">Person *p1 &#x3D; [p init];</span><br></pre></td></tr></table></figure>

<p>这里只是alloc的最基本的方法。没有什么代码量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-callAlloc"><a href="#2-2-callAlloc" class="headerlink" title="2.2 callAlloc"></a>2.2 callAlloc</h2><p>这里是核心代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__ &#x2F;&#x2F; 是个宏定义</span><br><span class="line">    &#x2F;&#x2F; slowpath表示括号内的条件可能性教小</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    &#x2F;&#x2F; fastpath表示括号内的条件可能性教大</span><br><span class="line">    &#x2F;&#x2F; 如果有自定义的allocWithZone（hasCustomAWZ）</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);   &#x2F;&#x2F; 1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available. 根据传进来的参数判断</span><br><span class="line">    if (allocWithZone) &#123;                            &#x2F;&#x2F; 2. </span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); &#x2F;&#x2F; 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>该处内容是现阶段alloc执行的代码</li>
<li>根据<code>callAlloc</code>调用传进来的参数判断，基本都会执行【1】。</li>
<li>通过消息发送，执行<code>alloc</code>，这里有个很有意思的点，源码跑起来就能知道。</li>
</ol>
<h2 id="2-3-objc-rootAllocWithZone"><a href="#2-3-objc-rootAllocWithZone" class="headerlink" title="2.3 _objc_rootAllocWithZone"></a>2.3 _objc_rootAllocWithZone</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-class-createInstanceFromZone"><a href="#2-4-class-createInstanceFromZone" class="headerlink" title="2.4 _class_createInstanceFromZone"></a>2.4 _class_createInstanceFromZone</h2><p>这里是重中之重。alloc的流程都在这里完美的展示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 既然要生成一个对象，首先要做的就是开辟空间，但是要开辟多少？</span><br><span class="line">    &#x2F;&#x2F; 由对象的ivars决定。在iOS中，字节是8自己对齐，而内存是16字节对齐，所以小于16字节会补齐</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 2. 算出来需要多少空间，这里进行开辟</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 极少数情况下，obj会创建失败</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3. 空间有了，这里进行对象关联</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-cls-gt-instanceSize"><a href="#2-4-1-cls-gt-instanceSize" class="headerlink" title="2.4.1 cls-&gt;instanceSize"></a>2.4.1 cls-&gt;instanceSize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    &#x2F;&#x2F; 有缓存的情况下</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 新开辟</span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果有缓存的情况下，则会执行fastInstanceSize。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t fastInstanceSize(size_t extra) const</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(hasFastInstanceSize(extra));</span><br><span class="line"></span><br><span class="line">    if (__builtin_constant_p(extra) &amp;&amp; extra &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return _flags &amp; FAST_CACHE_ALLOC_MASK16;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        size_t size &#x3D; _flags &amp; FAST_CACHE_ALLOC_MASK;</span><br><span class="line">        &#x2F;&#x2F; remove the FAST_CACHE_ALLOC_DELTA16 that was added</span><br><span class="line">        &#x2F;&#x2F; by setFastInstanceSize</span><br><span class="line">        &#x2F;&#x2F; 内存对齐是16字节</span><br><span class="line">        return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新开辟空间时计算对象所在空间</span><br><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() const &#123;</span><br><span class="line">    return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 8字节对齐</span><br><span class="line">static inline size_t word_align(size_t x) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过算法得到8字节的倍数</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 16字节对齐 fastInstanceSize</span><br><span class="line">static inline size_t align16(size_t x) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过算法得到16字节的倍数</span><br><span class="line">    return (x + size_t(15)) &amp; ~size_t(15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举例说明一下算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; WORD_MASK &#x3D; 7</span><br><span class="line">(x + 7) &amp; ~7;</span><br><span class="line">&#x2F;&#x2F; x &#x3D; 2, x + 7 &#x3D; 9   -&gt; 0000 1001  ⬇️   x&#x3D;10 17 &#x3D; 0001 0001</span><br><span class="line">&#x2F;&#x2F; 7 &#x3D; 0000 0111 -&gt; !7 &#x3D; 1111 1000  ⬇️        !7 &#x3D; 1111 1000</span><br><span class="line">&#x2F;&#x2F;              9 &amp; !7 &#x3D; 0000 1000 &#x3D; 8  (17 &amp; !7 &#x3D; 0001 0000 &#x3D; 16)</span><br></pre></td></tr></table></figure>

<p>所以：<code>word_align</code>计算出来的都是8的倍数。<br>     <code>align16</code>计算出来的都是16的倍数。</p>
<p>这里需要注意的是在ARM64下，内存开辟都是16个字节进行对齐的。所以计算的大小的都是16的倍数。</p>
<h3 id="2-4-2-calloc"><a href="#2-4-2-calloc" class="headerlink" title="2.4.2 calloc"></a>2.4.2 calloc</h3><p>calloc申请开辟内存，返回地址指针。</p>
<h3 id="2-4-3-obj-gt-initInstanceIsa"><a href="#2-4-3-obj-gt-initInstanceIsa" class="headerlink" title="2.4.3 obj-&gt;initInstanceIsa"></a>2.4.3 obj-&gt;initInstanceIsa</h3><p>生成的对象与class进行关联。通过isa指针。（isa之后会有说明，每一个类都有一个isa指针）。</p>
<h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p><img src="oc-alloc.png" alt=""></p>
<p>这个图很好的说明了alloc的流程。</p>
<h1 id="3-init"><a href="#3-init" class="headerlink" title="3. init"></a>3. init</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span><br><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init其实是工厂方法，从上面的代码可以看到，只是<code>return self</code>。这里有一个重要的点，就是大部分的实现都会交给子类去重新自定义init方法。</p>
<h1 id="4-new"><a href="#4-new" class="headerlink" title="4. new"></a>4. new</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false&#x2F;*checkNil*&#x2F;) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到new的实现就是执行了，callAlloc()，然后执行了init操作。与实际上的<code>[[Person alloc] init]</code>并没有什么区别。</p>
<p>但是看到有一些博客上说，还是有区别，因为init被重写之后，调用new可能会造成少些东西。这里不能苟同哈，所有的方法调用，在OC中都是objc_msgSend，会去寻找方法列表的。所以不会存在什么不同。</p>
<h1 id="5-扩展知识"><a href="#5-扩展知识" class="headerlink" title="5. 扩展知识"></a>5. 扩展知识</h1><p>我们已经知道了，本身写一个Person类，需要开辟16个字节的空间，那需要申请多大内存空间是由什么因素决定的？<br>我们可以试一下分别添加一个属性，两个属性，试一下。自己动手试一下哈，看看2.4.1小结处返回的size是多少。其申请内存的大小其实是成员变量说了算。</p>
<p>我这里添加了两个NSString属性，分别赋值A和B。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x600002f86cc0&gt;</span><br><span class="line">(lldb) x p</span><br><span class="line">0x600002f86cc0: 60 76 e3 06 01 00 00 00 40 20 e3 06 01 00 00 00  &#96;v......@ ......</span><br><span class="line">0x600002f86cd0: 60 20 e3 06 01 00 00 00 00 00 00 00 00 00 00 00  &#96; ..............</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4gx p</span><br><span class="line">0x600002f86cc0: 0x0000000106e37660 0x0000000106e32040</span><br><span class="line">0x600002f86cd0: 0x0000000106e32060 0x0000000000000000</span><br><span class="line">(lldb) po 0x0000000106e37660    &#x2F;&#x2F; isa指针，指向class</span><br><span class="line">Person</span><br><span class="line">(lldb) po 0x0000000106e32040</span><br><span class="line">A</span><br><span class="line">(lldb) po 0x0000000106e32060</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<p>通过<code>x p</code>命令我们可以打印出<code>p</code>的内存地址。在源码的运行过程中，断点到size计算那里，打印出来size的大小是<code>32</code>个字节。也就是会空8个字节。</p>
<p>如果声明了4个bool值，则4个bool值则会依次放在内存中，例如：0x0000000001010101，这个就涉及到字节的对齐以及iOS系统对属性的重排（内存优化）。</p>
<h1 id="6-真正的alloc流程"><a href="#6-真正的alloc流程" class="headerlink" title="6. 真正的alloc流程"></a>6. 真正的alloc流程</h1><p>当我们执行<code>[Person alloc]</code>的时候，直接吧断点放在<code>callAlloc-&gt;objc_msgSend</code>，则会先执行消息转发。原因是系统内部会通过llvm的函数方法把<code>alloc</code>指向到<code>objc_alloc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先执行一次<code>callAlloc(cls, true, false)</code>，注意这里的参数。然后执行到calAlloc中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil); &#x2F;&#x2F;1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#x2F;&#x2F; 2.</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); &#x2F;&#x2F; 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行，我们发现会先执行第3个return。所执行的还是<code>alloc</code>，这时候执行的才是真正的alloc。然后就可以顺着第2节的内容继续了。</p>
<p>如图，是完整的alloc会执行两次的流程图：</p>
<p><img src="oc-alloc-2.jpg" alt=""></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>alloc的流程</li>
<li>alloc的两次执行过程</li>
<li>init</li>
<li>new</li>
</ul>
<p>有什么不对的欢迎指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
