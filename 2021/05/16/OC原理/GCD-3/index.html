<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="3WOMyh0YrdEECGDv2GOACbgBEtVz_dJbyA_2G-pjr28">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="信号量先看代码： 123456789101112131415161718192021222324252627282930313233- (void)semaphore &amp;#123;    &#x2F;&#x2F; 全局队列    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);    &#x2F;&#x2F; 初始化一个信">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD底层原理-3">
<meta property="og:url" content="http://liujiaboy.github.io/2021/05/16/OC%E5%8E%9F%E7%90%86/GCD-3/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="信号量先看代码： 123456789101112131415161718192021222324252627282930313233- (void)semaphore &amp;#123;    &#x2F;&#x2F; 全局队列    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);    &#x2F;&#x2F; 初始化一个信">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-16T09:41:00.000Z">
<meta property="article:modified_time" content="2021-05-17T02:21:40.000Z">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Objective-C,">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/2021/05/16/OC%E5%8E%9F%E7%90%86/GCD-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>GCD底层原理-3 | 不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不会飞的小白" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会飞的小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/liujiaboy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/05/16/OC%E5%8E%9F%E7%90%86/GCD-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GCD底层原理-3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 17:41:00" itemprop="dateCreated datePublished" datetime="2021-05-16T17:41:00+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 10:21:40" itemprop="dateModified" datetime="2021-05-17T10:21:40+08:00">2021-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)semaphore &#123;</span><br><span class="line">    &#x2F;&#x2F; 全局队列</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    &#x2F;&#x2F; 初始化一个信号量可以并发执行2个任务</span><br><span class="line">    dispatch_semaphore_t sem &#x3D; dispatch_semaphore_create(2);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;1 start..&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;1 end...&quot;);</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;2 start..&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;2 end...&quot;);</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;3 start..&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;3 end...&quot;);</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先运行一下这个demo，看输出的结果是什么样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2021-05-16 17:38:16.018150+0800 GCDDemo[972:7272767] 1 start..</span><br><span class="line">2021-05-16 17:38:16.018154+0800 GCDDemo[972:7272769] 2 start..</span><br><span class="line">2021-05-16 17:38:17.027319+0800 GCDDemo[972:7272767] 1 end...</span><br><span class="line">2021-05-16 17:38:17.027332+0800 GCDDemo[972:7272769] 2 end...</span><br><span class="line">2021-05-16 17:38:17.027556+0800 GCDDemo[972:7272765] 3 start..</span><br><span class="line">2021-05-16 17:38:18.031174+0800 GCDDemo[972:7272765] 3 end...</span><br></pre></td></tr></table></figure>

<p>我们也需要看打印的时间点，先执行1、2 start，1s之后执行了1、2 end，紧接着执行3。</p>
<p>如果把信号量的初始值改成1呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2021-05-16 18:07:48.061949+0800 GCDDemo[1220:7292903] 1 start..</span><br><span class="line">2021-05-16 18:07:49.063438+0800 GCDDemo[1220:7292903] 1 end...</span><br><span class="line">2021-05-16 18:07:49.063639+0800 GCDDemo[1220:7292901] 2 start..</span><br><span class="line">2021-05-16 18:07:50.063905+0800 GCDDemo[1220:7292901] 2 end...</span><br><span class="line">2021-05-16 18:07:50.064202+0800 GCDDemo[1220:7292906] 3 start..</span><br><span class="line">2021-05-16 18:07:51.064940+0800 GCDDemo[1220:7292906] 3 end...</span><br></pre></td></tr></table></figure>

<p>结果就是先执行1，然后2，3每次间隔都是1s。</p>
<p>为什么能确定并发执行的个数呢？就是因为其中有两个语句，确定了最大的并发数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行-1操作</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#x2F;&#x2F; 执行+1操作</span><br><span class="line">dispatch_semaphore_signal(sem);</span><br></pre></td></tr></table></figure>

<p>分别看一下内部实现。</p>
<h2 id="dispatch-semaphore-create"><a href="#dispatch-semaphore-create" class="headerlink" title="dispatch_semaphore_create"></a>dispatch_semaphore_create</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t</span><br><span class="line">dispatch_semaphore_create(intptr_t value)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema;</span><br><span class="line">	if (value &lt; 0) &#123;</span><br><span class="line">		return DISPATCH_BAD_INPUT;</span><br><span class="line">	&#125;</span><br><span class="line">   &#x2F;&#x2F; 初始化信号量结构体  </span><br><span class="line">	dsema &#x3D; _dispatch_object_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">			sizeof(struct dispatch_semaphore_s));</span><br><span class="line">	dsema-&gt;do_next &#x3D; DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dsema-&gt;do_targetq &#x3D; _dispatch_get_default_queue(false);</span><br><span class="line">	&#x2F;&#x2F; 用来保存初始化的最大并发数</span><br><span class="line">	dsema-&gt;dsema_value &#x3D; value;</span><br><span class="line">	_dispatch_sema4_init(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	dsema-&gt;dsema_orig &#x3D; value;</span><br><span class="line">	return dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧，最开始就已经有判断了，如果创建时的参数小于0，直接返回一个<code>DISPATCH_BAD_INPUT</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DISPATCH_BAD_INPUT		((void *_Nonnull)0)</span><br></pre></td></tr></table></figure>

<p>知道时啥了吗？就是一个野指针。</p>
<p>那我们接下来看<code>dispatch_semaphore_wait</code>函数。</p>
<h2 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">intptr_t</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	long value &#x3D; os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	if (likely(value &gt;&#x3D; 0)) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>os_atomic_dec2o</code>，但是有一个dec，猜测应该是减法操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define os_atomic_dec2o(p, f, m) \</span><br><span class="line">		os_atomic_sub2o(p, f, 1, m)</span><br><span class="line"></span><br><span class="line">#define os_atomic_sub2o(p, f, v, m) \</span><br><span class="line">		os_atomic_sub(&amp;(p)-&gt;f, (v), m)</span><br><span class="line">		</span><br><span class="line">#define os_atomic_sub(p, v, m) \</span><br><span class="line">		_os_atomic_c11_op((p), (v), m, sub, -)</span><br><span class="line">		</span><br><span class="line">#define _os_atomic_c11_op(p, v, m, o, op) \</span><br><span class="line">		(&#123; _os_atomic_basetypeof(p) _v &#x3D; (v), _r &#x3D; \</span><br><span class="line">		atomic_fetch_##o##_explicit(_os_atomic_c11_atomic(p), _v, \</span><br><span class="line">		memory_order_##m); (__typeof__(_r))(_r op _v); &#125;)</span><br></pre></td></tr></table></figure>

<p>一层一层的宏定义，最后可以得出的函数是<code>atomic_fetch_sub_explicit</code>。<br>这是一个C语言的原子类型减的函数。也就是<code>dsema-&gt;dsema_value - 1</code>。</p>
<p>大于等于0都可以正常执行，否则发生等待。</p>
<h2 id="dispatch-semaphore-signal"><a href="#dispatch-semaphore-signal" class="headerlink" title="dispatch_semaphore_signal"></a>dispatch_semaphore_signal</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intptr_t</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	long value &#x3D; os_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">	if (likely(value &gt; 0)) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (unlikely(value &#x3D;&#x3D; LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				&quot;Unbalanced call to dispatch_semaphore_signal()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_semaphore_signal</code>与<code>dispatch_semaphore_wait</code>正好相反，执行的是加法操作，每次加1。</p>
<p>这里的判断条件是<code>value &gt; 0</code>，都可以正常执行，也就是必须有1个才行，否则阻塞线程，一直处于等待状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>dispatch_semaphore_wait</code>和<code>dispatch_semaphore_signal</code>肯定是成对出现的。</p>
<h1 id="dispatch-group-调度组"><a href="#dispatch-group-调度组" class="headerlink" title="dispatch_group 调度组"></a>dispatch_group 调度组</h1><p>当我们在业务中，需要两个网络请求都返回之后，才能处理某一个业务逻辑时，调度组就能很好的发挥作用，而且用起来很简单。</p>
<p>先看一下简单的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)groupDemo &#123;</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    dispatch_queue_t globle &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1.</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(globle, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 start ...&quot;);</span><br><span class="line">        sleep(3);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 2.</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(globle, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 start ...&quot;);</span><br><span class="line">        sleep(3);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3.</span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;3 ...&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行一下代码，发现3是最后执行的。</p>
<p>如果出现<code>dispatch_group_enter</code>比<code>dispatch_group_leave</code>多的情况呢？<br>不会发生crash。</p>
<p>如果出现<code>dispatch_group_leave</code>比<code>dispatch_group_enter</code>多的情况呢？<br>会发生crash。</p>
<p>这里需要注意的是：</p>
<ol>
<li><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>是成对出现的。<br> 不管执行的顺序如何，必须保证成对出现，否则不会触发<code>dispatch_group_notify</code>。</li>
<li><code>dispatch_group_notify</code>一般出现在最下边，有<code>dispatch_group_leave</code>就会触发，可以把3的代码放在最上边试一下。</li>
<li><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>可以使用<code>dispatch_group_async</code>来代替，减少代码量以及没有成对出现可能带来的问题。</li>
<li><code>dispatch_group_wait</code>设置超时时间，如果超时了任务还没有执行完成，则会直接触发<code>dispatch_group_notify</code>。</li>
</ol>
<p>这些代码可以试一下哈，我们接下来看内部实现原理。</p>
<h2 id="dispatch-group-create"><a href="#dispatch-group-create" class="headerlink" title="dispatch_group_create"></a>dispatch_group_create</h2><p>首先我们先看一下group的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t</span><br><span class="line">dispatch_group_create(void)</span><br><span class="line">&#123;</span><br><span class="line">	return _dispatch_group_create_with_count(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>_dispatch_group_create_with_count</code>，参数是一个0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static inline dispatch_group_t</span><br><span class="line">_dispatch_group_create_with_count(uint32_t n)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 初始化dg，dispatch_group_s是一个结构体</span><br><span class="line">	dispatch_group_t dg &#x3D; _dispatch_object_alloc(DISPATCH_VTABLE(group),</span><br><span class="line">			sizeof(struct dispatch_group_s));</span><br><span class="line">	&#x2F;&#x2F; 赋默认值</span><br><span class="line">	dg-&gt;do_next &#x3D; DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dg-&gt;do_targetq &#x3D; _dispatch_get_default_queue(false);</span><br><span class="line">	&#x2F;&#x2F; n &#x3D; 0，所以创建的时候永远不会执行这里。</span><br><span class="line">	if (n) &#123;</span><br><span class="line">		os_atomic_store2o(dg, dg_bits,</span><br><span class="line">				(uint32_t)-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);</span><br><span class="line">		os_atomic_store2o(dg, do_ref_cnt, 1, relaxed); &#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;22318411&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	return dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建group还是很好理解的，接下来看<code>dispatch_group_enter</code></p>
<h2 id="dispatch-group-enter"><a href="#dispatch-group-enter" class="headerlink" title="dispatch_group_enter"></a>dispatch_group_enter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_enter(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; The value is decremented on a 32bits wide atomic so that the carry</span><br><span class="line">	&#x2F;&#x2F; for the 0 -&gt; -1 transition is not propagated to the upper 32bits.</span><br><span class="line">	&#x2F;&#x2F; dg-&gt;dg_bits的值从0 变成 -1</span><br><span class="line">	uint32_t old_bits &#x3D; os_atomic_sub_orig2o(dg, dg_bits,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, acquire);</span><br><span class="line">	uint32_t old_value &#x3D; old_bits &amp; DISPATCH_GROUP_VALUE_MASK;</span><br><span class="line">	&#x2F;&#x2F; 等于0</span><br><span class="line">	if (unlikely(old_value &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">		_dispatch_retain(dg); &#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;22318411&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 我们上面执行了多个enter之后，没有发生crash，但是这里也有解释</span><br><span class="line">	&#x2F;&#x2F; 超过一个最大值时也会发生crash</span><br><span class="line">	if (unlikely(old_value &#x3D;&#x3D; DISPATCH_GROUP_VALUE_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(old_bits,</span><br><span class="line">				&quot;Too many nested calls to dispatch_group_enter()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os_atomic_sub_orig2o</code>这个函数跟上面信号量的函数有点类似，并且已经给了注释：dg-&gt;dg_bits的值从0 变成 -1。</p>
<h2 id="dispatch-group-leave"><a href="#dispatch-group-leave" class="headerlink" title="dispatch_group_leave"></a>dispatch_group_leave</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_leave(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; The value is incremented on a 64bits wide atomic so that the carry for</span><br><span class="line">	&#x2F;&#x2F; the -1 -&gt; 0 transition increments the generation atomically.</span><br><span class="line">	&#x2F;&#x2F; dg_state从-1 -&gt; 0 </span><br><span class="line">	uint64_t new_state, old_state &#x3D; os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, release);</span><br><span class="line">	uint32_t old_value &#x3D; (uint32_t)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">	if (unlikely(old_value &#x3D;&#x3D; DISPATCH_GROUP_VALUE_1)) &#123;</span><br><span class="line">		old_state +&#x3D; DISPATCH_GROUP_VALUE_INTERVAL;</span><br><span class="line">		do &#123;</span><br><span class="line">			new_state &#x3D; old_state;</span><br><span class="line">			if ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				new_state &amp;&#x3D; ~DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">				new_state &amp;&#x3D; ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F; If the group was entered again since the atomic_add above,</span><br><span class="line">				&#x2F;&#x2F; we can&#39;t clear the waiters bit anymore as we don&#39;t know for</span><br><span class="line">				&#x2F;&#x2F; which generation the waiters are for</span><br><span class="line">				new_state &amp;&#x3D; ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125;</span><br><span class="line">			if (old_state &#x3D;&#x3D; new_state) break;</span><br><span class="line">		&#125; while (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,</span><br><span class="line">				old_state, new_state, &amp;old_state, relaxed)));</span><br><span class="line">		return _dispatch_group_wake(dg, old_state, true);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; old_value</span><br><span class="line">	if (unlikely(old_value &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((uintptr_t)old_value,</span><br><span class="line">				&quot;Unbalanced call to dispatch_group_leave()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一步一步的分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint64_t new_state, old_state &#x3D; os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">		DISPATCH_GROUP_VALUE_INTERVAL, release);</span><br></pre></td></tr></table></figure>


<p>这里有注释，写了解释内容，从-1变成了0，所以：<br>old_state = -1, new_state = 0 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t old_value &#x3D; (uint32_t)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">#define DISPATCH_GROUP_VALUE_MASK       0x00000000fffffffcULL</span><br></pre></td></tr></table></figure>

<p>old_value 是通过&amp;运算得来的， -1 = 0xfffffffff，是一个全是1的二进制数，所以&amp;运算之后old_value = DISPATCH_GROUP_VALUE_MASK。</p>
<p>如果再执行一次leave操作，那么old_state=0,然后经过&amp;运算，old_value=0，也就是最后会发生crash。所以enter和leave一定要成对出现。</p>
<p>接下来就到重点了，当enter和leave达到平衡时，就会触发<code>_dispatch_group_wake</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">_dispatch_group_wake(dispatch_group_t dg, uint64_t dg_state, bool needs_release)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t refs &#x3D; needs_release ? 1 : 0; &#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;22318411&gt;</span><br><span class="line">    &#x2F;&#x2F; &amp;运算 </span><br><span class="line">	if (dg_state &amp; DISPATCH_GROUP_HAS_NOTIFS) &#123;</span><br><span class="line">		dispatch_continuation_t dc, next_dc, tail;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Snapshot before anything is notified&#x2F;woken &lt;rdar:&#x2F;&#x2F;problem&#x2F;8554546&gt;</span><br><span class="line">		dc &#x3D; os_mpsc_capture_snapshot(os_mpsc(dg, dg_notify), &amp;tail);</span><br><span class="line">		do &#123;</span><br><span class="line">			dispatch_queue_t dsn_queue &#x3D; (dispatch_queue_t)dc-&gt;dc_data;</span><br><span class="line">			next_dc &#x3D; os_mpsc_pop_snapshot_head(dc, tail, do_next);</span><br><span class="line">			&#x2F;&#x2F; 执行这个操作，在第一章中有介绍，执行dx_push操作。直到block执行完成</span><br><span class="line">			_dispatch_continuation_async(dsn_queue, dc,</span><br><span class="line">					_dispatch_qos_from_pp(dc-&gt;dc_priority), dc-&gt;dc_flags);</span><br><span class="line">			_dispatch_release(dsn_queue);</span><br><span class="line">		&#125; while ((dc &#x3D; next_dc));</span><br><span class="line"></span><br><span class="line">		refs++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (dg_state &amp; DISPATCH_GROUP_HAS_WAITERS) &#123;</span><br><span class="line">		_dispatch_wake_by_address(&amp;dg-&gt;dg_gen);</span><br><span class="line">	&#125;</span><br><span class="line">   &#x2F;&#x2F; 释放</span><br><span class="line">	if (refs) _dispatch_release_n(dg, refs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h2><p>接下来我们看一下<code>dispatch_group_notify</code>操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_notify(dispatch_group_t dg, dispatch_queue_t dq,</span><br><span class="line">		dispatch_block_t db)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dsn &#x3D; _dispatch_continuation_alloc();</span><br><span class="line">	_dispatch_continuation_init(dsn, dq, db, 0, DC_FLAG_CONSUME);</span><br><span class="line">	_dispatch_group_notify(dg, dq, dsn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_continuation_init</code> 内部是对属性赋值，保存dg(group)、dq(queue)、db(block)。在第一章有介绍。</p>
<p><code>_dispatch_group_notify</code>的函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static inline void</span><br><span class="line">_dispatch_group_notify(dispatch_group_t dg, dispatch_queue_t dq,</span><br><span class="line">		dispatch_continuation_t dsn)</span><br><span class="line">&#123;</span><br><span class="line">	uint64_t old_state, new_state;</span><br><span class="line">	dispatch_continuation_t prev;</span><br><span class="line"></span><br><span class="line">	dsn-&gt;dc_data &#x3D; dq;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line"></span><br><span class="line">	prev &#x3D; os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);</span><br><span class="line">	if (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);</span><br><span class="line">	if (os_mpsc_push_was_empty(prev)) &#123;</span><br><span class="line">		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, release, &#123;</span><br><span class="line">			new_state &#x3D; old_state | DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#x2F;&#x2F; 重点哈~</span><br><span class="line">			if ((uint32_t)old_state &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(&#123;</span><br><span class="line">					return _dispatch_group_wake(dg, new_state, false);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会有一系列的判断，当old_value=0的时候，执行wake操作。</p>
<h2 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_async(dispatch_group_t dg, dispatch_queue_t dq,</span><br><span class="line">		dispatch_block_t db)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc &#x3D; _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags &#x3D; DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;</span><br><span class="line">	dispatch_qos_t qos;</span><br><span class="line">  &#x2F;&#x2F; 任务包装器，存储block等信息</span><br><span class="line">	qos &#x3D; _dispatch_continuation_init(dc, dq, db, 0, dc_flags);</span><br><span class="line">&#x2F;&#x2F; 重点	_dispatch_continuation_group_async(dg, dq, dc, qos);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>


<p>这里的重点代码是<code>_dispatch_continuation_group_async</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline void</span><br><span class="line">_dispatch_continuation_group_async(dispatch_group_t dg, dispatch_queue_t dq,</span><br><span class="line">		dispatch_continuation_t dc, dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_enter(dg);</span><br><span class="line">	dc-&gt;dc_data &#x3D; dg;</span><br><span class="line">	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧，其内部有自动执行<code>dispatch_group_enter</code>操作。但是什么时候执行的leave呢？还记得上一章中介绍<code>_dispatch_continuation_invoke_inline</code>的时候吗？里头有一局代码是关于group的操作，我还专门写了注释。</p>
<p><code>_dispatch_continuation_async</code>是执行dx_push操作。</p>
<p><code>_dispatch_continuation_invoke_inline</code>在group的情况会值执行group相关的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline void</span><br><span class="line">_dispatch_continuation_with_group_invoke(dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">	struct dispatch_object_s *dou &#x3D; dc-&gt;dc_data;</span><br><span class="line">	unsigned long type &#x3D; dx_type(dou);</span><br><span class="line">	if (type &#x3D;&#x3D; DISPATCH_GROUP_TYPE) &#123;</span><br><span class="line">		_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">		_dispatch_trace_item_complete(dc);</span><br><span class="line">		dispatch_group_leave((dispatch_group_t)dou);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		DISPATCH_INTERNAL_CRASH(dx_type(dou), &quot;Unexpected object type&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯哼~这里也会执行<code>dispatch_group_leave</code>操作，这也就是dispatch_group_async可以代替enter和leave的原因。<br>下面的代码可以很好的解释<code>dispatch_group_async</code>的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_retain(group);</span><br><span class="line">	dispatch_group_enter(group);</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		block();</span><br><span class="line">		dispatch_group_leave(group);</span><br><span class="line">		dispatch_release(group);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h1><p><code>dispatch_source</code>是一个更为底层，直接与内核交互的东西，所以它执行起来会更快，效率更高。所以type类型是time的时候，准确率是最高的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger totalComplete &#x3D; 0</span><br><span class="line">&#x2F;&#x2F; 创建DISPATCH_SOURCE_TYPE_DATA_ADD类型的source，再主线程执行</span><br><span class="line">dispatch_source_t source &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置block回调</span><br><span class="line">dispatch_source_set_event_handler(self.source, ^&#123;</span><br><span class="line">    &#x2F;&#x2F; 获取数据</span><br><span class="line">    NSUInteger value &#x3D; dispatch_source_get_data(self.source);</span><br><span class="line">    totalComplete +&#x3D; value;</span><br><span class="line">    NSLog(@&quot;进度: %.2f&quot;, totalComplete&#x2F;100.0);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开始执行</span><br><span class="line">dispatch_resume(source);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步执行for</span><br><span class="line">for (int i&#x3D; 0; i&lt;100; i++) &#123;</span><br><span class="line">    dispatch_async(self.queue, ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#x2F;&#x2F; merge数据，每次+1，每次merge就会触发dispatch_source_set_event_handler</span><br><span class="line">        dispatch_source_merge_data(self.source, 1);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(100 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    &#x2F;&#x2F; 停止</span><br><span class="line">    dispatch_suspend(_source);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面内容就是source相关的。不是很常用，了解一下。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ol>
<li>dispatch_semaphore信号量<ol>
<li><code>dispatch_semaphore_signal</code>与<code>dispatch_semaphore_wait</code>成对出现。</li>
<li><code>dispatch_semaphore_signal</code>是+1操作</li>
<li><code>dispatch_semaphore_wait</code>是-1操作</li>
</ol>
</li>
<li>dispatch_group调度组<ol>
<li>enter和leave是成对出现的，否则可能发生crash</li>
<li><code>dispatch_group_notify</code>一般放在最下边执行。</li>
<li><code>dispatch_group_async</code>可以替代enter和leave两个操作。</li>
<li><code>dispatch_group_wait</code>超时操作。</li>
</ol>
</li>
<li>source，每次执行merge操作就会执行block。</li>
</ol>
<p>以上就是GCD的相关内容了，写了3章，有不对的地方欢迎指正。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Objective-C/" rel="tag"># Objective-C,</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/14/%E9%80%86%E5%90%91/mima-3-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" rel="prev" title="对称加密">
      <i class="fa fa-chevron-left"></i> 对称加密
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/16/OC%E5%8E%9F%E7%90%86/%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86/" rel="next" title="锁的原理">
      锁的原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#信号量"><span class="nav-number">1.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-semaphore-create"><span class="nav-number">1.1.</span> <span class="nav-text">dispatch_semaphore_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-semaphore-wait"><span class="nav-number">1.2.</span> <span class="nav-text">dispatch_semaphore_wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-semaphore-signal"><span class="nav-number">1.3.</span> <span class="nav-text">dispatch_semaphore_signal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dispatch-group-调度组"><span class="nav-number">2.</span> <span class="nav-text">dispatch_group 调度组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group-create"><span class="nav-number">2.1.</span> <span class="nav-text">dispatch_group_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group-enter"><span class="nav-number">2.2.</span> <span class="nav-text">dispatch_group_enter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group-leave"><span class="nav-number">2.3.</span> <span class="nav-text">dispatch_group_leave</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group-notify"><span class="nav-number">2.4.</span> <span class="nav-text">dispatch_group_notify</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group-async"><span class="nav-number">2.5.</span> <span class="nav-text">dispatch_group_async</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dispatch-source"><span class="nav-number">3.</span> <span class="nav-text">dispatch_source</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结-1"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
